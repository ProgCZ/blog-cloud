<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ProgCZ&#39;s Blog</title>
  
  <subtitle>Wubba Lubba Dub Dub</subtitle>
  <link href="https://progcz.com/atom.xml" rel="self"/>
  
  <link href="https://progcz.com/"/>
  <updated>2022-07-10T13:15:34.000Z</updated>
  <id>https://progcz.com/</id>
  
  <author>
    <name>ProgCZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 Azure Storage、CDN 和 DNS 服务部署静态博客</title>
    <link href="https://progcz.com/posts/1657454864/"/>
    <id>https://progcz.com/posts/1657454864/</id>
    <published>2022-07-10T12:09:04.000Z</published>
    <updated>2022-07-10T13:15:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>停更的这小半年，我自己身上发生了很多事情，自认为还算坚强地硬撑了过来。</p><p>尽管还在阴影之中，没有完全脱离，但是生活还得继续，折腾反而能让我从痛苦的父进程里 fork 出来，在这个只有我自己存在的子进程里，时间的流速也大大加快，这可是我求之不得的事情。</p><p>所以，趁着周末我又来折腾了，这次是把之前托管在 GitHub Pages 的静态博客，迁移到了 Azure Storage 和 CDN，顺便迁移了 DNS。</p><p><img data-src="https://image.progcz.com/2022/07/10/01.png"></p><span id="more"></span><h2 id="1-以前的方案"><a href="#1-以前的方案" class="headerlink" title="1 以前的方案"></a>1 以前的方案</h2><ul><li><p><strong>博客的 MD 源文件托管在 GitHub 仓库，借助 GitHub Actions 完成 Hexo 的解析，详情可见<a href="/posts/apply-github-actions-to-deploy-hexo-blog/">这篇文章</a>。</strong></p></li><li><p><strong>博客的 HTML 文件托管在 GitHub 仓库，自动部署至 GitHub Pages。</strong>毋须多言，从国内访问博客的速度较慢，而且作为一个中文博客，不能被百度收录，白白流失了不少流量<del>（瞧不上百度，还馋人家流量，有点过分）</del>。</p></li><li><p><strong>博客的自定义 CSS 和 JS 文件，以及图片都托管在 GitHub 仓库，借助 jsDelivr 分发，后来 jsDelivr 在围城内挂了，于是迁到了 cdnjs 和 Staticaly。</strong>可以看出，这些文件依赖的免费第三方服务是无法得到保障的，因为免费总是意味着会被滥用，随之而来必然是色情暴力政治宗教，所以迟早会被封禁。当然，一些公共的 CSS 和 JS 文件用这些 CDN 服务还是挺香的。</p></li></ul><p>当然，这些缺点在贫穷的我看来都还可以忍受，但架不住<strong>来微软之后，员工每月都有 $150 的 Azure 额度，</strong>本着「不用白不用」的古老智慧，动了这次迁移的念头。</p><p>但是说实话，如果不是送的额度，个人用户大概率不会选择 Azure 来搭博客，因为 Azure 主要面向企业用户，主打高可用性，所以 resource 普遍较贵。</p><p>Anyway，一个月之后我来补充一下，看看我这小博客能用掉多少钱。</p><h2 id="2-现在的方案"><a href="#2-现在的方案" class="headerlink" title="2 现在的方案"></a>2 现在的方案</h2><ul><li>博客和图片的 GitHub 仓库都不变，只是 CI/CD 里多加了几步，把 Hexo 解析后的 HTML 文件上传至 Azure Storage，借助 Azure CDN 分发，再用 Azure DNS 绑上自己的域名。</li></ul><hr><p>未完待续，困了，明天再写。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;停更的这小半年，我自己身上发生了很多事情，自认为还算坚强地硬撑了过来。&lt;/p&gt;
&lt;p&gt;尽管还在阴影之中，没有完全脱离，但是生活还得继续，折腾反而能让我从痛苦的父进程里 fork 出来，在这个只有我自己存在的子进程里，时间的流速也大大加快，这可是我求之不得的事情。&lt;/p&gt;
&lt;p&gt;所以，趁着周末我又来折腾了，这次是把之前托管在 GitHub Pages 的静态博客，迁移到了 Azure Storage 和 CDN，顺便迁移了 DNS。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://image.progcz.com/2022/07/10/01.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="折腾" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="Azure" scheme="https://progcz.com/tags/Azure/"/>
    
    <category term="Azure Storage" scheme="https://progcz.com/tags/Azure-Storage/"/>
    
    <category term="Azure CDN" scheme="https://progcz.com/tags/Azure-CDN/"/>
    
    <category term="Azure DNS" scheme="https://progcz.com/tags/Azure-DNS/"/>
    
    <category term="Blog" scheme="https://progcz.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>从「腾讯应届生声讨加班事件」谈谈国内大厂的工作现状</title>
    <link href="https://progcz.com/posts/1643205354/"/>
    <id>https://progcz.com/posts/1643205354/</id>
    <published>2022-01-27T06:44:09.000Z</published>
    <updated>2022-01-27T11:54:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天在 V2EX 看到<a href="https://v2ex.com/t/830681">腾讯应届生声讨加班事件的帖子</a>，心中不免有些共鸣，想想自己曾是大厂员工，也有过同样的感受，于是想借此热点，聊聊国内大厂，说说一枚螺丝钉的想法。</p><p><img data-src="https://image.progcz.com/2022/01/26/01.jpg"></p><span id="more"></span><p>如果你还不了解事件的来龙去脉，可以去看看主人公 folezhang 自己整理的<a href="https://docs.google.com/document/d/1kxKl06QCgboPSkCULkWX-IvYHx93ZgBm/edit"><strong>《关于声讨加班事件的说明》</strong></a>，条理清晰，逻辑严密。<del>如果套用字节内部的梗来说就是，这位老哥非常善文。</del></p><blockquote><p>需要注意的是，文档放在 Google Docs，需要科学上网。（写到这里，我的第一想法还是，为啥不用更容易在国内传播的腾讯文档。随即才意识到，如果是腾讯文档，那大概就不会有传播的机会了吧。）</p></blockquote><p>简单来讲，企微部门在给员工颁奖时，在评语中赞扬了该员工的加班行为：</p><img data-src="https://image.progcz.com/2022/01/26/02.png" width=70%><p>folezhang 当场怒怼：</p><img data-src="https://image.progcz.com/2022/01/26/03.png" width=70%><p>说起来，我挺能理解 folezhang 的愤怒。</p><p><strong>这怒气里，有一小部分针对获奖同事及各位同僚，怒其为了工作而不顾身体。</strong></p><p>回想自己，<strong>如果只用一个字来形容在字节的工作体验，那一定是「累」。</strong></p><p>这种累不仅是生理上的，更是心理上的，大量琐碎且排期紧张的工作，常常压得我喘不过气，甚至工作中的事情还屡次出现在梦里，等我醒来的时候发现自己浑身都是冷汗。</p><p>要说成长，那肯定是有的，正所谓「字节一年，人间三年」，四舍五入我也是有五年工作经验的人了（狗头）。</p><p><strong>毕竟玩游戏都可以靠「肝」来涨经验，谁说工作不可以呢？</strong></p><p><strong>这怒气里，还有大部分针对企微部门及国内大厂，怒其鼓励加班仍不知整改。</strong></p><p>国内大厂能有如今的成就，从时代的角度来说，是吃尽了移动互联网的红利。</p><p>那如何才能从同一个锅里，盛尽量多的饭到自己碗里？</p><p>对于这个问题，大厂之间展现出了惊人的默契，那就是：<strong>让员工多干活少休息，</strong>三天上线新需求，一个月上线新产品，未来半年突破百万日活。</p><p><strong>最让人痛心的是，这样的做法真的有效果。</strong></p><p>臭名昭著的血汗工厂拼多多，一度跻身国内第四大互联网公司，业内公认的养老公司豆瓣，如今靠评分和八卦勉强度日。</p><p>尽管过去一年监管不断重锤出击，国内大厂看起来也确实像在反思了，但是很多改进都还停留在纸面。</p><p>比如去年十一月的某天早上，HR 部门的某篇文档传遍了字节甚至整个互联网，文档中规定员工的工作时间为早上十点至晚上七点，超出时间可以申请加班，有加班费。</p><p>但是不同以往，如此重要的事情，既没有全员邮件，也没有领导通知，宛如房间里的大象。直到两个月后我离职的那天，这项规定都没能真正推行下去。</p><p>从这件事情，我甚至能看到决策者的挣扎：一方面是政府和舆论，让公司不得不下场表态，而另一方面是流量和竞争，也让公司不敢将其付诸行动。</p><p>很多年前，我就看到过这样一句话，至今深以为然：</p><blockquote><p><strong>入职以后，公司给每位员工发了一台电脑，表面上看是每个人拥有了一台电脑，其实是给每台电脑配了一个人。</strong></p></blockquote><p>我也看到过这样一张图，不免苦笑：</p><p><img data-src="https://image.progcz.com/2022/01/26/04.jpg"></p><p>写到最后，不知怎么突然想起了马丁·路德·金的 <em>I Have a Dream</em>，这场为了推动黑人争取民权而进行的演讲，彼时彼刻，恰如此时此刻。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;昨天在 V2EX 看到&lt;a href=&quot;https://v2ex.com/t/830681&quot;&gt;腾讯应届生声讨加班事件的帖子&lt;/a&gt;，心中不免有些共鸣，想想自己曾是大厂员工，也有过同样的感受，于是想借此热点，聊聊国内大厂，说说一枚螺丝钉的想法。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://image.progcz.com/2022/01/26/01.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="看法" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/%E7%9C%8B%E6%B3%95/"/>
    
    
    <category term="腾讯" scheme="https://progcz.com/tags/%E8%85%BE%E8%AE%AF/"/>
    
    <category term="字节跳动" scheme="https://progcz.com/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"/>
    
    <category term="加班" scheme="https://progcz.com/tags/%E5%8A%A0%E7%8F%AD/"/>
    
  </entry>
  
  <entry>
    <title>微软（苏州）面试经历：从入门到入职</title>
    <link href="https://progcz.com/posts/1638593506/"/>
    <id>https://progcz.com/posts/1638593506/</id>
    <published>2021-12-04T04:55:51.000Z</published>
    <updated>2021-12-07T09:13:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>年末，微软面试终于告一段落，目前已经签定 Offer Letter，处于背调阶段，不出意外的话，月底就会入职。</p><p>在准备面试的过程中，一众大佬的面经给了我很多启发，如今到了薪火相传的时候，希望我的面经对你也能有所帮助。</p><p><img data-src="https://image.progcz.com/2021/12/07/01.png"></p><span id="more"></span><div class="note success"><p><strong>微软内推，可以发送邮件至 <a href="mailto:progcz@yeah.net">progcz@yeah.net</a>，记得附上简历、心仪的岗位及链接（可以<a href="https://careers.microsoft.com/us/en/search-results">官网</a>搜索）和简单的自我介绍哦。</strong></p></div><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><p>面经，向来是典型的「小马过河」问题。不同的人有着不同的教育和工作经历，装备等级在一定程度上影响着打怪难度，所以<strong>你我的背景越相近，面经才越具备参考价值。</strong></p><h3 id="1-1-教育经历"><a href="#1-1-教育经历" class="headerlink" title="1.1 教育经历"></a>1.1 教育经历</h3><p>2017 年本科毕业于厦门大学测控技术与仪器专业，2020 年硕士毕业于中国科学技术大学控制工程专业。所以，我并非计算机科班出身，更多是靠选修和自学来接触的编程。</p><h3 id="1-2-工作经历"><a href="#1-2-工作经历" class="headerlink" title="1.2 工作经历"></a>1.2 工作经历</h3><p>2020 年入职字节跳动（上海），担任推荐算法工程师。至于为什么离开字节，我想这应该是下一篇文章的主题了，写在正式离开字节之后。</p><h3 id="1-3-面试岗位"><a href="#1-3-面试岗位" class="headerlink" title="1.3 面试岗位"></a>1.3 面试岗位</h3><p>微软（苏州），Windows 365 软件开发工程师。</p><blockquote><p>JD 参考：<a href="https://careers.microsoft.com/us/en/job/1168023/Windows-365-Software-Engineer">https://careers.microsoft.com/us/en/job/1168023/Windows-365-Software-Engineer</a></p></blockquote><h2 id="2-简历"><a href="#2-简历" class="headerlink" title="2 简历"></a>2 简历</h2><p>如下所示，我并没有套用模板，只是参考了下简历一般需要哪些信息，然后用 Word 最基础的功能，做了一份够简的简历出来。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://image.progcz.com/2021/12/07/02.png"></div><div class="group-picture-column"><img data-src="https://image.progcz.com/2021/12/07/03.png"></div></div></div><p>几点可能有用的建议：</p><ul><li><p>准备中、英两版简历，做在同一个 Word 文件中，导入同一个 PDF 文件中。</p></li><li><p>保持简洁，重要的信息，尤其是与所面岗位相契合的信息，应该大书特书，占最大的版面。</p></li></ul><h2 id="3-人生问题"><a href="#3-人生问题" class="headerlink" title="3 人生问题"></a>3 人生问题</h2><p><strong>开个文档，针对面试中常见的人生问题，把答案提前准备一遍，每个答案都尽量保持在 5 - 10 分钟。</strong></p><p>准备的过程，其实也是与自己对话的过程，因此这样做并不是为了弄虚作假，而是为了在被问到的时候，能够从容应对，逻辑清晰地表达内心想法。</p><p>比如：</p><ul><li><p>为什么想离开上一家公司？为什么想加入我们这家公司？</p></li><li><p>简单介绍一下简历上的某个项目？你在其中承担哪一部分的工作？遇到最大的挑战是什么？</p></li><li><p>未来的职业规划是什么？想成为一个什么样的工程师？</p></li><li><p>简单介绍一下自己的优缺点？</p></li><li><p>有什么想问我的吗？</p></li></ul><h2 id="4-算法题目"><a href="#4-算法题目" class="headerlink" title="4 算法题目"></a>4 算法题目</h2><p>优先刷下 LeetCode 的 <a href="https://leetcode.com/problemset/all/?listId=wpwgkgt&page=1">Top Interview Questions</a>，难度在 Medium 及以下即可。</p><p>几点可能有用的建议：</p><ul><li><p>每道题目限定 20 分钟，没做出来直接去看 Discuss 里 Most Votes 的答案（如果英文吃力，可以参考 <a href="https://www.cnblogs.com/grandyang/p/4606334.html">LeetCode All in One</a> 项目），看完之后自己手写一遍。</p></li><li><p>不要满足于仅一种解法，要问这么几个问题：</p><ul><li><p>现在这个解法，时间复杂度、空间复杂度是多少？</p></li><li><p>还有没有解法，可以降低时间复杂度，或者降低空间复杂度，或者写法上更简洁？</p></li></ul></li><li><p>会讲思路，在写代码前能把解法口头描述出来。</p></li><li><p>会写测试代码和测试用例，在运行前能考虑到尽量多的 corner case，在运行后能根据 error case 分析代码中的 bug。</p>  <details class="note info"><summary><p>面试过程中，推荐使用 LeetCode 的 <a href="https://leetcode.com/playground/">Playground</a> 编写代码，相比 <a href="https://codeshare.io/">Codeshare</a>，Playground 可以在线编译并运行，测试起来非常方便<strong>（微软的面试官都非常注重测试）</strong>。</p></summary><p>比如，我在<a href="/posts/1633654398/">常见排序算法的 C++ 实现、复杂度和稳定性分析</a>中给出的 <a href="https://leetcode.com/playground/gZfypPAn">Playground</a>：</p><p><img data-src="https://image.progcz.com/2021/12/07/04.png"></p></details></li></ul><h2 id="5-面试"><a href="#5-面试" class="headerlink" title="5 面试"></a>5 面试</h2><p>简单记录一下我的面试过程，以供参考。</p><h3 id="5-1-第一轮面试"><a href="#5-1-第一轮面试" class="headerlink" title="5.1 第一轮面试"></a>5.1 第一轮面试</h3><p>常规，聊工作项目，做算法题目。</p><ul><li><p>算法题目：给定一个由 <code>0</code> 和 <code>1</code> 组成的矩阵，从左上角出发，只能向右或向下移动，<code>0</code> 表示可以通行，<code>1</code> 表示不可通行，求解到达右下角的不同路径的数量。原题参考：<a href="https://leetcode.com/problems/unique-paths-ii/">LeetCode 63. Unique Paths II</a></p><p>  解法：动态规划，维护一个同样尺寸的矩阵，矩阵中的每个值代表从左上角到这一格的不同路径的数量，那么容易得到，每个值都是其左侧格（如有）的值与其上方格（如有）的值之和，而该矩阵左上角的值确定为 <code>1</code>，则从左上角开始遍历更新，最终返回右下角的值即可。</p>  <div class="note success"><p>上述解法写完之后，我主动与面试官进一步讲了，如何将空间复杂度从 <code>O(n^2)</code> 优化至 <code>O(n)</code>：不需要维护整个矩阵，只需要维护遍历位置的当前行即可。我相信这应该是个加分项。</p></div></li></ul><h3 id="5-2-第二轮面试（连续三场）"><a href="#5-2-第二轮面试（连续三场）" class="headerlink" title="5.2 第二轮面试（连续三场）"></a>5.2 第二轮面试（连续三场）</h3><p>连续三场面试真的很累，一定注意精力管理。</p><h4 id="第一场"><a href="#第一场" class="headerlink" title="第一场"></a>第一场</h4><p>科大师兄，聊学校，聊毕业论文（这个让我有点意外，我以为社招只会聊工作项目），做算法题目。</p><ul><li><p>算法题目：给定一个 <code>long long</code> 类型的数字，以 <code>long long</code> 类型返回其 reverse 后的数字。相似题目参考：<a href="https://leetcode.com/problems/reverse-integer/">LeetCode 7. Reverse Integer</a></p><p>  解法：题目并不难，主要考察如何处理 corner case，比如负数、结果值溢出、中间值溢出等情况。</p></li></ul><h4 id="第二场"><a href="#第二场" class="headerlink" title="第二场"></a>第二场</h4><p>常规，聊工作项目，做算法题目。</p><ul><li><p>算法题目一：给定一个尺寸为 n 的数组，其值均在 [1, n+1] 之间，有且只有一个数字不在这个数组中，找出这个数字。</p><p>  解法：题目并不难，实际上简单的数学运算就可以，但是面试官还是问了有没有其他解法，最后写了一个使用两轮异或运算的解法。</p></li><li><p>算法题目二：给定一个数组和一个目标值，在数组中找到三数之和，使其最接近目标值。原题参考：<a href="https://leetcode.com/problems/3sum-closest">LeetCode 16. 3Sum Closest</a></p><p>  解法：面试过程中只给了暴力解法，面试结束后才想起来，使用头尾双指针的解法，可以把时间复杂度优化到 <code>O(n^2)</code>。</p></li></ul><h4 id="第三场"><a href="#第三场" class="headerlink" title="第三场"></a>第三场</h4><p>科大师兄，聊工作项目，问 C++ 题目，做算法题目。</p><ul><li><p>C++ 题目：C++ 11 相比于 C++ 98，有什么新特性？智能指针 <code>unique_ptr</code> 是怎么实现资源独占的？</p><p>  答案：第一个问题老生常谈，可以参考<a href="/posts/1634567000/#%E7%9B%B8%E6%AF%94%E4%BA%8E-C-98%EF%BC%8CC-11-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F">面试中常见的 C++ 问题汇总</a>；第二个问题，面试过程中猜错了，正确答案是 <code>unique_ptr</code> 使用 <code>= delete</code> 禁用了拷贝构造函数。</p></li><li><p>算法题目：对于带有随机指针的链表，进行深拷贝。原题参考：<a href="https://leetcode.com/problems/copy-list-with-random-pointer/">LeetCode 138. Copy List with Random Pointer</a></p><p>  解法：第一轮遍历，先不考虑随机指针的拷贝，遍历原链表，构造新链表，在遍历过程中，将新链表节点的随机指针指向原链表节点，同时维护从原链表节点到新链表节点的映射；第二轮遍历，遍历新链表，从新链表节点的随机指针找到原链表节点，再从原链表节点的随机指针找到原链表随机节点，再从映射找到新链表随机节点，赋值给新链表的随机指针即可。</p>  <div class="note info"><p>解法的难度是一方面，测试的难度才是真正考察的点。</p><p>在面试过程中，为了方便测试，我实现了 <code>MyListNode* vec2list(vector&lt;pair&lt;int, int&gt;&gt;&amp; vec);</code> 将测试用例从数组形式构造为链表形式，实现了 <code>bool valid(MyListNode* root_1, MyListNode* root_2);</code> 用来判断两个链表是否互为深拷贝的关系。</p><p>尤其是 <code>valid</code> 这个函数，千算万算还是百密一疏，面试官最后指出了其中可能存在的漏洞。</p></div></li></ul><h3 id="5-3-第三轮面试"><a href="#5-3-第三轮面试" class="headerlink" title="5.3 第三轮面试"></a>5.3 第三轮面试</h3><p>最后一面是跟老板（竟然也是科大师兄）面，邮件里的 PRINCIPAL GROUP SW ENG MGR 格外显眼。</p><p>其实能到最后一面，说明候选人在技术方面没什么太大问题，<strong>老板考察更多的是，候选人是否具备成为优秀工程师的基本素养。</strong></p><ul><li><p>人生问题：</p><ol><li><p>为什么想离开字节，为什么想加入微软？</p></li><li><p>希望成为一个什么样的工程师？</p></li><li><p>在字节有什么样的成长？</p></li><li><p>对 Windows 365 产品有什么样的理解？</p></li></ol></li><li><p>算法题目：实现 sqrt 运算，计算算术平方根，结果向下取整。原题参考：<a href="https://leetcode.com/problems/sqrtx/">LeetCode 69. Sqrt(x)</a></p><p>  解法：二分法。</p></li></ul><h2 id="6-致谢"><a href="#6-致谢" class="headerlink" title="6 致谢"></a>6 致谢</h2><ul><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwODE4Nzg2NQ==&mid=2650548534&idx=1&sn=7b8b5f417e3e9423f6584bdc69328abc&chksm=8f0e7180b879f8964f57da433275455d456930a891594ebf9fd213c40c1e08def7e929e4a95a&scene=21#wechat_redirect">微软面经分享：如何更好地做好面试准备</a></p></li><li><p><a href="https://www.paincker.com/microsoft-interview">微软面试经历和相关思考总结</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;年末，微软面试终于告一段落，目前已经签定 Offer Letter，处于背调阶段，不出意外的话，月底就会入职。&lt;/p&gt;
&lt;p&gt;在准备面试的过程中，一众大佬的面经给了我很多启发，如今到了薪火相传的时候，希望我的面经对你也能有所帮助。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://image.progcz.com/2021/12/07/01.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="经历" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="面试" scheme="https://progcz.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="微软" scheme="https://progcz.com/tags/%E5%BE%AE%E8%BD%AF/"/>
    
    <category term="苏州" scheme="https://progcz.com/tags/%E8%8B%8F%E5%B7%9E/"/>
    
    <category term="社招" scheme="https://progcz.com/tags/%E7%A4%BE%E6%8B%9B/"/>
    
    <category term="内推" scheme="https://progcz.com/tags/%E5%86%85%E6%8E%A8/"/>
    
  </entry>
  
  <entry>
    <title>面试中常见的二叉树题目汇总</title>
    <link href="https://progcz.com/posts/1635906832/"/>
    <id>https://progcz.com/posts/1635906832/</id>
    <published>2021-11-03T02:34:37.000Z</published>
    <updated>2021-11-03T08:22:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>重点解决 LeetCode 中 List 为 Top Interview Questions 且 Tag 为 Binary Tree 的题目。</p><span id="more"></span><h2 id="1-二叉树的遍历（常规形式）"><a href="#1-二叉树的遍历（常规形式）" class="headerlink" title="1 二叉树的遍历（常规形式）"></a>1 二叉树的遍历（常规形式）</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出二叉树的前序（Pre-Order）、中序（In-Order）、后序（Post-Order）遍历的递归、循环实现。</p><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><p>递归版本：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode *root, vector&lt;<span class="keyword">int</span>&gt; &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// Pre-Order</span></span><br><span class="line">    path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;left, path);</span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;right, path);</span><br><span class="line">    <span class="comment">// In-Order</span></span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;left, path);</span><br><span class="line">    path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;right, path);</span><br><span class="line">    <span class="comment">// Post-Order</span></span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;left, path);</span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;right, path);</span><br><span class="line">    path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环版本：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; path = &#123;&#125;;</span><br><span class="line">        stack&lt;pair&lt;TreeNode*, <span class="keyword">bool</span>&gt;&gt; s;</span><br><span class="line">        s.<span class="built_in">push</span>(&#123;root, <span class="literal">false</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> p = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* node = p.first;</span><br><span class="line">            <span class="keyword">bool</span> visited = p.second;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (visited) &#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Pre-Order</span></span><br><span class="line">                s.<span class="built_in">push</span>(&#123;node-&gt;right, <span class="literal">false</span>&#125;);</span><br><span class="line">                s.<span class="built_in">push</span>(&#123;node-&gt;left, <span class="literal">false</span>&#125;);</span><br><span class="line">                s.<span class="built_in">push</span>(&#123;node, <span class="literal">true</span>&#125;);</span><br><span class="line">                <span class="comment">// In-Order</span></span><br><span class="line">                s.<span class="built_in">push</span>(&#123;node-&gt;right, <span class="literal">false</span>&#125;);</span><br><span class="line">                s.<span class="built_in">push</span>(&#123;node, <span class="literal">true</span>&#125;);</span><br><span class="line">                s.<span class="built_in">push</span>(&#123;node-&gt;left, <span class="literal">false</span>&#125;);</span><br><span class="line">                <span class="comment">// Post-Order</span></span><br><span class="line">                s.<span class="built_in">push</span>(&#123;node, <span class="literal">true</span>&#125;);</span><br><span class="line">                s.<span class="built_in">push</span>(&#123;node-&gt;right, <span class="literal">false</span>&#125;);</span><br><span class="line">                s.<span class="built_in">push</span>(&#123;node-&gt;left, <span class="literal">false</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-二叉树的层级遍历"><a href="#2-二叉树的层级遍历" class="headerlink" title="2 二叉树的层级遍历"></a>2 二叉树的层级遍历</h2><p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">LeetCode 102. Binary Tree Level Order Traversal</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出二叉树的层级（Level）遍历的循环实现，同一层的元素放在同一个数组里，不同层的元素放在不同的数组里。</p><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res = &#123;&#125;;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">        queue&lt;TreeNode*&gt; tq;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">continue</span>;</span><br><span class="line">            level.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            tq.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            tq.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!level.<span class="built_in">empty</span>()) res.<span class="built_in">push_back</span>(level);</span><br><span class="line">        q = tq;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-二叉树的之字形遍历"><a href="#3-二叉树的之字形遍历" class="headerlink" title="3 二叉树的之字形遍历"></a>3 二叉树的之字形遍历</h2><p><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">LeetCode 103. Binary Tree Zigzag Level Order Traversal</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出二叉树的之字形（Zigzag）遍历的循环实现，同一层的元素放在同一个数组里，不同层的元素放在不同的数组里。</p><h3 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res = &#123;&#125;;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">        stack&lt;TreeNode*&gt; ts;</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">continue</span>;</span><br><span class="line">            level.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                ts.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                ts.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ts.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                ts.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!level.<span class="built_in">empty</span>()) res.<span class="built_in">push_back</span>(level);</span><br><span class="line">        s = ts;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-根据前序遍历和中序遍历构造二叉树"><a href="#4-根据前序遍历和中序遍历构造二叉树" class="headerlink" title="4 根据前序遍历和中序遍历构造二叉树"></a>4 根据前序遍历和中序遍历构造二叉树</h2><p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>以数组形式给定二叉树的前序遍历和中序遍历，构造出该二叉树的数据结构。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据前序遍历的定义，<code>preorder</code> 的第 <code>0</code> 个元素 <code>preorder[0]</code>，必然是整个二叉树的根节点，构造该节点。</p><p>根据中序遍历的定义，<code>preorder[0]</code> 在 <code>inorder</code> 中的位置，其左侧所有元素会构成根节点的左子树，其右侧所有元素会构成根节点的右子树。</p><p>接着 <code>preorder</code> 的第 <code>1</code> 个元素 <code>preorder[1]</code>，必然是左子树的根节点，构造该节点，其在 <code>inorder</code> 中的位置，左侧构成左子树的左子树，右侧构成左子树的右子树。</p><p>不断重复上述过程，便可不断构造子树。</p><h3 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = inorder.<span class="built_in">size</span>(), pre_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            inorder_val2idx[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(preorder, inorder, pre_idx, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span>&amp; pre_idx, <span class="keyword">int</span> in_beg, <span class="keyword">int</span> in_end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in_beg &gt; in_end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[pre_idx]);</span><br><span class="line">        <span class="keyword">int</span> in_idx = inorder_val2idx[preorder[pre_idx]];</span><br><span class="line">        ++pre_idx;</span><br><span class="line">        root-&gt;left = <span class="built_in">build</span>(preorder, inorder, pre_idx, in_beg, in_idx<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">build</span>(preorder, inorder, pre_idx, in_idx+<span class="number">1</span>, in_end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; inorder_val2idx = &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-根据中序遍历和后序遍历构造二叉树"><a href="#5-根据中序遍历和后序遍历构造二叉树" class="headerlink" title="5 根据中序遍历和后序遍历构造二叉树"></a>5 根据中序遍历和后序遍历构造二叉树</h2><p><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">LeetCode 106. Construct Binary Tree from Inorder and Postorder Traversal</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>以数组形式给定二叉树的前序遍历和中序遍历，构造出该二叉树的数据结构。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>与前一题的思路一致，不再赘述。</p><h3 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = inorder.<span class="built_in">size</span>(), post_idx = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            inorder_val2idx[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(inorder, postorder, <span class="number">0</span>, n<span class="number">-1</span>, post_idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> in_beg, <span class="keyword">int</span> in_end, <span class="keyword">int</span>&amp; post_idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in_beg &gt; in_end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(postorder[post_idx]);</span><br><span class="line">        <span class="keyword">int</span> in_idx = inorder_val2idx[postorder[post_idx]];</span><br><span class="line">        --post_idx;</span><br><span class="line">        root-&gt;right = <span class="built_in">build</span>(inorder, postorder, in_idx+<span class="number">1</span>, in_end, post_idx);</span><br><span class="line">        root-&gt;left = <span class="built_in">build</span>(inorder, postorder, in_beg, in_idx<span class="number">-1</span>, post_idx);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; inorder_val2idx = &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-找出二叉树中两个节点的最小公共父节点"><a href="#6-找出二叉树中两个节点的最小公共父节点" class="headerlink" title="6 找出二叉树中两个节点的最小公共父节点"></a>6 找出二叉树中两个节点的最小公共父节点</h2><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">LeetCode 236. Lowest Common Ancestor of a Binary Tree</a></p><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>给定二叉树，找出其中两个节点的最小公共父节点。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>对二叉树进行遍历，过程中不断判断，当前节点及左右子树是否包含 <code>p</code> 和 <code>q</code>，如果同时满足，则记录该节点，记录一次之后不再记录，保证记录的为最小公共子节点。</p><h3 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        TreeNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> ret = <span class="built_in">travel</span>(root, p, q, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    pair&lt;bool, bool&gt; travel(TreeNode* node, TreeNode* p, TreeNode* q, TreeNode* &amp;res) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node || res) <span class="keyword">return</span> &#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> left_ret = <span class="built_in">travel</span>(node-&gt;left, p, q, res);</span><br><span class="line">        <span class="keyword">auto</span> right_ret = <span class="built_in">travel</span>(node-&gt;right, p, q, res);</span><br><span class="line">        <span class="keyword">bool</span> p_hit = (node == p) || left_ret.first || right_ret.first;</span><br><span class="line">        <span class="keyword">bool</span> q_hit = (node == q) || left_ret.second || right_ret.second;</span><br><span class="line">        <span class="keyword">if</span> (p_hit &amp;&amp; q_hit &amp;&amp; !res) &#123;</span><br><span class="line">            res = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;p_hit, q_hit&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-验证是否为二叉搜索树"><a href="#7-验证是否为二叉搜索树" class="headerlink" title="7 验证是否为二叉搜索树"></a>7 验证是否为二叉搜索树</h2><p><a href="https://leetcode.com/problems/validate-binary-search-tree/">LeetCode 98. Validate Binary Search Tree</a></p><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>给定二叉树，判断是否为二叉搜索树。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>根据二叉搜索树的定义，对于任意一个节点：</p><ul><li><p>其值大于左子树中任一节点的值，可以等价为其值大于左子树中所有节点的最大值</p></li><li><p>其值小于右子树中任一节点的值，可以等价为其值小于右子树中所有节点的最小值</p></li><li><p>其左子树和右子树也均为二叉搜索树</p></li></ul><h3 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="built_in">is_valid</span>(root);</span><br><span class="line">        <span class="keyword">return</span> p.first;</span><br><span class="line">    &#125;</span><br><span class="line">    pair&lt;<span class="keyword">bool</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">is_valid</span>(TreeNode* node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="literal">true</span>, &#123;node-&gt;val, node-&gt;val&#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> node_min = node-&gt;val, node_max = node-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="built_in">is_valid</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">bool</span> valid = p.first;</span><br><span class="line">            <span class="keyword">auto</span> [left_min, left_max] = p.second;</span><br><span class="line">            <span class="keyword">if</span> (valid &amp;&amp; left_max &lt; node-&gt;val) &#123;</span><br><span class="line">                node_min = left_min;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="literal">false</span>, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="built_in">is_valid</span>(node-&gt;right);</span><br><span class="line">            <span class="keyword">bool</span> valid = p.first;</span><br><span class="line">            <span class="keyword">auto</span> [right_min, right_max] = p.second;</span><br><span class="line">            <span class="keyword">if</span> (valid &amp;&amp; right_min &gt; node-&gt;val) &#123;</span><br><span class="line">                node_max = right_max;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="literal">false</span>, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="literal">true</span>, &#123;node_min, node_max&#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note info"><p>上述实现的难点在于辅助函数 <code>is_valid</code> 返回类型的设计，<code>pair&lt;bool, pair&lt;int, int&gt;&gt;</code> 的含义对应：以 <code>node</code> 为根节点的树是否为二叉搜索树、以 <code>node</code> 为根节点的树的最小值和最大值。</p></div><h2 id="8-根据有序数组构造二叉搜索树"><a href="#8-根据有序数组构造二叉搜索树" class="headerlink" title="8 根据有序数组构造二叉搜索树"></a>8 根据有序数组构造二叉搜索树</h2><p><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">LeetCode 108. Convert Sorted Array to Binary Search Tree</a></p><h3 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h3><p>给定有序数组，由此构造一个平衡的二叉搜索树，平衡是指任一节点的左右子树的深度之差总不超过 1。</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>不断二分，将中位数构造为根节点，其左侧递归构造左子树，其右侧递归构造右子树。</p><h3 id="C-实现-7"><a href="#C-实现-7" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(nums, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beg &gt; end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        node-&gt;left = <span class="built_in">build</span>(nums, beg, mid<span class="number">-1</span>);</span><br><span class="line">        node-&gt;right = <span class="built_in">build</span>(nums, mid+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="9-找出二叉搜索树中第-K-小的元素"><a href="#9-找出二叉搜索树中第-K-小的元素" class="headerlink" title="9 找出二叉搜索树中第 K 小的元素"></a>9 找出二叉搜索树中第 K 小的元素</h2><p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">LeetCode 230. Kth Smallest Element in a BST</a></p><h3 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h3><p>给定二叉搜索树，找出其中第 K 小的元素（从 1 开始计数）。</p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>对二叉搜索树进行中序遍历，从而实现从小到大进行遍历，过程中计数，到 K 则记录节点的值。</p><h3 id="C-实现-8"><a href="#C-实现-8" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> order = <span class="number">1</span>, val = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">travel</span>(root, k, order, val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(TreeNode* node, <span class="keyword">int</span> k, <span class="keyword">int</span>&amp; order, <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">travel</span>(node-&gt;left, k, order, val);</span><br><span class="line">        <span class="keyword">if</span> (order++ == k) val = node-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (order &gt; k) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">travel</span>(node-&gt;right, k, order, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;重点解决 LeetCode 中 List 为 Top Interview Questions 且 Tag 为 Binary Tree 的题目。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://progcz.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="数据结构与算法" scheme="https://progcz.com/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="数据结构与算法" scheme="https://progcz.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="面试" scheme="https://progcz.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Binary Tree" scheme="https://progcz.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>面试中常见的链表题目汇总</title>
    <link href="https://progcz.com/posts/1634602816/"/>
    <id>https://progcz.com/posts/1634602816/</id>
    <published>2021-10-19T00:21:15.000Z</published>
    <updated>2021-10-26T01:39:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>重点解决 LeetCode 中 List 为 Top Interview Questions 且 Tag 为 Linked List 的题目。</p><span id="more"></span><h2 id="0-如何写测试代码"><a href="#0-如何写测试代码" class="headerlink" title="0 如何写测试代码"></a>0 如何写测试代码</h2><p>以下是以 <a href="https://leetcode.com/problems/add-two-numbers/">LeetCode 2</a> 为例的，在 LeetCode Playground 完成的 C++ 实现及测试代码：</p><p><a href="https://leetcode.com/playground/WmFSQPkU">https://leetcode.com/playground/WmFSQPkU</a></p><p>其中，测试代码主要包含以下几个部分：</p><ul><li><p>定义单向链表节点：</p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    MyListNode* next;</span><br><span class="line">    <span class="built_in">MyListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">MyListNode</span>(<span class="keyword">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">MyListNode</span>(<span class="keyword">int</span> val, MyListNode* next) : <span class="built_in">val</span>(val), <span class="built_in">next</span>  (next) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>打印链表：</p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_list</span><span class="params">(MyListNode* node)</span> </span>&#123;</span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        oss &lt;&lt; node-&gt;val &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断两个链表是否相等：</p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_equal_list</span><span class="params">(MyListNode* l1, MyListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!l1 &amp;&amp; !l2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!l1 || !l2 || l1-&gt;val != l2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">is_equal_list</span>(l1-&gt;next, l2-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将数组转换为链表：</p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MyListNode* <span class="title">vec2list</span><span class="params">(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (end &gt;= n || beg &gt; end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    MyListNode* node = <span class="keyword">new</span> <span class="built_in">MyListNode</span>(</span><br><span class="line">        vec[beg], <span class="built_in">vec2list</span>(vec, beg+<span class="number">1</span>, end)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这样，我们就可以通过给定数组来测试链表了：</p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; args_1 = &#123;</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">8</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; args_2 = &#123;</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; rets = &#123;</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在主函数中测试：</p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = rets.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        MyListNode* arg_1 = <span class="built_in">vec2list</span>(args_1[i], <span class="number">0</span>, args_1[i].<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// print_list(arg_1);</span></span><br><span class="line">        MyListNode* arg_2 = <span class="built_in">vec2list</span>(args_2[i], <span class="number">0</span>, args_2[i].<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// print_list(arg_2);</span></span><br><span class="line">        MyListNode* ret = <span class="built_in">vec2list</span>(rets[i], <span class="number">0</span>, rets[i].<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// print_list(ret);</span></span><br><span class="line">        <span class="built_in">assert</span>(</span><br><span class="line">            <span class="built_in">is_equal_list</span>(<span class="built_in">add_two_numbers</span>(arg_1, arg_2), ret)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-反转链表"><a href="#1-反转链表" class="headerlink" title="1 反转链表"></a>1 反转链表</h2><p><a href="https://leetcode.com/problems/reverse-linked-list">LeetCode 206. Reverse Linked List</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个链表，将其反转。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>以相邻三个元素 <code>pre</code>、<code>cur</code> 和 <code>nxt</code> 的处理过程为一个周期，在此周期内：</p><ol><li><p>首先将 <code>cur-&gt;next</code> 记录到 <code>nxt</code> 中</p></li><li><p>然后将 <code>cur-&gt;next</code> 置为 <code>pre</code>，完成 <code>cur</code> 位置上的反转</p></li><li><p>最后将 <code>pre</code> 移动至 <code>cur</code> 的位置，将 <code>cur</code> 移动至 <code>nxt</code> 的位置</p></li></ol><p>可以参考这个动图：<a href="https://image.progcz.com/2021/10/26/01.gif">How to Reverse Linked List</a></p><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>, *cur = head, *nxt = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            nxt = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-排序链表"><a href="#2-排序链表" class="headerlink" title="2 排序链表"></a>2 排序链表</h2><p><a href="https://leetcode.com/problems/sort-list">LeetCode 148. Sort List</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定一个链表，将其升序排序。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用归并排序或快速排序，基本思想与<a href="/posts/1633654398/">数组的排序算法</a>保持一致，只是由于链表的特殊结构，在实现上要做特殊处理。</p><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><p>归并排序：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* slow = head, *fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">sortList</span>(head), <span class="built_in">sortList</span>(fast));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* root = <span class="keyword">new</span> <span class="built_in">ListNode</span>(), *cur = root;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>快速排序：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">quick_sort</span>(head, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(ListNode* left, ListNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right || left-&gt;next == right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = <span class="built_in">partition</span>(left, right);</span><br><span class="line">        <span class="built_in">quick_sort</span>(left, mid);</span><br><span class="line">        <span class="built_in">quick_sort</span>(mid-&gt;next, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* left, ListNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = left-&gt;val;</span><br><span class="line">        ListNode* pre = left, *cur = left-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (cur != right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val &lt; pivot) &#123;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">                <span class="built_in">swap_pointer</span>(pre, cur);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap_pointer</span>(left, pre);</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap_pointer</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = l1-&gt;val;</span><br><span class="line">        l1-&gt;val = l2-&gt;val;</span><br><span class="line">        l2-&gt;val = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;重点解决 LeetCode 中 List 为 Top Interview Questions 且 Tag 为 Linked List 的题目。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://progcz.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="数据结构与算法" scheme="https://progcz.com/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="数据结构与算法" scheme="https://progcz.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="面试" scheme="https://progcz.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Linked List" scheme="https://progcz.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>面试中常见的 C++ 问题汇总</title>
    <link href="https://progcz.com/posts/1634567000/"/>
    <id>https://progcz.com/posts/1634567000/</id>
    <published>2021-10-18T15:07:20.000Z</published>
    <updated>2021-11-03T01:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>以前秋招，整理过一版 C++ 问题汇总，这次社招，重新梳理一遍。</p><span id="more"></span><h2 id="1-语法基础"><a href="#1-语法基础" class="headerlink" title="1 语法基础"></a>1 语法基础</h2><h3 id="C-和-C-有什么区别？"><a href="#C-和-C-有什么区别？" class="headerlink" title="C++ 和 C 有什么区别？"></a>C++ 和 C 有什么区别？</h3><ul><li><p>C++ 是面向对象的语言，而 C 是面向过程的语言</p></li><li><p>C++ 引入类的概念，而 C 中没有</p></li><li><p>C++ 引入引用的概念，而 C 中没有</p></li><li><p>C++ 引入函数重载的特性，而 C 中没有</p></li><li><p>C++ 引入 <code>new/delete</code> 运算符，取代 C 中的 <code>malloc/free</code> 库函数</p></li></ul><h3 id="相比于-C-98，C-11-有哪些新特性？"><a href="#相比于-C-98，C-11-有哪些新特性？" class="headerlink" title="相比于 C++98，C++11 有哪些新特性？"></a>相比于 C++98，C++11 有哪些新特性？</h3><ul><li><p>引入 Lambda 表达式用于创建匿名函数</p></li><li><p>引入自动类型推导 <code>auto</code> 和 <code>decltype</code></p></li><li><p>引入 <code>= default</code> 生成默认构造函数，<code>= delete</code> 禁止使用拷贝构造函数</p></li><li><p>引入 <code>nullptr</code> 关键字，用于解决 <code>NULL</code> 的二义性问题</p></li><li><p>引入范围 <code>for</code> 循环</p></li><li><p>引入列表初始化</p></li><li><p>引入 <code>shared_ptr</code>、<code>unique_ptr</code> 等智能指针</p></li><li><p>引入右值引用，将引用绑定到右值，如临时对象或字面量</p></li><li><p>引入线程库</p></li></ul><h3 id="struct-和-class-有什么区别？"><a href="#struct-和-class-有什么区别？" class="headerlink" title="struct 和 class 有什么区别？"></a><code>struct</code> 和 <code>class</code> 有什么区别？</h3><ul><li><p>成员的默认访问权限：<code>struct</code> 的成员默认为 <code>public</code> 权限，<code>class</code> 的成员默认为 <code>private</code> 权限</p></li><li><p>默认继承权限：<code>struct</code> 的继承按照 <code>public</code> 处理，<code>class</code> 的继承按照 <code>private</code> 处理</p></li></ul><h3 id="对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？"><a href="#对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？" class="headerlink" title="对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？"></a>对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？</h3><p>应该使用 <code>inline</code> 内联函数，即编译器将 <code>inline</code> 内联函数内的代码替换到函数被调用的地方。</p><p>优点：</p><ul><li><p>在内联函数被调用的地方进行代码展开，省去函数调用的时间，从而提高程序运行效率</p></li><li><p>相比于宏函数，内联函数在代码展开时，编译器会进行语法安全检查或数据类型转换，使用更加安全</p></li></ul><p>缺点：</p><ul><li><p>代码膨胀，产生更多的开销</p></li><li><p>如果内联函数内代码块的执行时间比调用时间长得多，那么效率的提升并没有那么大</p></li><li><p>如果修改内联函数，那么所有调用该函数的代码文件都需要重新编译</p></li><li><p>内联声明只是建议，是否内联由编译器决定，所以实际并不可控</p></li></ul><h3 id="define-和-inline-有什么区别？"><a href="#define-和-inline-有什么区别？" class="headerlink" title="#define 和 inline 有什么区别？"></a><code>#define</code> 和 <code>inline</code> 有什么区别？</h3><ul><li><p><code>#define</code> 宏函数在预处理阶段展开，而 <code>inline</code> 内联函数在编译阶段展开</p></li><li><p><code>#define</code> 宏函数不检查参数类型，而 <code>inline</code> 内联函数检查参数类型，使用更加安全</p></li></ul><h3 id="const-关键字有什么作用？"><a href="#const-关键字有什么作用？" class="headerlink" title="const 关键字有什么作用？"></a><code>const</code> 关键字有什么作用？</h3><ul><li><p>修饰变量时，表示该变量的值在其生命周期内只读，不能被改变</p></li><li><p>修饰指针：<code>int * const</code></p></li><li><p>修饰指针所指向的对象：<code>const int *</code></p></li><li><p>修饰引用所绑定的对象：<code>const int &amp;</code></p></li><li><p>修饰函数的引用形参时，可以保护实参不被函数修改</p></li><li><p>修饰非静态成员变量时，不能在类定义处初始化，必须通过构造函数初始化列表进行初始化</p></li><li><p>修饰静态成员变量时，不能在类内部初始化，一般在类外部进行初始化</p></li><li><p>修饰成员函数时，表示该函数不应修改非静态成员，但并不可靠，因为指针所指对象可能会被修改</p></li></ul><h3 id="define-和-const-有什么区别？"><a href="#define-和-const-有什么区别？" class="headerlink" title="#define 和 const 有什么区别？"></a><code>#define</code> 和 <code>const</code> 有什么区别？</h3><ul><li><p>编译器处理方式不同：<code>#define</code> 宏是在预处理阶段展开，不能对宏定义进行调试，而 <code>const</code> 常量是在编译阶段使用</p></li><li><p>类型和安全检查不同：<code>#define</code> 宏没有类型，不做任何类型检查，仅仅是代码展开，可能产生边际效应等错误，而 <code>const</code> 常量有具体类型，在编译阶段会执行类型检查</p></li><li><p>存储方式不同：<code>#define</code> 宏仅仅是代码展开，在多个地方进行字符串替换，不会分配内存，存储于程序的代码段中，而 <code>const</code> 常量会分配内存，但只维持一份拷贝，存储于程序的数据段中</p></li><li><p>定义域不同：<code>#define</code> 宏不受定义域限制，而 <code>const</code> 常量只在定义域内有效</p></li></ul><h3 id="explicit-关键字有什么作用？"><a href="#explicit-关键字有什么作用？" class="headerlink" title="explicit 关键字有什么作用？"></a><code>explicit</code> 关键字有什么作用？</h3><p>可以用单个实参来调用的构造函数都定义了从形参类型到实参类型的隐式转换，这种转换往往都是非预期的，所以使用 <code>explicit</code> 关键字对构造函数进行修饰，从而避免由构造函数定义的隐式转换。</p><h3 id="extern关键字有什么作用？"><a href="#extern关键字有什么作用？" class="headerlink" title="extern关键字有什么作用？"></a><code>extern</code>关键字有什么作用？</h3><ul><li><p>当 <code>extern</code> 修饰变量或函数时，表示变量或函数的定义在其他文件中，提示编译器在其他模块中寻找其定义</p></li><li><p>当 <code>extern C</code> 时，提示编译器在编译函数时按照 C 的规则去翻译相应的函数名，如果按照 C++ 的规则，函数名会被翻译得变得面目全非，因为 C++ 支持函数的重载。</p></li></ul><h3 id="static关键字有什么作用？"><a href="#static关键字有什么作用？" class="headerlink" title="static关键字有什么作用？"></a><code>static</code>关键字有什么作用？</h3><ul><li><p>修饰局部变量时，使得该变量在静态存储区分配内存；只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化；其生命周期与程序相同，但其作用域为局部作用域，并不能一直被访问</p></li><li><p>修饰全局变量时，使得该变量在静态存储区分配内存；在声明该变量的整个文件中都是可见的，而在文件外是不可见的</p></li><li><p>修饰函数时，在声明该函数的整个文件中都是可见的，而在文件外是不可见的，从而可以在多人协作时避免同名的函数冲突</p></li><li><p>修饰成员变量时，所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加 <code>static</code></p></li><li><p>修饰成员函数时，该函数不接受 <code>this</code> 指针，只能访问类的静态成员；不需要实例化对象即可访问</p></li></ul><h3 id="sizeof-和-strlen-之间有什么区别？"><a href="#sizeof-和-strlen-之间有什么区别？" class="headerlink" title="sizeof 和 strlen 之间有什么区别？"></a><code>sizeof</code> 和 <code>strlen</code> 之间有什么区别？</h3><ul><li><p><code>sizeof</code> 属于运算符，不是库函数，其结果在编译时期计算得到，因此不能用来得到动态分配的内存大小，而 <code>strlen</code> 属于库函数，其结果在运行期间计算得到</p></li><li><p><code>sizeof</code> 参数可以是任何数据或数据类型，而 <code>strlen</code> 的参数只能是字符指针，且该指针指向结尾为 <code>\0</code> 的字符串</p></li></ul><h3 id="assert-有什么用处？"><a href="#assert-有什么用处？" class="headerlink" title="assert 有什么用处？"></a><code>assert</code> 有什么用处？</h3><p><code>assert</code> 是一种仅在 debug 版本中使用的宏函数，用于检查不该发生的情况，可以看作是一种在任何系统状态下都可以安全使用的无害测试手段；可以通过 <code>#define NDEBUG</code> 来关闭 <code>assert</code>，放在 <code>&lt;cassert&gt;</code> 头文件之前。</p><h3 id="变量的声明和定义有什么区别？"><a href="#变量的声明和定义有什么区别？" class="headerlink" title="变量的声明和定义有什么区别？"></a>变量的声明和定义有什么区别？</h3><ul><li><p>声明仅仅是把变量类型等信息提供给编译器，并不为其分配内存空间，而定义需要为变量分配内存空间</p></li><li><p>变量可以在多处声明，如外部变量 <code>extern</code>，但只能在一处定义</p></li></ul><h3 id="指针和引用有什么区别？"><a href="#指针和引用有什么区别？" class="headerlink" title="指针和引用有什么区别？"></a>指针和引用有什么区别？</h3><ul><li><p>指针是一种对象，用来存放某个对象的地址，占用内存空间，而引用是一种别名，不占用内存空间</p></li><li><p>指针可以声明为空，之后进行初始化，普通指针可以随时更换所指对象，而引用必须在声明的时候初始化，而且初始化后不可改变</p></li><li><p>指针包含指向常量的指针和常量指针，而引用不包含常量引用，但包含对常量的引用</p></li></ul><h3 id="右值引用有什么作用？"><a href="#右值引用有什么作用？" class="headerlink" title="右值引用有什么作用？"></a>右值引用有什么作用？</h3><p>右值引用的主要目的是为了实现转移语义和完美转发，消除两个对象交互时不必要的对象拷贝，也能够更加简洁明确地定义泛型函数。</p><h3 id="类型转换分为哪几种？各自有什么样的特点？"><a href="#类型转换分为哪几种？各自有什么样的特点？" class="headerlink" title="类型转换分为哪几种？各自有什么样的特点？"></a>类型转换分为哪几种？各自有什么样的特点？</h3><ul><li><p><code>static_cast</code>：用于基本数据类型之间的转换、子类向父类的安全转换、<code>void*</code> 和其他类型指针之间的转换</p></li><li><p><code>const_cast</code>：用于去除 <code>const</code> 或 <code>volatile</code> 属性</p></li><li><p><code>dynamic_cast</code>：用于子类和父类之间的安全转换，可以实现向上向下转换，因为编译器默认向上转换总是安全的，而向下转换时，<code>dynamic_cast</code> 具有类型检查的功能；<code>dynamic_cast</code> 转换失败时，对于指针会返回目标类型的 <code>nullptr</code>，对于引用会返回 <code>bad_cast</code> 异常</p></li><li><p><code>reinterpret_cast</code>：用于不同类型指针之间、不同类型引用之间、指针和能容纳指针的整数类型之间的转换</p></li></ul><h2 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2 内存管理"></a>2 内存管理</h2><h3 id="常用的数据类型各占用多大的内存空间？"><a href="#常用的数据类型各占用多大的内存空间？" class="headerlink" title="常用的数据类型各占用多大的内存空间？"></a>常用的数据类型各占用多大的内存空间？</h3><table><thead><tr><th>数据类型</th><th>32位编译器</th><th>64位编译器</th></tr></thead><tbody><tr><td><strong>bool</strong></td><td><strong>1</strong></td><td>1</td></tr><tr><td><strong>char</strong></td><td><strong>1</strong></td><td>1</td></tr><tr><td><strong>short (int)</strong></td><td><strong>2</strong></td><td>2</td></tr><tr><td><strong>int</strong></td><td><strong>4</strong></td><td>4</td></tr><tr><td><strong>unsigned (int)</strong></td><td><strong>4</strong></td><td>4</td></tr><tr><td><strong>long</strong></td><td><strong>4</strong></td><td><strong>8</strong></td></tr><tr><td><strong>long long</strong></td><td><strong>8</strong></td><td>8</td></tr><tr><td><strong>float</strong></td><td><strong>4</strong></td><td>4</td></tr><tr><td><strong>double</strong></td><td><strong>8</strong></td><td>8</td></tr><tr><td><strong>pointer</strong></td><td><strong>4</strong></td><td><strong>8</strong></td></tr></tbody></table><h3 id="new-delete-和-malloc-free-之间有什么关系？"><a href="#new-delete-和-malloc-free-之间有什么关系？" class="headerlink" title="new/delete 和 malloc/free 之间有什么关系？"></a><code>new/delete</code> 和 <code>malloc/free</code> 之间有什么关系？</h3><ul><li><p>相同点：对于内部数据类型来说，没有构造与析构的过程，所以两者是等价的，都可以用于申请动态内存和释放内存</p></li><li><p>不同点：</p><ul><li><p><code>new/delete</code> 可以调用对象的构造函数和析构函数，属于运算符，在编译器权限之内，而 <code>malloc/free</code> 仅用于内存分配和释放，属于库函数，不在编译器权限之内</p></li><li><p><code>new</code> 是类型安全的，而 <code>malloc</code> 返回的数据类型是 <code>void *</code>，所以要显式地进行类型转换</p></li><li><p><code>new</code> 可以自动计算所需字节数，而 <code>malloc</code> 需要手动计算</p></li><li><p><code>new</code> 申请内存失败时抛出 <code>bad_malloc</code> 异常，而 <code>malloc</code> 返回空指针</p></li></ul></li></ul><h3 id="delete-与-delete-有什么区别？"><a href="#delete-与-delete-有什么区别？" class="headerlink" title="delete 与 delete [] 有什么区别？"></a><code>delete</code> 与 <code>delete []</code> 有什么区别？</h3><ul><li><p>对于简单类型来说：使用 <code>new</code> 分配后，不管是数组数组还是非数组形式，两种方式都可以释放内存</p></li><li><p>对于自定义类型来说：需要对于单个对象使用 <code>delete</code>，对于对象数组使用 <code>delete []</code>，逐个调用数组中对象的析构函数，从而释放所有内存；如果反过来使用，即对于单个对象使用 <code>delete []</code>，对于对象数组使用 <code>delete</code>，其行为是未定义的</p></li></ul><p>所以，最恰当的方式就是如果用了 <code>new</code>，就用 <code>delete</code>；如果用了 <code>new []</code>，就用 <code>delete []</code>。</p><h3 id="内存泄漏的场景有哪些？"><a href="#内存泄漏的场景有哪些？" class="headerlink" title="内存泄漏的场景有哪些？"></a>内存泄漏的场景有哪些？</h3><ul><li><p><code>malloc</code> 和 <code>free</code> 未成对出现，或 <code>new/new []</code> 和 <code>delete/delete []</code> 未成对出现</p><ul><li><p>在堆中创建对象分配内存，但未显式释放内存；比如，通过局部分配的内存，未在调用者函数体内释放：</p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="built_in">getMemory</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在构造函数中动态分配内存，但未在析构函数中正确释放内存</p></li></ul></li><li><p>未定义拷贝构造函数或未重载赋值运算符，从而造成两次释放相同内存的做法；比如，类中包含指针成员变量，在未定义拷贝构造函数或未重载赋值运算符的情况下，编译器会调用默认的拷贝构造函数或赋值运算符，以逐个成员拷贝的方式来复制指针成员变量，使得两个对象包含指向同一内存空间的指针，那么在释放第一个对象时，析构函数释放该指针指向的内存空间，在释放第二个对象时，析构函数就会释放同一内存空间，这样的行为是错误的</p></li><li><p>没有将基类的析构函数定义为虚函数</p></li></ul><h3 id="内存的分配方式有几种？"><a href="#内存的分配方式有几种？" class="headerlink" title="内存的分配方式有几种？"></a>内存的分配方式有几种？</h3><ul><li><p>在栈上分配：在执行函数时，局部变量的内存都可以在栈上分配，函数结束时会自动释放；栈内存的分配运算内置于处理器的指令集中，效率很高，但分配的内存容量有限</p></li><li><p>从堆上分配：由 <code>new</code> 分配和 <code>delete</code> 释放的内存块，也称为动态内存分配，使用者自行申请和释放内存，使用灵活</p></li><li><p>从自由存储区分配：由 <code>malloc</code> 分配和 <code>free</code> 释放的内存块，与堆类似</p></li><li><p>从常量存储区分配：特殊的存储区，存放的是常量，不可修改</p></li><li><p>从全局/静态存储区分配：编译期间分配内存，整个程序运行期间都存在，如全局变量、静态变量等</p></li></ul><h3 id="堆和栈有什么区别？"><a href="#堆和栈有什么区别？" class="headerlink" title="堆和栈有什么区别？"></a>堆和栈有什么区别？</h3><ul><li><p>分配和管理方式不同：</p><ul><li><p>堆是动态分配的，其空间的分配和释放都由使用者控制</p></li><li><p>栈是由编译器自动管理的，其分配方式有两种：</p><ol><li><p>静态分配由编译器完成，比如局部变量的分配</p></li><li><p>动态分配由 <code>alloca()</code> 函数进行分配，但是会由编译器释放</p></li></ol></li></ul></li><li><p>产生碎片不同：</p><ul><li><p>对堆来说，频繁使用 <code>new/delete</code> 或者 <code>malloc/free</code> 会造成内存空间的不连续，产生大量碎片，是程序效率降低</p></li><li><p>对栈来说，不存在碎片问题，因为栈具有先进后出的特性</p></li></ul></li><li><p>生长方向不同：</p><ul><li><p>堆是向着内存地址增加的方向增长的，从内存的低地址向高地址方向增长</p></li><li><p>栈是向着内存地址减小的方向增长的，从内存的高地址向低地址方向增长</p></li></ul></li><li><p>申请大小限制不同：</p><ul><li><p>栈顶和栈底是预设好的，大小固定</p></li><li><p>堆是不连续的内存区域，其大小可以灵活调整</p></li></ul></li></ul><h3 id="静态内存分配和动态内存分配有什么区别？"><a href="#静态内存分配和动态内存分配有什么区别？" class="headerlink" title="静态内存分配和动态内存分配有什么区别？"></a>静态内存分配和动态内存分配有什么区别？</h3><ul><li><p>静态内存分配是在编译时期完成的，不占用 CPU 资源；动态内存分配是在运行时期完成的，分配和释放需要占用 CPU 资源</p></li><li><p>静态内存分配是在栈上分配的；动态内存分配是在堆上分配的</p></li><li><p>静态内存分配不需要指针或引用类型的支持；动态内存分配需要</p></li><li><p>静态内存分配是按计划分配的，在编译前确定内存块的大小；动态内存分配是按需要分配的</p></li><li><p>静态内存分配是把内存的控制权交给了编译器；动态内存分配是把内存的控制权给了使用者</p></li><li><p>静态内存分配的运行效率比动态内存分配高，动态内存分配不当可能造成内存泄漏</p></li></ul><h3 id="如何构造一个类，使得只能在堆上或只能在栈上分配内存？"><a href="#如何构造一个类，使得只能在堆上或只能在栈上分配内存？" class="headerlink" title="如何构造一个类，使得只能在堆上或只能在栈上分配内存？"></a>如何构造一个类，使得只能在堆上或只能在栈上分配内存？</h3><ul><li><p>只能在堆上分配内存：将析构函数声明为 <code>private</code></p></li><li><p>只能在栈上生成对象：将 <code>new</code> 和 <code>delete</code> 重载为 <code>private</code></p></li></ul><h3 id="浅拷贝和深拷贝有什么区别？"><a href="#浅拷贝和深拷贝有什么区别？" class="headerlink" title="浅拷贝和深拷贝有什么区别？"></a>浅拷贝和深拷贝有什么区别？</h3><ul><li><p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享一块内存</p></li><li><p>深拷贝会创造一个相同的对象，新对象与原对象不共享内存，修改新对象不会影响原对象</p></li></ul><h3 id="什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？"><a href="#什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？" class="headerlink" title="什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？"></a>什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？</h3><p>智能指针是一个 RAII 类模型，用于动态分配内存，其设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用 <code>delete</code> 删除指针所指向的内存空间。</p><p>智能指针的作用是，能够处理内存泄漏问题和空悬指针问题。</p><p>智能指针分为 <code>auto_ptr</code>、<code>unique_ptr</code>、<code>shared_ptr</code> 和 <code>weak_ptr</code> 四种，各自的特点：</p><ul><li><p>对于 <code>auto_ptr</code>，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象；但 <code>auto_ptr</code> 在 C++11 中被摒弃，其主要问题在于：</p><ul><li><p>对象所有权的转移，比如在函数传参过程中，对象所有权不会返还，从而存在潜在的内存崩溃问题</p></li><li><p>不能指向数组，也不能作为 STL 容器的成员</p></li></ul></li><li><p>对于 <code>unique_ptr</code>，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象，因为无法进行拷贝构造和拷贝赋值，但是可以进行移动构造和移动赋值</p></li><li><p>对于 <code>shared_ptr</code>，实现共享式拥有的概念，即多个智能指针可以指向相同的对象，该对象及相关资源会在其所指对象不再使用之后，自动释放与对象相关的资源</p></li><li><p>对于 <code>weak_ptr</code>，解决 <code>shared_ptr</code> 相互引用时，两个指针的引用计数永远不会下降为 0，从而导致死锁问题，因为 <code>weak_ptr</code> 是对对象的一种弱引用，可以绑定到 <code>shared_ptr</code>，但不会增加对象的引用计数</p></li></ul><h3 id="shared-ptr-是如何实现的？"><a href="#shared-ptr-是如何实现的？" class="headerlink" title="shared_ptr 是如何实现的？"></a><code>shared_ptr</code> 是如何实现的？</h3><ol><li><p>构造函数中计数初始化为 1</p></li><li><p>拷贝构造函数中计数值加 1</p></li><li><p>赋值运算符中，左边的对象引用计数减 1，右边的对象引用计数加 1</p></li><li><p>析构函数中引用计数减 1</p></li><li><p>在赋值运算符和析构函数中，如果减 1 后为 0，则调用 <code>delete</code> 释放对象</p></li></ol><h2 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3 面向对象"></a>3 面向对象</h2><h3 id="面向对象的三大特征是哪些？各自有什么样的特点？"><a href="#面向对象的三大特征是哪些？各自有什么样的特点？" class="headerlink" title="面向对象的三大特征是哪些？各自有什么样的特点？"></a>面向对象的三大特征是哪些？各自有什么样的特点？</h3><ul><li><p>封装：将客观事物封装成抽象的类，而类可以把自己的数据和方法暴露给可信的类或者对象，对不可信的类或对象则进行信息隐藏</p></li><li><p>继承：可以使用现有类的所有功能，并且无需重新编写原来的类即可对功能进行拓展</p></li><li><p>多态：一个类实例的相同方法在不同情形下有不同的表现形式，使不同内部结构的对象可以共享相同的外部接口</p></li></ul><h3 id="多态的实现有哪几种？"><a href="#多态的实现有哪几种？" class="headerlink" title="多态的实现有哪几种？"></a>多态的实现有哪几种？</h3><p>多态分为静态多态和动态多态：</p><ul><li><p>静态多态是通过重载和模板技术实现的，在编译期间确定</p></li><li><p>动态多态是通过虚函数和继承关系实现的，执行动态绑定，在运行期间确定</p></li></ul><h3 id="动态多态有什么作用？有哪些必要条件？"><a href="#动态多态有什么作用？有哪些必要条件？" class="headerlink" title="动态多态有什么作用？有哪些必要条件？"></a>动态多态有什么作用？有哪些必要条件？</h3><p>动态多态的作用：</p><ul><li><p>隐藏实现细节，使代码模块化，提高代码的可复用性</p></li><li><p>接口重用，使派生类的功能可以被基类的指针/引用所调用，即向后兼容，提高代码的可扩充性和可维护性</p></li></ul><p>动态多态的必要条件：</p><ul><li><p>需要有继承</p></li><li><p>需要有虚函数覆盖</p></li><li><p>需要有基类指针/引用指向子类对象</p></li></ul><h3 id="动态绑定是如何实现的？"><a href="#动态绑定是如何实现的？" class="headerlink" title="动态绑定是如何实现的？"></a>动态绑定是如何实现的？</h3><p>当编译器发现类中有虚函数时，会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在对象中增加一个指针 <code>vptr</code>，用于指向类的虚函数表。当派生类覆盖基类的虚函数时，会将虚函数表中对应的指针进行替换，从而调用派生类中覆盖后的虚函数，从而实现动态绑定。</p><h3 id="虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？"><a href="#虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？" class="headerlink" title="虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？"></a>虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？</h3><p>虚函数表是针对类的，类的所有对象共享这个类的虚函数表，每个对象内部都保存一个指向该类虚函数表的指针 <code>vptr</code>，每个对象的 <code>vptr</code> 的存放地址都不同，但都指向同一虚函数表。</p><h3 id="为什么基类的构造函数不能定义为虚函数？"><a href="#为什么基类的构造函数不能定义为虚函数？" class="headerlink" title="为什么基类的构造函数不能定义为虚函数？"></a>为什么基类的构造函数不能定义为虚函数？</h3><p>虚函数的调用依赖于虚函数表，而指向虚函数表的指针 <code>vptr</code> 需要在构造函数中进行初始化，所以无法调用定义为虚函数的构造函数。</p><h3 id="为什么基类的析构函数需要定义为虚函数？"><a href="#为什么基类的析构函数需要定义为虚函数？" class="headerlink" title="为什么基类的析构函数需要定义为虚函数？"></a>为什么基类的析构函数需要定义为虚函数？</h3><p>为了实现动态绑定，基类指针指向派生类对象，如果析构函数不是虚函数，那么在对象销毁时，就会调用基类的析构函数，只能销毁派生类对象中的部分数据，所以必须将析构函数定义为虚函数，从而在对象销毁时，调用派生类的析构函数，从而销毁派生类对象中的所有数据。</p><h3 id="构造函数和析构函数能抛出异常吗？"><a href="#构造函数和析构函数能抛出异常吗？" class="headerlink" title="构造函数和析构函数能抛出异常吗？"></a>构造函数和析构函数能抛出异常吗？</h3><ul><li><p>从语法的角度来说，构造函数可以抛出异常，但从逻辑和风险控制的角度来说，尽量不要抛出异常，否则可能导致内存泄漏</p></li><li><p>析构函数不可以抛出异常，如果析构函数抛出异常，则异常点之后的程序，比如释放内存等操作，就不会被执行，从而造成内存泄露的问题；而且当异常发生时，C++ 通常会调用对象的析构函数来释放资源，如果此时析构函数也抛出异常，即前一个异常未处理又出现了新的异常，从而造成程序崩溃的问题</p></li></ul><h3 id="纯虚函数有什么作用？如何实现？"><a href="#纯虚函数有什么作用？如何实现？" class="headerlink" title="纯虚函数有什么作用？如何实现？"></a>纯虚函数有什么作用？如何实现？</h3><p>作用是实现一个接口，起到规范的作用，想要继承这个类就必须覆盖该函数。</p><p>实现方式是在虚函数声明的结尾加上 <code>= 0</code> 即可。</p><h3 id="如何让一个类不能实例化？"><a href="#如何让一个类不能实例化？" class="headerlink" title="如何让一个类不能实例化？"></a>如何让一个类不能实例化？</h3><p>将类定义为抽象类（也就是存在纯虚函数）或者将构造函数声明为 <code>private</code>。</p><h3 id="public-成员、protected-成员、private-成员有什么区别？"><a href="#public-成员、protected-成员、private-成员有什么区别？" class="headerlink" title="public 成员、protected 成员、private 成员有什么区别？"></a><code>public</code> 成员、<code>protected</code> 成员、<code>private</code> 成员有什么区别？</h3><ul><li><p><code>public</code> 成员可以被本类及本类对象、友元类及友元类对象、子类及子类对象访问</p></li><li><p><code>protected</code> 成员可以被本类、友元类、子类访问，不能被任何对象访问</p></li><li><p><code>private</code> 成员只可以被本类访问</p></li></ul><h3 id="public-继承、protected-继承、private-继承有什么区别？"><a href="#public-继承、protected-继承、private-继承有什么区别？" class="headerlink" title="public 继承、protected 继承、private 继承有什么区别？"></a><code>public</code> 继承、<code>protected</code> 继承、<code>private</code> 继承有什么区别？</h3><p>不管哪类继承，子类都可以访问父类的 <code>public</code> 成员、<code>protected</code> 成员，但是继承之后，成员属性会发生变化：</p><table><thead><tr><th>父类成员</th><th><code>public</code> 继承后子类成员</th><th><code>protected</code> 继承后子类成员</th><th><code>private</code> 继承后子类成员</th></tr></thead><tbody><tr><td><code>public</code></td><td><code>public</code></td><td><code>protected</code></td><td><code>private</code></td></tr><tr><td><code>protected</code></td><td><code>protected</code></td><td><code>protected</code></td><td><code>private</code></td></tr><tr><td><code>private</code></td><td>无法继承</td><td>无法继承</td><td>无法继承</td></tr></tbody></table><h3 id="多继承存在什么问题？如何消除多继承中的二义性？"><a href="#多继承存在什么问题？如何消除多继承中的二义性？" class="headerlink" title="多继承存在什么问题？如何消除多继承中的二义性？"></a>多继承存在什么问题？如何消除多继承中的二义性？</h3><ul><li><p>增加程序的复杂度，使得程序的编写和维护比较困难，容易出错</p></li><li><p>在继承时，基类之间或基类与派生类之间发生成员同名时，将出现对成员访问的不确定性，即同名二义性；消除同名二义性的方法：</p><ul><li><p>利用作用域运算符 <code>::</code>，用于限定派生类使用的是哪个基类的成员</p></li><li><p>在派生类中定义同名成员，覆盖基类中的相关成员</p></li></ul></li><li><p>当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类的成员时，将产生另一种不确定性，即路径二义性；消除路径二义性的方法：</p><ul><li><p>消除同名二义性的两种方法都可以</p></li><li><p>使用虚继承，使得不同路径继承来的同名成员在内存中只有一份拷贝</p></li></ul></li></ul><h2 id="4-程序编译"><a href="#4-程序编译" class="headerlink" title="4 程序编译"></a>4 程序编译</h2><h3 id="程序编译的顺序是什么？"><a href="#程序编译的顺序是什么？" class="headerlink" title="程序编译的顺序是什么？"></a>程序编译的顺序是什么？</h3><ol><li><p>预处理：源代码经过预处理器，生成一个 <code>.i</code> 中间文件，这个阶段会把 <code>#include</code> 的头文件内容进行替换，并处理宏定义</p></li><li><p>编译：<code>.i</code> 中间文件生成 <code>.s</code> 汇编文件</p></li><li><p>汇编：<code>.s</code> 汇编文件经过汇编器生成 <code>.obj</code> 目标文件</p></li><li><p>链接：<code>.obj</code> 目标文件经过链接器，与 <code>lib</code> 静态链接库和 <code>dll</code> 动态链接库生成可执行文件</p></li></ol><h3 id="静态链接和动态链接有什么区别？"><a href="#静态链接和动态链接有什么区别？" class="headerlink" title="静态链接和动态链接有什么区别？"></a>静态链接和动态链接有什么区别？</h3><ul><li><p>静态链接是在编译链接时直接将需要的执行代码拷贝到调用处</p><ul><li><p>优点在于程序在发布时不需要依赖库，可以独立执行</p></li><li><p>缺点在于程序的体积会相对较大，而且如果静态库更新之后，所有可执行文件需要重新链接</p></li></ul></li><li><p>动态链接是在编译时不直接拷贝执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定代码时，在共享执行内存中寻找已经加载的动态库可执行代码，实现运行时链接</p><ul><li><p>优点在于多个程序可以共享同一个动态库，节省资源</p></li><li><p>缺点在于由于运行时加载，可能影响程序的前期执行性能</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前秋招，整理过一版 C++ 问题汇总，这次社招，重新梳理一遍。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://progcz.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="编程语言" scheme="https://progcz.com/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="CPP" scheme="https://progcz.com/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CPP/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="面试" scheme="https://progcz.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法的 C++ 实现、复杂度和稳定性分析</title>
    <link href="https://progcz.com/posts/1633654398/"/>
    <id>https://progcz.com/posts/1633654398/</id>
    <published>2021-10-08T00:55:03.000Z</published>
    <updated>2021-10-15T10:12:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>以下是在 LeetCode Playground 完成的 C++ 实现及测试用例：</p><ul><li><a href="https://leetcode.com/playground/gZfypPAn">https://leetcode.com/playground/gZfypPAn</a></li></ul><p>以下是来自<a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">菜鸟教程</a>的表格，给出了时间复杂度、空间复杂度和稳定性分析：</p><table><thead><tr><th align="center">算法</th><th align="center">时间复杂度 - 平均</th><th align="center">时间复杂度 - 最好</th><th align="center">时间复杂度 - 最坏</th><th align="center">空间复杂度</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center"><strong>冒泡排序</strong></td><td align="center"><code>O(n^2)</code></td><td align="center"><code>O(n)</code></td><td align="center"><code>O(n^2)</code></td><td align="center"><code>O(1)</code></td><td align="center">稳定</td></tr><tr><td align="center"><strong>插入排序</strong></td><td align="center"><code>O(n^2)</code></td><td align="center"><code>O(n)</code></td><td align="center"><code>O(n^2)</code></td><td align="center"><code>O(1)</code></td><td align="center">稳定</td></tr><tr><td align="center"><strong>选择排序</strong></td><td align="center"><code>O(n^2)</code></td><td align="center"><code>O(n^2)</code></td><td align="center"><code>O(n^2)</code></td><td align="center"><code>O(1)</code></td><td align="center">不稳定</td></tr><tr><td align="center"><strong>归并排序</strong></td><td align="center"><code>O(nlogn)</code></td><td align="center"><code>O(nlogn)</code></td><td align="center"><code>O(nlogn)</code></td><td align="center"><code>O(n)</code></td><td align="center">稳定</td></tr><tr><td align="center"><strong>快速排序</strong></td><td align="center"><code>O(nlogn)</code></td><td align="center"><code>O(nlogn)</code></td><td align="center"><code>O(n^2)</code></td><td align="center"><code>O(logn)</code></td><td align="center">不稳定</td></tr><tr><td align="center"><strong>计数排序</strong></td><td align="center"><code>O(n+k)</code></td><td align="center"><code>O(n+k)</code></td><td align="center"><code>O(n+k)</code></td><td align="center"><code>O(k)</code></td><td align="center">稳定</td></tr></tbody></table><span id="more"></span><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1 冒泡排序"></a>1 冒泡排序</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>遍历数组 <code>nums</code>，对于遍历到的元素 <code>nums[i]</code>，如果 <code>nums[i] &gt; nums[i+1]</code>，那么交换 <code>nums[i]</code> 和 <code>nums[i+1]</code>，这样一轮下来，最后一位必然是 <code>nums</code> 中最大的数字，在下一轮遍历中可以避开这一元素。不断重复这一过程，直到无可遍历元素为止。</p><p>可以参考来自<a href="https://www.runoob.com/w3cnote/bubble-sort.html">菜鸟教程</a>的动图：</p><p><img data-src="https://image.progcz.com/2021/10/15/01.gif"></p><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">bool</span> has_swap = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(nums[j], nums[j+<span class="number">1</span>]);</span><br><span class="line">                has_swap = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!has_swap) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info"><p>这里的实现，是在冒泡排序的基础实现之上，加了「早停」的思想，即：在一轮冒泡之后，如果没有发生交换，那么说明数组已经有序，直接退出即可。</p><p>这也是为什么，冒泡排序的时间复杂度在最好的情况下是 <code>O(n)</code>，因为最好的情况就是数组已经有序，只需遍历一次即可。</p></div><h2 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2 插入排序"></a>2 插入排序</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>遍历数组 <code>nums</code>，对于遍历到的元素 <code>nums[i]</code>，嵌套遍历并后移其前的元素，直到找到比 <code>nums[i]</code> 小的元素，将 <code>nums[i]</code> 插入其后即可。</p><p>可以参考来自<a href="https://www.runoob.com/w3cnote/insertion-sort.html">菜鸟教程</a>的动图：</p><p><img data-src="https://image.progcz.com/2021/10/15/02.gif"></p><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = nums[i], j = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; val; --j) &#123;</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+<span class="number">1</span>] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3 选择排序"></a>3 选择排序</h2><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><p>遍历数组 <code>nums</code>，对于遍历到的元素 <code>nums[i]</code>，嵌套遍历其后的所有元素，找出其中的最小值 <code>nums[min_num_idx]</code>，将 <code>nums[i]</code> 与 <code>nums[min_num_idx]</code> 进行交换即可。</p><p>可以参考来自<a href="https://www.runoob.com/w3cnote/selection-sort.html">菜鸟教程</a>的动图：</p><p><img data-src="https://image.progcz.com/2021/10/15/03.gif"></p><h3 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> min_num_idx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[min_num_idx]) &#123;</span><br><span class="line">                min_num_idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::<span class="built_in">swap</span>(nums[i], nums[min_num_idx]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4 归并排序"></a>4 归并排序</h2><h3 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h3><p>将数组 <code>nums</code> 拆分为左右两个子数组，不断向下递归，直到无法拆分为止。拷贝左右两个子数组，使用两个指针不断比较，较小者放入原数组中，自此向上递归。</p><p>可以参考来自<a href="https://www.runoob.com/w3cnote/merge-sort.html">菜鸟教程</a>的动图：</p><p><img data-src="https://image.progcz.com/2021/10/15/04.gif"></p><h3 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><p>递归版本：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive_core</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beg &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">merge_sort_recursive_core</span>(nums, beg, mid);</span><br><span class="line">    <span class="built_in">merge_sort_recursive_core</span>(nums, mid+<span class="number">1</span>, end);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">left_sub_arr</span><span class="params">(nums.begin()+beg, nums.begin()+mid+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">right_sub_arr</span><span class="params">(nums.begin()+mid+<span class="number">1</span>, nums.begin()+end+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = beg, left_idx = <span class="number">0</span>, right_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left_idx &lt;= mid-beg &amp;&amp; right_idx &lt;= end-mid<span class="number">-1</span>) &#123;</span><br><span class="line">        nums[i++] = left_sub_arr[left_idx] &lt; right_sub_arr[right_idx] ?</span><br><span class="line">            left_sub_arr[left_idx++] : right_sub_arr[right_idx++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (left_idx &lt;= mid-beg) &#123;</span><br><span class="line">        nums[i++] = left_sub_arr[left_idx++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (right_idx &lt;= end-mid<span class="number">-1</span>) &#123;</span><br><span class="line">        nums[i++] = right_sub_arr[right_idx++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">merge_sort_recursive_core</span>(nums, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环版本：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_loop</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> seg = <span class="number">1</span>; seg &lt; n; seg *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> beg = <span class="number">0</span>; beg &lt; n; beg += seg*<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = <span class="built_in">min</span>(n<span class="number">-1</span>, beg+seg<span class="number">-1</span>), end = <span class="built_in">min</span>(n<span class="number">-1</span>, beg+seg*<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">            <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">left_sub_arr</span><span class="params">(nums.begin()+beg, nums.begin()+mid+<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">right_sub_arr</span><span class="params">(nums.begin()+mid+<span class="number">1</span>, nums.begin()+end+<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">int</span> i = beg, left_idx = <span class="number">0</span>, right_idx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (left_idx &lt;= mid-beg &amp;&amp; right_idx &lt;= end-mid<span class="number">-1</span>) &#123;</span><br><span class="line">                nums[i++] = left_sub_arr[left_idx] &lt; right_sub_arr[right_idx] ? left_sub_arr[left_idx++] : right_sub_arr[right_idx++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left_idx &lt;= mid-beg) &#123;</span><br><span class="line">                nums[i++] = left_sub_arr[left_idx++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (right_idx &lt;= end-mid<span class="number">-1</span>) &#123;</span><br><span class="line">                nums[i++] = right_sub_arr[right_idx++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5 快速排序"></a>5 快速排序</h2><h3 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h3><p>在数组 <code>nums</code> 中，挑选出一个基准数字 <code>pivot</code>，一般为数组头部的数字。使用两个指针 <code>beg</code> 和 <code>end</code> 分别从数组头部和尾部遍历，<code>nums[end]</code> 比 <code>pivot</code> 小者挪至 <code>beg</code> 处，<code>nums[beg]</code> 比 <code>pivot</code> 大者挪至 <code>end</code> 处，从而保证在 <code>beg</code> 和 <code>end</code> 相遇时，相遇位置左侧的所有元素均小于 <code>pivot</code>，相遇位置右侧的所有元素均大于 <code>pivot</code>。之后递归地处理左右两个子数组即可。</p><p>可以参考来自<a href="https://www.runoob.com/w3cnote/quick-sort-2.html">菜鸟教程</a>的动图：</p><p><img data-src="https://image.progcz.com/2021/10/15/05.gif"></p><h3 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><p>递归版本：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partition_recursive</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beg &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[beg], <span class="keyword">beg_t</span> = beg, <span class="keyword">end_t</span> = end;</span><br><span class="line">    <span class="keyword">while</span> (beg &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (beg &lt; end &amp;&amp; nums[end] &gt; pivot) --end;</span><br><span class="line">        nums[beg] = nums[end];</span><br><span class="line">        <span class="keyword">while</span> (beg &lt; end &amp;&amp; nums[beg] &lt;= pivot) ++beg;</span><br><span class="line">        nums[end] = nums[beg];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[beg] = pivot;</span><br><span class="line">    <span class="built_in">partition_recursive</span>(nums, <span class="keyword">beg_t</span>, beg<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">partition_recursive</span>(nums, beg+<span class="number">1</span>, <span class="keyword">end_t</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort_recursive</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">partition_recursive</span>(nums, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环版本：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition_loop</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beg &gt;= end) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[beg], <span class="keyword">beg_t</span> = beg, <span class="keyword">end_t</span> = end;</span><br><span class="line">    <span class="keyword">while</span> (beg &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (beg &lt; end &amp;&amp; nums[end] &gt; pivot) --end;</span><br><span class="line">        nums[beg] = nums[end];</span><br><span class="line">        <span class="keyword">while</span> (beg &lt; end &amp;&amp; nums[beg] &lt;= pivot) ++beg;</span><br><span class="line">        nums[end] = nums[beg];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[beg] = pivot;</span><br><span class="line">    <span class="keyword">return</span> beg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort_loop</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    std::stack&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(&#123;<span class="number">0</span>, n<span class="number">-1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [beg, end] = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="built_in">partition_loop</span>(nums, beg, end);</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        s.<span class="built_in">push</span>(&#123;beg, idx<span class="number">-1</span>&#125;);</span><br><span class="line">        s.<span class="built_in">push</span>(&#123;idx+<span class="number">1</span>, end&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-计数排序"><a href="#6-计数排序" class="headerlink" title="6 计数排序"></a>6 计数排序</h2><h3 id="基本思想-5"><a href="#基本思想-5" class="headerlink" title="基本思想"></a>基本思想</h3><p>计数排序适用于：数据的范围不大，方差不大，且均为离散值。</p><p>在数组 <code>nums</code> 中，找到最小值 <code>min_num</code> 和最大值 <code>max_num</code>，就可以得到 <code>nums</code> 中数字的范围，将这个范围表示为计数数组 <code>cnts</code>，将 <code>nums</code> 中数字在对应索引处进行计数，最后将 <code>cnts</code> 中的数字依次填回 <code>nums</code> 即可。</p><p>可以参考来自<a href="https://www.runoob.com/w3cnote/counting-sort.html">菜鸟教程</a>的动图：</p><p><img data-src="https://image.progcz.com/2021/10/15/06.gif"></p><h3 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counting_sort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> min_num = INT_MAX, max_num = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">        min_num = <span class="built_in">min</span>(min_num, num);</span><br><span class="line">        max_num = <span class="built_in">max</span>(max_num, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnts</span><span class="params">(max_num-min_num+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">        ++cnts[num-min_num];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_num-min_num+<span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = cnts[i]; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">            nums[idx++] = min_num + i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;以下是在 LeetCode Playground 完成的 C++ 实现及测试用例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode.com/playground/gZfypPAn&quot;&gt;https://leetcode.com/playground/gZfypPAn&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是来自&lt;a href=&quot;https://www.runoob.com/w3cnote/ten-sorting-algorithm.html&quot;&gt;菜鸟教程&lt;/a&gt;的表格，给出了时间复杂度、空间复杂度和稳定性分析：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;算法&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;时间复杂度 - 平均&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;时间复杂度 - 最好&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;时间复杂度 - 最坏&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;空间复杂度&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;稳定性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;冒泡排序&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n^2)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n^2)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(1)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;插入排序&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n^2)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n^2)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(1)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;选择排序&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n^2)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n^2)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n^2)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(1)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;不稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;归并排序&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(nlogn)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(nlogn)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(nlogn)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;快速排序&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(nlogn)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(nlogn)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n^2)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(logn)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;不稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;计数排序&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n+k)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n+k)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n+k)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(k)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="技术" scheme="https://progcz.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="数据结构与算法" scheme="https://progcz.com/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="数据结构与算法" scheme="https://progcz.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="Sort" scheme="https://progcz.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>上海迪士尼乐园攻略：两人行一日游</title>
    <link href="https://progcz.com/posts/1624282620/"/>
    <id>https://progcz.com/posts/1624282620/</id>
    <published>2021-06-21T13:41:11.000Z</published>
    <updated>2021-06-26T06:24:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>从去年开始，女朋友就一直念着想去上海迪士尼乐园，然而疫情使得计划一拖再拖，直到上周六才如愿以偿。</p><p>不得不说，迪士尼乐园的确是真实世界中最接近于「童话王国」的地方，迪士尼作品中的经典形象在这里都触手可及。你可以是杰克船长的水手，也可以是冰雪女王的朋友；你可以坐在蜜罐里和小熊维尼打招呼，也可以跟着小飞侠穿梭在城市的上空。</p><p>迪士尼满足你的童心、少女心，以及对于浪漫的一切幻想。<del>只要你肯花钱。</del></p><p><img data-src="https://image.progcz.com/2021/06/25.png"></p><span id="more"></span><div class="note info"><p>友情提示：上海迪士尼乐园的政策几乎每月一变，可能导致攻略失效，比如很多攻略中提到的 FP 早就不复存在了，所以以下内容与其称为攻略，不如说是记录，仅供参考。</p></div><h2 id="1-购买门票"><a href="#1-购买门票" class="headerlink" title="1 购买门票"></a>1 购买门票</h2><p>我是在美团上购买的门票，价格大概是官方打 93 折。</p><blockquote><p>需要注意的是，不管是什么渠道购买的门票，都会有一行类似的注意事项：</p><p><em>乐园门票一经售出不可转让、不可退款，除非法律另有规定。指定日门票可在尚有余票且补足票价差额的前提下，于有效日的两日前更换两次等值或者更高价值的指定日门票。</em></p><p>而且我当时看到只能更换为当月的门票，所以建议提前规划行程，尤其注意天气。</p></blockquote><h2 id="2-准备随身携带的物品"><a href="#2-准备随身携带的物品" class="headerlink" title="2 准备随身携带的物品"></a>2 准备随身携带的物品</h2><p>记得携带身份证、口罩（疫情期间）、手机、移动电源及数据线、一次性雨衣（漂流项目和下雨天气）、空的非玻璃水瓶（园区内直饮水）、防晒用品（夏季）、小风扇（夏季）等等。</p><p>不能携带自拍杆、折叠椅、自热食物等等。</p><p>更多参考<a href="https://www.shanghaidisneyresort.com/rules/">上海迪士尼乐园游客须知</a>。</p><h2 id="3-住宿"><a href="#3-住宿" class="headerlink" title="3 住宿"></a>3 住宿</h2><p>我本身在上海，不用考虑住宿，所以这一部分就跳过了。</p><h2 id="4-入园"><a href="#4-入园" class="headerlink" title="4 入园"></a>4 入园</h2><p>如果购买早享卡，可以提前一个小时入园。</p><p>如果不买早享卡，建议提前至少一个小时到达园区门口排队，有包游客需要过有包安检，比较慢，无包游客只需要过安检门，比较快。</p><blockquote><p>需要注意的是，同一订单的多张门票必须同时入园，所以要么分不同订单来购买门票，要么同行的人都排有包安检，除非大家都不带包。</p></blockquote><h2 id="5-游玩"><a href="#5-游玩" class="headerlink" title="5 游玩"></a>5 游玩</h2><p>提前下载好上海迪士尼乐园的 APP，入园后将同行门票绑定在同一个 APP 内，优先领取预约等候卡，没有预约等候卡的项目可以在游玩过程中视排队情况购买尊享卡。</p><ol><li><p>领取预约等候卡，等于拥有在高峰时段排队的资格。每天可领取预约等候卡的项目不固定，可以当日在 APP 内查询。</p></li><li><p>购买尊享卡，等于拥有在任意时段插队的资格。如果想买尊享卡的项目比较多，可以考虑八件套或者六件套。</p></li></ol><p>放张盗来的图，热门项目基本一览无余。</p><p><img data-src="https://image.progcz.com/2021/06/26.png"></p><p>再来分享一波自己拍的照片。</p><p>两个必看的舞台剧：风暴来临·杰克船长之惊天特技大冒险 &amp; 冰雪奇缘·欢唱盛会。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://image.progcz.com/2021/06/27.png"></div><div class="group-picture-column"><img data-src="https://image.progcz.com/2021/06/28.png"></div></div></div><p>在漫威总部见到了钢铁侠的历代战甲，还碰到了钢铁侠的 COS，可惜是个视频没办法传上来。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://image.progcz.com/2021/06/29.png"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://image.progcz.com/2021/06/30.png"></div><div class="group-picture-column"><img data-src="https://image.progcz.com/2021/06/31.png"></div></div></div><p>夜晚的旋转木马，可以说是如梦如幻了。</p><p><img data-src="https://image.progcz.com/2021/06/32.png"></p><h2 id="6-就餐"><a href="#6-就餐" class="headerlink" title="6 就餐"></a>6 就餐</h2><p>图个省事，我和女朋友在园区内吃的午饭和晚饭，每顿人均 100 左右。</p><p>午饭在加勒比海盗附近的巴博萨烧烤，左图的秋刀鱼套餐很不错。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://image.progcz.com/2021/06/33.png"></div><div class="group-picture-column"><img data-src="https://image.progcz.com/2021/06/34.png"></div></div></div><p>晚饭在创极速光轮附近的星露台餐厅，钢铁侠牛肉汉堡非常难吃，不放图了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从去年开始，女朋友就一直念着想去上海迪士尼乐园，然而疫情使得计划一拖再拖，直到上周六才如愿以偿。&lt;/p&gt;
&lt;p&gt;不得不说，迪士尼乐园的确是真实世界中最接近于「童话王国」的地方，迪士尼作品中的经典形象在这里都触手可及。你可以是杰克船长的水手，也可以是冰雪女王的朋友；你可以坐在蜜罐里和小熊维尼打招呼，也可以跟着小飞侠穿梭在城市的上空。&lt;/p&gt;
&lt;p&gt;迪士尼满足你的童心、少女心，以及对于浪漫的一切幻想。&lt;del&gt;只要你肯花钱。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://image.progcz.com/2021/06/25.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="经历" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="上海" scheme="https://progcz.com/tags/%E4%B8%8A%E6%B5%B7/"/>
    
    <category term="迪士尼" scheme="https://progcz.com/tags/%E8%BF%AA%E5%A3%AB%E5%B0%BC/"/>
    
    <category term="加勒比海盗" scheme="https://progcz.com/tags/%E5%8A%A0%E5%8B%92%E6%AF%94%E6%B5%B7%E7%9B%97/"/>
    
    <category term="漫威" scheme="https://progcz.com/tags/%E6%BC%AB%E5%A8%81/"/>
    
  </entry>
  
  <entry>
    <title>招商银行朝朝宝：余额宝和零钱通的最佳替代品</title>
    <link href="https://progcz.com/posts/1620777814/"/>
    <id>https://progcz.com/posts/1620777814/</id>
    <published>2021-05-12T00:05:49.000Z</published>
    <updated>2021-05-13T14:14:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我们看向历史的后视镜，2013 年面世的余额宝确实是一款影响十分深远的产品，它永久地改变了人们对于短期闲置现金的处置方式，更进一步地推动了无现金支付的发展。邯郸学步的零钱通后来也不断壮大，和余额宝一起，成为人们活期理财的首要选择。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://image.progcz.com/2021/05/03.png"></div><div class="group-picture-column"><img data-src="https://image.progcz.com/2021/05/04.png"></div></div></div><p>达成这一切，靠的便是直击用户痛点的两个特性：<strong>高收益率</strong>和<strong>随时支取</strong>。</p><p>然而，眼看着互联网金融的繁荣发展，银行自然不能坐以待毙。</p><p>招商银行推出的<strong>朝朝宝</strong>便是这样一款狙击余额宝/零钱通的活期理财产品，极大地吸引了以招商银行卡为主力卡的用户，比如我。</p><span id="more"></span><h2 id="1-在余额宝出现之前，用于日常支出的钱都放在哪里？"><a href="#1-在余额宝出现之前，用于日常支出的钱都放在哪里？" class="headerlink" title="1 在余额宝出现之前，用于日常支出的钱都放在哪里？"></a>1 在余额宝出现之前，用于日常支出的钱都放在哪里？</h2><p>无非三个选择：钱包、银行卡的活期账户、支付宝的余额。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://image.progcz.com/2021/05/05.png"></div><div class="group-picture-column"><img data-src="https://image.progcz.com/2021/05/06.png"></div><div class="group-picture-column"><img data-src="https://image.progcz.com/2021/05/07.png"></div></div></div><p>这样看来，钱包和银行卡的活期账户明显是更优的选择，因为</p><ul><li>如果场景不支持扫码，可以用钱包中的现金，或者 POS 机刷银行卡支付。</li><li>如果场景支持扫码，可以在支付宝中选择使用银行卡支付。</li></ul><p>更何况，放在银行卡里，还有聊胜于无的利息收入，放在支付宝余额里，就真的只是放着而已。</p><p>所以，<strong>用户好像没有什么动力，特地把银行卡里的钱转到支付宝里。</strong></p><h2 id="2-余额宝解决了什么痛点？"><a href="#2-余额宝解决了什么痛点？" class="headerlink" title="2 余额宝解决了什么痛点？"></a>2 余额宝解决了什么痛点？</h2><h3 id="2-1-高收益率"><a href="#2-1-高收益率" class="headerlink" title="2.1 高收益率"></a>2.1 高收益率</h3><p>众所周知，余额宝本质上属于货币基金。</p><blockquote><p>货币基金的运作方式可以简单理解为，基金将用户的钱集中起来，去跟银行谈一个利息较高的大额存款，再将利息作为收益返还给用户。</p></blockquote><p>好，这就为余额宝带来了第一个极具吸引力的特性：<strong>我把钱放在余额宝里，是有收益的，而且收益远高于银行卡的活期利息。</strong></p><div class="note info"><p>热知识：2014 年，余额宝的七日年化曾高达 6.76%，万份收益 1.8 元左右。</p></div><p>但是，用户还有个小问题：我为啥不选择其他货币基金？</p><h3 id="2-2-随时支取"><a href="#2-2-随时支取" class="headerlink" title="2.2 随时支取"></a>2.2 随时支取</h3><p>我们都知道，余额宝可以用于扫码支付、淘宝购物。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://image.progcz.com/2021/05/08.png"></div><div class="group-picture-column"><img data-src="https://image.progcz.com/2021/05/09.png"></div></div></div><p>其支撑就在于，不同于当时的其他货币基金，余额宝提供了 T+0 的快速赎回方式。</p><p>好，第二个极具吸引力的特性向我们走来：<strong>我把钱放在余额宝里，24 小时均可取出，几分钟内到账。</strong></p><p>如今，众多「宝宝」类产品，比如天天基金的活期宝，其背后的货币基金也可以实现 T+0，但是无法打通消费场景，这是来自于支付宝的降维打击。</p><h2 id="3-余额宝还有什么缺点？"><a href="#3-余额宝还有什么缺点？" class="headerlink" title="3 余额宝还有什么缺点？"></a>3 余额宝还有什么缺点？</h2><h3 id="3-1-收益率不断下滑"><a href="#3-1-收益率不断下滑" class="headerlink" title="3.1 收益率不断下滑"></a>3.1 收益率不断下滑</h3><p>我不是经济专家，无法准确给出收益率下滑的原因。</p><p>但是对于一个用户而言，这就让我把钱转到余额宝里的动力越来越低。</p><div class="note warning"><p>内心 OS：每天就那么点收益，何必费那个劲呢？</p></div><h3 id="3-2-资金分散，不便管理"><a href="#3-2-资金分散，不便管理" class="headerlink" title="3.2 资金分散，不便管理"></a>3.2 资金分散，不便管理</h3><p>这实际上并不是余额宝的缺点，而是支付宝和微信支付二分天下带来的问题。</p><p>对于日常收支、投资理财，我有非常清晰的记录和规划。我每月初都会花十几分钟的时间整理一个表格，上面清晰地记录着我的每一分钱都放在什么地方，同时根据现状做出调整和规划。</p><p>具体到用于日常支出的短期闲置现金，我一般会在余额宝和零钱通分别放 5K 整。这样的话，下个月初我就能根据剩多少钱，快速算出上个月的支出。如果有异常，再去查看账单明细，看看是什么事情花费较多，有没有可优化的空间。</p><p>虽然管理两处也不是什么特别麻烦的事情，但是如果能合为一处岂不快哉。</p><h2 id="4-为什么推荐朝朝宝？"><a href="#4-为什么推荐朝朝宝？" class="headerlink" title="4 为什么推荐朝朝宝？"></a>4 为什么推荐朝朝宝？</h2><p>对于我而言，朝朝宝完美解决了上面两个缺点。</p><h3 id="4-1-收益方面"><a href="#4-1-收益方面" class="headerlink" title="4.1 收益方面"></a>4.1 收益方面</h3><p>朝朝宝的七日年化高达 3.10%，万分收益 0.8 元左右。</p><div class="note warning"><p>作为对比，支付宝的七日年化只有 2.12%，万份收益 0.5 元左右。</p></div><p>这一点主要得益于<strong>朝朝宝背后并不是货币基金，而是五款风险评级均为 R1 的招行代销理财产品，</strong>在收益较高的同时也保证了资金的安全性。</p><blockquote><p>其中一款代销理财细节可以看官网资料：<a href="http://www.cmbchina.com/cfweb/personal/saproductdetail.aspx?saaCod=D07&funCod=8920">招银理财招赢聚宝盆 1 号现金管理类理财计划</a></p></blockquote><p>当然，收益率会不会像余额宝一样下滑，还需要持续观察，至少现在是高的对吧。</p><h3 id="4-2-管理方面"><a href="#4-2-管理方面" class="headerlink" title="4.2 管理方面"></a>4.2 管理方面</h3><p>朝朝宝支持支付宝支付，微信支付，银行转账，ATM 取款，还信用卡、花呗和贷款，购买银行理财和基金等，如果不出意外的话，应该还支持 Apple Pay 或者其他 Pay（我没试过）。</p><p><img data-src="https://image.progcz.com/2021/05/10.png"></p><p>我只需要每月初在朝朝宝里放 1W 整，不管是支付宝还是微信支付，在扫码后选择使用银行卡支付即可。</p><p>这样的话，我就可以集中管理生活中各个方面的支出情况，我直接大呼过瘾。</p><div class="note warning"><p>需要注意的是，朝朝宝最多可转入 5W，每日也最多可转出 5W，对于日常支出较多的人来说可能不是很友好。</p></div><h2 id="5-后记"><a href="#5-后记" class="headerlink" title="5 后记"></a>5 后记</h2><p>这不是朝朝宝的软文（招行也不至于卑贱到来找我写软文），单纯只是我想分享一下好的理财产品。不构成理财建议，但是如果对你有所帮助，那就再好不过了。也祝自己早日暴富！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当我们看向历史的后视镜，2013 年面世的余额宝确实是一款影响十分深远的产品，它永久地改变了人们对于短期闲置现金的处置方式，更进一步地推动了无现金支付的发展。邯郸学步的零钱通后来也不断壮大，和余额宝一起，成为人们活期理财的首要选择。&lt;/p&gt;
&lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot;&gt;&lt;img data-src=&quot;https://image.progcz.com/2021/05/03.png&quot;&gt;&lt;/div&gt;&lt;div class=&quot;group-picture-column&quot;&gt;&lt;img data-src=&quot;https://image.progcz.com/2021/05/04.png&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;达成这一切，靠的便是直击用户痛点的两个特性：&lt;strong&gt;高收益率&lt;/strong&gt;和&lt;strong&gt;随时支取&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然而，眼看着互联网金融的繁荣发展，银行自然不能坐以待毙。&lt;/p&gt;
&lt;p&gt;招商银行推出的&lt;strong&gt;朝朝宝&lt;/strong&gt;便是这样一款狙击余额宝/零钱通的活期理财产品，极大地吸引了以招商银行卡为主力卡的用户，比如我。&lt;/p&gt;</summary>
    
    
    
    <category term="投资" scheme="https://progcz.com/categories/%E6%8A%95%E8%B5%84/"/>
    
    <category term="银行理财" scheme="https://progcz.com/categories/%E6%8A%95%E8%B5%84/%E9%93%B6%E8%A1%8C%E7%90%86%E8%B4%A2/"/>
    
    
    <category term="招商银行" scheme="https://progcz.com/tags/%E6%8B%9B%E5%95%86%E9%93%B6%E8%A1%8C/"/>
    
    <category term="朝朝宝" scheme="https://progcz.com/tags/%E6%9C%9D%E6%9C%9D%E5%AE%9D/"/>
    
    <category term="余额宝" scheme="https://progcz.com/tags/%E4%BD%99%E9%A2%9D%E5%AE%9D/"/>
    
    <category term="零钱通" scheme="https://progcz.com/tags/%E9%9B%B6%E9%92%B1%E9%80%9A/"/>
    
    <category term="活期理财" scheme="https://progcz.com/tags/%E6%B4%BB%E6%9C%9F%E7%90%86%E8%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>从一封邮件谈谈我为什么不再想要评论系统</title>
    <link href="https://progcz.com/posts/1620608429/"/>
    <id>https://progcz.com/posts/1620608429/</id>
    <published>2021-05-10T01:01:20.000Z</published>
    <updated>2021-05-11T15:08:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>在重建站点的过程中，我曾经挣扎过要不要重设评论系统。</p><p>基础设施方面，适用于静态博客的各类评论系统都已经发展得比较成熟，比如独立服务的 <a href="https://blog.disqus.com/">Disqus</a>、依赖 GitHub Issues 的 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 和 <a href="https://github.com/utterance/utterances">Utterances</a>、依赖 LeanCloud 等的 <a href="https://github.com/xCss/Valine">Valine</a> 和 <a href="https://github.com/lizheming/waline">Waline</a>，选择颇多。</p><p>对于博客而言，评论系统可以让读者更方便地给出反馈，和作者交流彼此的观点和看法。</p><p>但是如你所见，我还是没有重设评论系统。</p><p>真正促使我放弃的，根本原因是<strong>互联网中随处可见的，无知、无营养甚至充满恶意的评论。</strong></p><p>而导火索则是这样一封邮件：</p><p><img data-src="https://image.progcz.com/2021/05/01.png"></p><span id="more"></span><h2 id="1-事情起因（我的猜测）"><a href="#1-事情起因（我的猜测）" class="headerlink" title="1 事情起因（我的猜测）"></a>1 事情起因（我的猜测）</h2><p>这位朋友曾经使用 Cloudflare 搭过 Google Scholar 的镜像网站，突然发现不可用了，于是在 Google 搜索相关信息，看到了我一年前写的这篇文章：<a href="https://progcz.com/posts/use-cf-workers-build-google-and-github-mirrors/">使用 Cloudflare Workers 搭建 Google 和 GitHub 镜像网站</a>，认为是我的分享和传播导致了 Cloudflare 不可用，怒不可遏的同时又看到了我的邮箱，于是就有了上面那封邮件。</p><h2 id="2-我的看法"><a href="#2-我的看法" class="headerlink" title="2 我的看法"></a>2 我的看法</h2><p>这位朋友的核心观点在于：<strong>这样的知识，自己知道就好了，不要拿出来分享。</strong></p><p>可以说是非常自私了，而且多少有点逻辑的人都能看出这里面的问题：<strong>如果每个人都不分享这样的知识，那这位朋友又是从哪里获取到的呢？靠自己顿悟吗？</strong></p><p>我有时候也会很纳闷，为什么这么简单的道理，都没有出现在这类朋友的脑子里。</p><p>如果是其他网民，我可能可以理解。因为根据<a href="https://finance.sina.com.cn/tech/2020-09-29/doc-iivhuipp7144597.shtml">这篇文章</a>，2020 年网民的规模达 9.40 亿，其中学历达到本科及以上的仅为 8.8％。没有经历过高等教育的话，认知是会受到一定限制。</p><p>但是这位朋友提到了谷歌学术，说明至少已经到了高等教育的阶段，却依然这么狭隘，让我匪夷所思。</p><p>当然，这种情况不止发生了一次，在评论量较大的博客、在我认为社区氛围很好的 B 站和豆瓣，我都会频繁地看到这类评论，不然我也不会对互联网的评论环境如此失望。</p><h2 id="3-我的回复"><a href="#3-我的回复" class="headerlink" title="3 我的回复"></a>3 我的回复</h2><p>尽管无法理解，但我还是出于本能的 defence，回复了这封邮件：</p><p><img data-src="https://image.progcz.com/2021/05/02.png"></p><p>看，这也是我不想要评论系统的原因之一，我不想为了这种事情 defence 啊。</p><p>人生已经很累了，照顾好自己的情绪都是一件非常困难的事情，就更不想陷入这种本不该存在的争论之中了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在重建站点的过程中，我曾经挣扎过要不要重设评论系统。&lt;/p&gt;
&lt;p&gt;基础设施方面，适用于静态博客的各类评论系统都已经发展得比较成熟，比如独立服务的 &lt;a href=&quot;https://blog.disqus.com/&quot;&gt;Disqus&lt;/a&gt;、依赖 GitHub Issues 的 &lt;a href=&quot;https://github.com/gitalk/gitalk&quot;&gt;Gitalk&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/utterance/utterances&quot;&gt;Utterances&lt;/a&gt;、依赖 LeanCloud 等的 &lt;a href=&quot;https://github.com/xCss/Valine&quot;&gt;Valine&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/lizheming/waline&quot;&gt;Waline&lt;/a&gt;，选择颇多。&lt;/p&gt;
&lt;p&gt;对于博客而言，评论系统可以让读者更方便地给出反馈，和作者交流彼此的观点和看法。&lt;/p&gt;
&lt;p&gt;但是如你所见，我还是没有重设评论系统。&lt;/p&gt;
&lt;p&gt;真正促使我放弃的，根本原因是&lt;strong&gt;互联网中随处可见的，无知、无营养甚至充满恶意的评论。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而导火索则是这样一封邮件：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://image.progcz.com/2021/05/01.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="折腾" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="博客" scheme="https://progcz.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>谈谈 Hexo 的主题现状以及我对 NexT 的细节改造</title>
    <link href="https://progcz.com/posts/1619784301/"/>
    <id>https://progcz.com/posts/1619784301/</id>
    <published>2021-04-30T15:05:45.000Z</published>
    <updated>2021-04-30T15:05:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>上次发文还是三月初，中间停更了这么久，主要原因在于，之前我对主题源码进行了侵入式的改造，难以升级享受最新的版本特性，于是我就想要重建这个博客站点，兼顾可升级和可改造。</p><p>那我就想，既然要重建，何不换个主题试一下？果然，试试就逝世。</p><span id="more"></span><h2 id="1-Hexo-主题"><a href="#1-Hexo-主题" class="headerlink" title="1 Hexo 主题"></a>1 Hexo 主题</h2><p>在静态博客框架中，Hexo 向来是最受青睐的选择，没有之一。</p><p>Jekyll 作为 GitHub 官方支持的框架，可以直接托管源码而无需手动生成静态网页，Hugo 借助 Go 语言的性能优势，号称全世界最快的框架，然而这两者都有一点远落后于 Hexo，那就是最为关键的<strong>主题生态</strong>。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://image.progcz.com/2021/04/01.png"></div><div class="group-picture-column"><img data-src="https://image.progcz.com/2021/04/02.png"></div></div></div><p>作为一个想搭博客的人来说，审美能对自己胃口才是头等大事，所以主题生态只有枝繁叶茂才能留住众口难调的用户。</p><p>Hexo 使用 Node.js 开发，从语言层面上就吸引了大批优秀的前端工程师，精美主题可以说是层出不穷。</p><p>当然再好的主题也必然有令人不甚满意的地方，这里就把 Butterfly 单拎出来说说问题。</p><h3 id="1-1-Butterfly"><a href="#1-1-Butterfly" class="headerlink" title="1.1 Butterfly"></a>1.1 <a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></h3><p><img data-src="https://image.progcz.com/2021/04/03.png"></p><p>简洁好看，尤其是首屏的视觉效果，足够吸引眼球。这也是我刚开始重建的第一选择。</p><p>但是这个主题，说得严重一点，「金玉其外，败絮其中。」</p><p>我相信，任何用过 Butterfly 的人，一定会被 <code>_config.butterfly.yml</code> 中混乱的配置给搞得心烦意乱，举个栗子：</p><p>配置中有一段是关于网站默认的展示模式，可以选择明亮/暗黑：</p><figure class="highlight yaml"><figcaption><span>code</span><a href="https://github.com/jerryc127/hexo-theme-butterfly/blob/dev/_config.yml">_config.yml</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Default display mode (網站默認的顯示模式)</span></span><br><span class="line"><span class="comment"># light (default) / dark</span></span><br><span class="line"><span class="attr">display_mode:</span> <span class="string">light</span></span><br></pre></td></tr></table></figure><p>然而在后面又出现了一段是关于暗黑模式，可以选择是否开启：</p><figure class="highlight yaml"><figcaption><span>code</span><a href="https://github.com/jerryc127/hexo-theme-butterfly/blob/dev/_config.yml">_config.yml</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># dark mode</span></span><br><span class="line"><span class="attr">darkmode:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Toggle Button to switch dark/light mode</span></span><br><span class="line">    <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Switch dark/light mode automatically (自動切換 dark mode和 light mode)</span></span><br><span class="line">    <span class="comment"># autoChangeMode: 1  Following System Settings, if the system doesn&#x27;t support dark mode, it will switch dark mode between 6 pm to 6 am</span></span><br><span class="line">    <span class="comment"># autoChangeMode: 2  Switch dark mode between 6 pm to 6 am</span></span><br><span class="line">    <span class="comment"># autoChangeMode: false</span></span><br><span class="line">    <span class="attr">autoChangeMode:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这让我不禁想问：如果我在前面选了默认明亮模式，后面又选了开启暗黑模式，那主题到底是展现哪一种？只有试过之后才能知道，无疑增加了理解成本。</p><p>类似的问题还有很多，就不赘述了。总之这个配置文件折磨了我很久，最终不得不放弃。</p><div class="note warning"><p>不管怎样，我还是很尊重主题作者的，提供免费开源的主题给大家用，本身就非常值得敬佩。但还是那句话，「若批评不自由，则赞美无意义。」</p><p><del>而且感觉主题作者是个暴躁老哥，惹不太起。</del></p></div><h2 id="2-NexT-改造"><a href="#2-NexT-改造" class="headerlink" title="2 NexT 改造"></a>2 NexT 改造</h2><p>当然，我换过不止 Butterfly 一个主题，然而其他主题即便没有混乱的配置文件，也存在大量优化不到位的细节，所以兜兜转转又回到了 NexT 的怀抱。</p><h3 id="2-1-基本配置"><a href="#2-1-基本配置" class="headerlink" title="2.1 基本配置"></a>2.1 基本配置</h3><p><code>_config.yml</code> 和 <code>_config.next.yml</code> 中的配置基本都体现在 <a href="https://github.com/ProgCZ/blog-cloud/commit/f3cdd681835389803f187024e06124960f48d251">commit f3cdd68</a> 中，不再赘述。</p><h3 id="2-2-特殊改造"><a href="#2-2-特殊改造" class="headerlink" title="2.2 特殊改造"></a>2.2 特殊改造</h3><p>特殊改造基本都体现在 <a href="https://github.com/ProgCZ/blog-cloud/commit/3d56b383f78c1b260edb668ff7ed8e0d6f5232fd">commit 3d56b38</a> 中，没有污染博客源码，只是通过自定义的 js 和 css 来实现。</p><ol><li><p>替换站点标题中不规范的部分</p><p> 如果足够细心的话，你就会发现，在每个分类页面中，标题中的冒号都是英文冒号，不符合中文排版规范：</p><p> <img data-src="https://image.progcz.com/2021/04/04.png"></p><p> 替换后：</p><p> <img data-src="https://image.progcz.com/2021/04/05.png"></p></li><li><p>替换归档页面中不规范的部分</p><p> 归档页面中，表达冗余，且英文叹号也不符合中文排版规范：</p><p> <img data-src="https://image.progcz.com/2021/04/06.png"></p><p> 替换后：</p><p> <img data-src="https://image.progcz.com/2021/04/07.png"></p></li><li><p>替换文章信息中不规范的部分</p><p> 这个单纯是我看中文逗号不顺眼，不能表达分类之间的层级关系：</p><p> <img data-src="https://image.progcz.com/2021/04/08.png"></p><p> 替换后：</p><p> <img data-src="https://image.progcz.com/2021/04/09.png"></p></li><li><p>替换页脚中不规范的部分</p><p> 这个也单纯是我看 copyright 字符不顺眼，有点矮：</p><p> <img data-src="https://image.progcz.com/2021/04/10.png"></p><p> 替换后：</p><p> <img data-src="https://image.progcz.com/2021/04/11.png"></p></li><li><p>动画速度调整至 0.3s</p> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.animated</span> &#123;</span><br><span class="line">    <span class="attribute">animation-duration</span>: <span class="number">0.3s</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>侧边栏字体从 <code>font-size-smaller</code> 调大至 <code>font-size-small</code></p> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu-item</span> &#123;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: $font-size-small;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.links-of-author</span> &#123;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: $font-size-small;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.site-state-item-name</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: $font-size-small;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-后记"><a href="#3-后记" class="headerlink" title="3 后记"></a>3 后记</h2><p>折腾告一段落，静下心来好好写些文章吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上次发文还是三月初，中间停更了这么久，主要原因在于，之前我对主题源码进行了侵入式的改造，难以升级享受最新的版本特性，于是我就想要重建这个博客站点，兼顾可升级和可改造。&lt;/p&gt;
&lt;p&gt;那我就想，既然要重建，何不换个主题试一下？果然，试试就逝世。&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="折腾" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="博客" scheme="https://progcz.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="Hexo" scheme="https://progcz.com/tags/Hexo/"/>
    
    <category term="NexT" scheme="https://progcz.com/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>充满仪式感的「全年总结」和不太可能坚持下去的「新年计划」</title>
    <link href="https://progcz.com/posts/summary-for-past-year-and-plan-for-new-year/"/>
    <id>https://progcz.com/posts/summary-for-past-year-and-plan-for-new-year/</id>
    <published>2021-01-02T12:34:35.000Z</published>
    <updated>2021-01-02T12:34:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>即使新建好了文档，我依然不知道到底该写些什么，但是「写」这个念头就像只怎么也赶不走的乌鸦，一直在我的头顶盘旋。</p><p>也许确实是因为仪式感吧，<strong>每到了辞旧迎新的时候，总该有些「落在纸面」的文字，先跟过去的一年和解，再把自己交代给未来的一年。</strong></p><p>也罢，就让我这个记忆力和行动力都逐渐退化的人，来一场「全年总结」和「新年计划」吧！</p><img data-src="https://image.progcz.com/2021/01/01.jpg" style="zoom:100%"/><span id="more"></span><h2 id="1-全年总结"><a href="#1-全年总结" class="headerlink" title="1 全年总结"></a>1 全年总结</h2><h3 id="1-1-失去的五个月"><a href="#1-1-失去的五个月" class="headerlink" title="1.1 失去的五个月"></a>1.1 失去的五个月</h3><img data-src="https://image.progcz.com/2021/01/02.jpg" style="zoom:100%"/><p>但凡回顾 2020，疫情是怎么都绕不开的话题。</p><p>不论性别，不论国籍，不论贫穷或富有，不论疾病或健康，只要你还是这颗蓝色星球上的原住民，或多或少都会受到疫情的影响，唯一的区别就在于这个「或多或少」。</p><p>非常幸运，也非常惭愧，我是「或少」中的一员。</p><p>不管是磕磕绊绊但还是顺利完成了的学位答辩，还是在家只吃不动而逐渐狂妄的体重涨幅，在这场全人类都无法幸免的灾难面前，看上去都是小事。</p><p>因此，我始终对在疫情中离开人世的生命感到惋惜，他们一定也在 2020 年伊始时，怀揣着对新年的希望，如今归于尘土；我也始终对在疫情中奋战在一线的医护人员保持敬意，他们以血肉之躯，构筑起保护我们的钢铁长城。</p><div class="note warning"><p>写得越来越像高考作文了。</p><p>Whatever, it’s just the way how i was raised and educated.</p></div><p>不是超级英雄，<strong>只能保护好自己，照顾好家人，足够了。</strong></p><h3 id="1-2-十九年寒窗"><a href="#1-2-十九年寒窗" class="headerlink" title="1.2 十九年寒窗"></a>1.2 十九年寒窗</h3><img data-src="https://image.progcz.com/2021/01/03.jpg" style="zoom:100%"/><p>毕业算是改变人生的事情当中，意外指数最低的事情了吧。</p><p>在这种意义下，与其说是改变人生，<strong>不如说是人生早就被安排成了列车的时刻表，毕业这件事情就在单线轨道的某个站点上等着，没有丝毫悬念。</strong></p><p>虽然，我今年所面临的毕业，与以往的毕业不尽相同：</p><ul><li><p>以往的毕业，从学校到学校，换了环境而已，依然是衣食无忧的学生，终极目标不过是分数、绩点和排名。</p></li><li><p>今年的毕业，从学校到公司，真正意义上的经济独立，终极目标切换成房子、车子和存款。</p></li></ul><p>当然，还是很感谢曾经作为学生的自己，至少为我打好了阶级跃迁的基础，在人生这一新的阶段能多抢跑几秒钟。</p><h3 id="1-3-职场与人生"><a href="#1-3-职场与人生" class="headerlink" title="1.3 职场与人生"></a>1.3 职场与人生</h3><p>互联网大厂的程序员工作，一言以蔽之：节奏快，工作忙，身体累。</p><p>比起初入职场的感想，我更想探讨的是，在人生意义这个问题上的心态转变。</p><p>这是个老生常谈的哲学命题，我明白。但我还是想说说自己的理解。</p><p>过去的二十几年，从我记事开始，我就一直在为别人而活。</p><p>说起来非常简单的生活：作为学生，考试考个好成绩；作为儿女，听长辈的话。这样，父母就会很开心，长辈就会称赞我（不管是不是虚情假意），同学也会尊重我（即便是以对待书呆子的态度）。</p><p>我好像从来没想过，自己想要什么。</p><p>或者说，是周围的人告诉我的「我想要的」：努力学习，努力赚钱，有套自己的房子，有个幸福的家庭。</p><p>直到我开始问我自己：然后呢？这一切之后呢？从生到死，人这一生到底是为了什么呢？</p><p>过去的一年里，我反复地思考人生的意义，在上下班通勤的路上，在漫长而枯燥的旅途中，在每个放纵自己而熬到很困的深夜里。</p><p>而每次我都只能得到同一个答案：<strong>人生的意义是为了开心，为了愉悦的体验，为了舒适的生活。</strong></p><p>又是个老生常谈的答案，我明白。但这次，我是真的相信它了。</p><h2 id="2-新年计划"><a href="#2-新年计划" class="headerlink" title="2 新年计划"></a>2 新年计划</h2><h3 id="2-1-工作"><a href="#2-1-工作" class="headerlink" title="2.1 工作"></a>2.1 工作</h3><p>无他，努力工作，赚钱买房。</p><div class="note warning"><p>但是要牢记的是，身体是革命的本钱！任何事情的达成都不能以牺牲身体健康为前提。</p></div><h3 id="2-2-读书"><a href="#2-2-读书" class="headerlink" title="2.2 读书"></a>2.2 读书</h3><p>在将 kindle 上未读的书目消灭至只有个位数之前，不再囤书了。</p><p>至于数量，不想做硬性要求，只求在有大块时间和舒适状态的时候，能想起来读书，而不是刷手机/看视频。</p><h3 id="2-3-按摩-健身"><a href="#2-3-按摩-健身" class="headerlink" title="2.3 按摩/健身"></a>2.3 按摩/健身</h3><p>每周二按摩，每周四健身。</p><h3 id="2-4-旅游"><a href="#2-4-旅游" class="headerlink" title="2.4 旅游"></a>2.4 旅游</h3><p>希望每年能有一次旅游，实际上 2021 的额度已经分给厦门了，毕竟厦大百年校庆，是时候回去看看了。</p><img data-src="https://image.progcz.com/2021/01/04.jpg" style="zoom:100%"/><hr><h2 id="3-番外"><a href="#3-番外" class="headerlink" title="3 番外"></a>3 番外</h2><p>新年第一天，去撸了猫猫狗狗，希望能把这份开心延续一整年吧。</p><img data-src="https://image.progcz.com/2021/01/05.jpg" style="zoom:100%"/>]]></content>
    
    
    <summary type="html">&lt;p&gt;即使新建好了文档，我依然不知道到底该写些什么，但是「写」这个念头就像只怎么也赶不走的乌鸦，一直在我的头顶盘旋。&lt;/p&gt;
&lt;p&gt;也许确实是因为仪式感吧，&lt;strong&gt;每到了辞旧迎新的时候，总该有些「落在纸面」的文字，先跟过去的一年和解，再把自己交代给未来的一年。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也罢，就让我这个记忆力和行动力都逐渐退化的人，来一场「全年总结」和「新年计划」吧！&lt;/p&gt;
&lt;img data-src=&quot;https://image.progcz.com/2021/01/01.jpg&quot; style=&quot;zoom:100%&quot;/&gt;</summary>
    
    
    
    <category term="总结与计划" scheme="https://progcz.com/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E8%AE%A1%E5%88%92/"/>
    
    
    <category term="计划" scheme="https://progcz.com/tags/%E8%AE%A1%E5%88%92/"/>
    
    <category term="总结" scheme="https://progcz.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>我的工作桌面长啥样</title>
    <link href="https://progcz.com/posts/what-does-my-work-desktop-look-like/"/>
    <id>https://progcz.com/posts/what-does-my-work-desktop-look-like/</id>
    <published>2020-08-01T07:11:15.000Z</published>
    <updated>2021-05-31T00:57:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉，已经入职两个月了。</p><p>在这两个月里，我一直在适应工作节奏，所以没有时间更新博客（虽然也没什么人看）。</p><p>在这两个月里，我的工作桌面也在不断进化，不断适应我的使用习惯，到现在也算是个初级形态了，所以打算在这里梳理一下（其实就是想晒装备）。</p><p>先来张工作桌面的整体照片过过瘾：</p><img data-src="https://image.progcz.com/2020/08/00.png" style="zoom:100%"/><span id="more"></span><h2 id="1-「公司发的」MacBook-Pro-16"><a href="#1-「公司发的」MacBook-Pro-16" class="headerlink" title="1 「公司发的」MacBook Pro 16"></a>1 「公司发的」MacBook Pro 16</h2><img data-src="https://image.progcz.com/2020/08/01.png" style="zoom:100%"/><p>整个桌面都是围绕着 MacBook Pro 16 来布置的，具体配置：</p><table><thead><tr><th>条目</th><th>明细</th></tr></thead><tbody><tr><td>处理器</td><td>2.6 GHz 6‑core Intel Core i7</td></tr><tr><td>图形卡-1</td><td>AMD Radeon Pro 5300M 4 GB</td></tr><tr><td>图形卡-2</td><td>Intel UHD Graphics 630 1536 MB</td></tr><tr><td>内存</td><td>16 GB 2667 MHz DDR4</td></tr><tr><td>储存空间</td><td>512 GB SSD</td></tr></tbody></table><p>我已经过了那个对配置敏感的年纪，拿到这个电脑之后也只会感叹「好漂亮」和「好流畅」了。</p><p>在日常开发中，MacBook Pro 的性能确实绰绰有余，毕竟编译之类的苦差事都是在远程开发机上完成的，本地只是开开 Chrome 和 VS Code 而已。</p><p>P.S. 散热架也是公司发的，感觉薅了太多羊毛。</p><h2 id="2-「公司发的」Dell-U2720Q-4K-显示器"><a href="#2-「公司发的」Dell-U2720Q-4K-显示器" class="headerlink" title="2 「公司发的」Dell U2720Q 4K 显示器"></a>2 「公司发的」Dell U2720Q 4K 显示器</h2><img data-src="https://image.progcz.com/2020/08/02.png" style="zoom:100%"/><p>两台 4K 显示器的幸福，我以前无法想象，现在除了开会和回家以外，MacBook Pro 基本上都是合盖的状态，因为两个显示器已经够我看的了，多了怕鼠标都挪不过来。</p><p>另外一个让人感到幸福的细节，就是可以使用单根 Type-C 数据线合并「显示」、「充电」和「扩展」的功能，显示器的下行接口可以外接键盘和鼠标，极大地节约了 MacBook Pro 的接口数量。</p><p>但是我有两台显示器，为了达到显示的最佳效果，还是不可避免地占用了 MacBook Pro 的两个接口。</p><h2 id="3-「自己买的」DURGOD-TAURUS-K320-茶轴机械键盘"><a href="#3-「自己买的」DURGOD-TAURUS-K320-茶轴机械键盘" class="headerlink" title="3 「自己买的」DURGOD TAURUS K320 茶轴机械键盘"></a>3 「自己买的」DURGOD TAURUS K320 茶轴机械键盘</h2><img data-src="https://image.progcz.com/2020/08/03.png" style="zoom:100%"/><p>当时买这款机械键盘，主要是看中了 PBT 键帽，长期使用不打油的体验也是非常幸福。</p><h2 id="4-「自己买的」Logitech-MX-Master-2S-无线蓝牙鼠标"><a href="#4-「自己买的」Logitech-MX-Master-2S-无线蓝牙鼠标" class="headerlink" title="4 「自己买的」Logitech MX Master 2S 无线蓝牙鼠标"></a>4 「自己买的」Logitech MX Master 2S 无线蓝牙鼠标</h2><img data-src="https://image.progcz.com/2020/08/04.png" style="zoom:50%"/><p>不解释，办公神器。</p><h2 id="5-「自己买的」AirPods-2-无线蓝牙耳机"><a href="#5-「自己买的」AirPods-2-无线蓝牙耳机" class="headerlink" title="5 「自己买的」AirPods 2 无线蓝牙耳机"></a>5 「自己买的」AirPods 2 无线蓝牙耳机</h2><img data-src="https://image.progcz.com/2020/08/05.png" style="zoom:25%"/><p>MacBook Pro 的耳机孔在右侧，使用的有线耳机总是和使用鼠标的手发生干涉，所以我就入手了 AirPods，在一众无线蓝牙耳机中算是最省心的选择了，连接、音质和通话质量都足够稳定，别无他求。</p><h2 id="6-写在最后"><a href="#6-写在最后" class="headerlink" title="6 写在最后"></a>6 写在最后</h2><p>之前在 V2EX 看到一句话，与君共勉：</p><blockquote><p>入职以后，公司给每位员工发了一台电脑，表面上看是每个人拥有了一台电脑，其实是给每台电脑配了一个人。</p></blockquote><hr><h2 id="7-更新（2020-11-26）"><a href="#7-更新（2020-11-26）" class="headerlink" title="7 更新（2020-11-26）"></a>7 更新（2020-11-26）</h2><p>惯例，先放张工作桌面 2.0 的整体照片：</p><img data-src="https://image.progcz.com/2020/11/00.jpg" style="zoom:100%"/><p>改动：</p><ul><li><p>常年合盖使用的 MBP 被我挪到了左侧，这样键盘就可以向前推进，得到伸展的手臂感觉舒适了许多。</p></li><li><p>两个显示器都用包装盒架起了一定的高度，仰在椅子上的时候视线更加舒服了。</p></li><li><p>AirPods 2 =&gt; AirPods Pro，网吧工位少不了降噪。</p></li></ul><h2 id="8-更新（2021-05-31）"><a href="#8-更新（2021-05-31）" class="headerlink" title="8 更新（2021-05-31）"></a>8 更新（2021-05-31）</h2><p>可能是最终形态的工作桌面 3.0：</p><p><img data-src="https://image.progcz.com/2021/05/11.png"></p><p>改动：</p><ul><li><p>MBP 16 背着实在有点重，换成 MBP 13</p></li><li><p>双屏虽然爽，但是没啥用，所以归还其中一个显示器，只看正面的显示器</p></li><li><p>键盘从杜咖茶轴换成阿米洛红轴，键位与 Mac 自带键盘保持一致</p></li><li><p>常年用鼠标，右手手指关节十分痛苦，所以换成妙控板，左右手交替操作</p></li><li><p>手机换成 iPhone 12 mini，和 AirPods Pro 都可以无线充电，所以买了绿联的无线充电板，随用随充</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;不知不觉，已经入职两个月了。&lt;/p&gt;
&lt;p&gt;在这两个月里，我一直在适应工作节奏，所以没有时间更新博客（虽然也没什么人看）。&lt;/p&gt;
&lt;p&gt;在这两个月里，我的工作桌面也在不断进化，不断适应我的使用习惯，到现在也算是个初级形态了，所以打算在这里梳理一下（其实就是想晒装备）。&lt;/p&gt;
&lt;p&gt;先来张工作桌面的整体照片过过瘾：&lt;/p&gt;
&lt;img data-src=&quot;https://image.progcz.com/2020/08/00.png&quot; style=&quot;zoom:100%&quot;/&gt;</summary>
    
    
    
    <category term="生活" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="折腾" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="桌面" scheme="https://progcz.com/tags/%E6%A1%8C%E9%9D%A2/"/>
    
    <category term="MacBook Pro" scheme="https://progcz.com/tags/MacBook-Pro/"/>
    
    <category term="AirPods Pro" scheme="https://progcz.com/tags/AirPods-Pro/"/>
    
  </entry>
  
  <entry>
    <title>记录一次在上海租房的经历</title>
    <link href="https://progcz.com/posts/record-for-rent-in-shanghai/"/>
    <id>https://progcz.com/posts/record-for-rent-in-shanghai/</id>
    <published>2020-06-13T07:08:48.000Z</published>
    <updated>2020-06-13T07:08:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>入职之前，我预留了一周的时间用来租房，本以为做好了充足的准备，但还是碰到了很多「租房新手」必踩的坑。果然，<strong>小马还是要自己过一遍河才能知道河水的深浅。</strong></p><p>所以，趁着自己的记忆还够新鲜，记录一下这次在上海租房的经历，为以后的自己留下亿点经验和教训。</p><img data-src="https://image.progcz.com/2020/06/00.png" style="zoom:100%"/><span id="more"></span><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1 需求"></a>1 需求</h2><p>在租房之前，需要<strong>梳理一遍自己的需求，哪些是必不可少的，哪些是可以妥协的。</strong></p><p>当然，下面列出的这些需求仅适用于我个人，读者需要自行甄别。</p><h3 id="1-1-必不可少的"><a href="#1-1-必不可少的" class="headerlink" title="1.1 必不可少的"></a>1.1 必不可少的</h3><div class="note warning"><p>对于「必不可少的」需求，一旦确定之后，即便中介再怎么花言巧语，也不能有半点动摇。</p></div><ul><li><p><strong>距离公司的步行时间不超过 15 分钟，</strong>能够有效提升幸福感。</p></li><li><p><strong>房子不在一楼或顶楼，</strong>避免一楼的过于潮湿和顶楼的过冷过热。</p></li><li><p><strong>房间的装修时间至少在一年以上，</strong>避免存在甲醛和苯等污染问题。</p><p>我刚开始租的就是新装修了一个月的房间，年少无知的我觉得只要通风就好了，结果在房间里面待了几个小时之后，嗓子就开始不舒服。所以，我只租了几天，就直接与房东违约，押金自然要不回来了，肉疼但还是保命要紧。</p></li><li><p><strong>独立卫生间，不必与他人分享马桶和浴室，</strong>不管从时间还是空间的角度，都能够有效提升幸福感。</p><p>预算充足的话，可以考虑<strong>「整租」独立的一居室</strong>；预算有限的话，可以考虑<strong>「合租」带独卫的卧室</strong>。</p></li><li><p><strong>家具和家电：床、空调、衣柜、洗衣机、热水器。</strong></p></li></ul><h3 id="1-2-可以妥协的"><a href="#1-2-可以妥协的" class="headerlink" title="1.2 可以妥协的"></a>1.2 可以妥协的</h3><ul><li><p><strong>可以晾衣服的地方。</strong></p><p>预算充足的话，可以考虑<strong>朝南阳台</strong>；预算有限的话，可以考虑<strong>朝南外窗（带外置晾衣架）</strong>。</p><p>当然，朝北也是可以的，毕竟洗衣机甩干后的衣服只要再风干就可以了。</p></li><li><p><strong>厨房。</strong></p></li><li><p><strong>家具和家电：冰箱、电视、沙发。</strong></p></li></ul><h3 id="1-3-其他"><a href="#1-3-其他" class="headerlink" title="1.3 其他"></a>1.3 其他</h3><h4 id="1-3-1-关于二房东"><a href="#1-3-1-关于二房东" class="headerlink" title="1.3.1 关于二房东"></a>1.3.1 关于二房东</h4><p>我之前看过的很多租房攻略都有提到：千万不要租二房东的房子。</p><p>但是，其实有相当一部分的房源都来自<strong>「职业」二房东</strong>，这种二房东并不是真正的租客，而是因为原房东手中有闲置的房子而又怕麻烦，于是将房子出租给二房东，由二房东来管理出租的事情。真正应该避开的是<strong>「非职业」二房东</strong>，这种二房东是真正的租客，但是因为某些原因而不得已将其转租，在这种情况下就很难保障自己的租房权益。</p><p>所以，可以要求<strong>查看二房东的原租房合同和原房东的房产证。</strong>查看租房合同是否长达数年，就可以大致判断是否为「职业」二房东。而且，查看租房合同的开始日期，也可以大致判断房间的装修时间。</p><h4 id="1-3-2-关于隔断"><a href="#1-3-2-关于隔断" class="headerlink" title="1.3.2 关于隔断"></a>1.3.2 关于隔断</h4><p>预算有限的话，一般只能考虑隔断的房间了。但是，隔断属于违规建筑，其最大的风险在于<strong>房间可能随时会被政府强拆。</strong></p><p>所以，可以要求<strong>在租房合同中注明：如果房间因为违规建筑而导致乙方无法居住，那么不算乙方违约，甲方需退还押金和剩余租金。</strong></p><div class="note info"><p>问：如何判断隔断？</p><p>答：实地看房时敲一下四周的墙。如果声音很闷，就是原装的墙，如果声音很响，就是隔断的墙。</p></div><h2 id="2-找房"><a href="#2-找房" class="headerlink" title="2 找房"></a>2 找房</h2><h3 id="2-1-短租"><a href="#2-1-短租" class="headerlink" title="2.1 短租"></a>2.1 短租</h3><p>我没有短租过，但是个人感觉短租的话直接选择<strong>自如或蛋壳</strong>即可，省心省力且价格也没有高很多。</p><p>但是，自如或蛋壳被人诟病最多的就是污染问题，所以需要实地看房，感受一下房间内的空气质量。</p><h3 id="2-2-长租"><a href="#2-2-长租" class="headerlink" title="2.2 长租"></a>2.2 长租</h3><p>长租的话还是建议找当地的<strong>大中介</strong>，比如链家、我爱我家等。</p><h2 id="3-看房"><a href="#3-看房" class="headerlink" title="3 看房"></a>3 看房</h2><p>这一步主要是看房间是否满足需求，同时检查一下房间内设施的基本情况，包括但不仅限于：</p><ul><li><p>检查是否新装修，是否存在污染问题。</p></li><li><p>检查防盗门、窗户是否完好。</p></li><li><p>检查家具、家电是否老化。</p></li><li><p>检查水管是否通畅、电路是否老化。</p></li><li><p>检查卫生情况。</p></li></ul><h2 id="4-签订合同"><a href="#4-签订合同" class="headerlink" title="4 签订合同"></a>4 签订合同</h2><p>大中介的合同一般没有什么问题，只是需要注意以下几点：</p><ul><li><p><strong>明确费用明细，</strong>包括但不仅限于：押金、房租、中介费、服务费、物业费、水电费、煤气费、宽带费、维修费等。</p></li><li><p><strong>明确房东和房客的违约条款。</strong></p></li><li><p><strong>拍照或录像记录房间内设施的基本情况，</strong>避免后续的维修纠纷。</p></li><li><p><strong>（独居女生尤其注意）与房东沟通是否可以换锁。</strong></p></li><li><p><strong>与房东当面签订合同，拍照留存房东的身份证、房产证，如果是二房东，拍照留存二房东的原租房合同和原房东的身份证、房产证。</strong></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;入职之前，我预留了一周的时间用来租房，本以为做好了充足的准备，但还是碰到了很多「租房新手」必踩的坑。果然，&lt;strong&gt;小马还是要自己过一遍河才能知道河水的深浅。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，趁着自己的记忆还够新鲜，记录一下这次在上海租房的经历，为以后的自己留下亿点经验和教训。&lt;/p&gt;
&lt;img data-src=&quot;https://image.progcz.com/2020/06/00.png&quot; style=&quot;zoom:100%&quot;/&gt;</summary>
    
    
    
    <category term="生活" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="经历" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="上海" scheme="https://progcz.com/tags/%E4%B8%8A%E6%B5%B7/"/>
    
    <category term="租房" scheme="https://progcz.com/tags/%E7%A7%9F%E6%88%BF/"/>
    
  </entry>
  
  <entry>
    <title>记录使用 IFTTT + Telegram 订阅 RSS 的推送模板</title>
    <link href="https://progcz.com/posts/record-use-ifttt-tg-sub-rss-push-template/"/>
    <id>https://progcz.com/posts/record-use-ifttt-tg-sub-rss-push-template/</id>
    <published>2020-05-24T10:30:11.000Z</published>
    <updated>2020-05-24T10:30:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于大部分使用 RSS 的人来说，RSS 最大的优势便是能够提供<strong>「聚合阅读」</strong>的功能，也就是在一个地方阅读多篇不同来源的文章，而且可以自主选择订阅源，拒绝推荐引擎的「投喂」。然而对于我来说，RSS 还有一个重要的作用在于能够提供<strong>「即时通知」</strong>的功能，也就是<strong>「一旦发生了什么，请立刻通知我」</strong>。</p><p>所以，为了实现<strong>「即时通知」</strong>的功能，<strong>可以使用 IFTTT 将 RSS 订阅内容推送至 Telegram 的对话、群组或公开频道，形成属于自己的「信息流」。</strong></p><img data-src="https://image.progcz.com/2020/05/10.png" style="zoom:100%"/><span id="more"></span><h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0 写在前面"></a>0 写在前面</h2><p>本文不介绍具体教程，只记录其中使用的推送模板，留作以后参考。</p><p><strong>如果你想了解具体教程，推荐参考<a href="https://sword.studio/157.html">这篇文章</a>。</strong></p><p>另外，<strong>如果你也使用 <a href="https://docs.rsshub.app/">RSSHub</a>，推荐参考<a href="https://docs.rsshub.app/install/#bu-shu-dao-vercel-zeit-now">官方文档</a>将其部署至 <a href="https://vercel.com/">Vercel</a>，</strong>从而搭建属于自己的订阅引擎。</p><h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1 应用场景"></a>1 应用场景</h2><p>在 Telegram 中，我创建了两个公开频道，分别是：</p><ul><li><p><strong><a href="https://t.me/ProgCZChannel">ProgCZ’s Blog - Channel</a> 用于同步本博客更新的文章。</strong></p></li><li><p><strong><a href="https://t.me/ProgCZFlow">ProgCZ’s Flow</a> 用于建立专属于自己的信息流。</strong></p></li></ul><h2 id="2-推送模板"><a href="#2-推送模板" class="headerlink" title="2 推送模板"></a>2 推送模板</h2><p>在 IFTTT 中，需要设置推送模板，分为两种情况：</p><ul><li><p><strong>对于内容较多的订阅源（比如博客文章），只是推送其标题、链接和来源，</strong>模板如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标题：&lt;b&gt;&#123;&#123;EntryTitle&#125;&#125;&lt;&#x2F;b&gt;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">链接：&lt;b&gt;&#123;&#123;EntryUrl&#125;&#125;&lt;&#x2F;b&gt;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">来自：&lt;a href&#x3D;&quot;&#123;&#123;FeedUrl&#125;&#125;&quot;&gt;&#123;&#123;FeedTitle&#125;&#125;&lt;&#x2F;a&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure><p>同时，<strong>开启「网页预览」功能。</strong></p></li><li><p><strong>对于内容较少的订阅源（比如购物优惠），推送其标题、内容、链接和来源，</strong>模板如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标题：&lt;b&gt;&#123;&#123;EntryTitle&#125;&#125;&lt;&#x2F;b&gt;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&#123;&#123;EntryContent&#125;&#125;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">链接：&lt;b&gt;&#123;&#123;EntryUrl&#125;&#125;&lt;&#x2F;b&gt;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">来自：&lt;a href&#x3D;&quot;&#123;&#123;FeedUrl&#125;&#125;&quot;&gt;&#123;&#123;FeedTitle&#125;&#125;&lt;&#x2F;a&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure><p>同时，<strong>关闭「网页预览」功能。</strong></p></li></ul><h2 id="3-预览效果"><a href="#3-预览效果" class="headerlink" title="3 预览效果"></a>3 预览效果</h2><p>如果你想预览效果，可以在科学环境中访问 <a href="https://t.me/s/ProgCZChannel">ProgCZ’s Blog - Channel</a> 和 <a href="https://t.me/s/ProgCZFlow">ProgCZ’s Flow</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于大部分使用 RSS 的人来说，RSS 最大的优势便是能够提供&lt;strong&gt;「聚合阅读」&lt;/strong&gt;的功能，也就是在一个地方阅读多篇不同来源的文章，而且可以自主选择订阅源，拒绝推荐引擎的「投喂」。然而对于我来说，RSS 还有一个重要的作用在于能够提供&lt;strong&gt;「即时通知」&lt;/strong&gt;的功能，也就是&lt;strong&gt;「一旦发生了什么，请立刻通知我」&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以，为了实现&lt;strong&gt;「即时通知」&lt;/strong&gt;的功能，&lt;strong&gt;可以使用 IFTTT 将 RSS 订阅内容推送至 Telegram 的对话、群组或公开频道，形成属于自己的「信息流」。&lt;/strong&gt;&lt;/p&gt;
&lt;img data-src=&quot;https://image.progcz.com/2020/05/10.png&quot; style=&quot;zoom:100%&quot;/&gt;</summary>
    
    
    
    <category term="生活" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="折腾" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="IFTTT" scheme="https://progcz.com/tags/IFTTT/"/>
    
    <category term="Telegram" scheme="https://progcz.com/tags/Telegram/"/>
    
    <category term="RSS" scheme="https://progcz.com/tags/RSS/"/>
    
  </entry>
  
  <entry>
    <title>使用 Cloudflare Workers 搭建 Google 和 GitHub 镜像网站</title>
    <link href="https://progcz.com/posts/use-cf-workers-build-google-and-github-mirrors/"/>
    <id>https://progcz.com/posts/use-cf-workers-build-google-and-github-mirrors/</id>
    <published>2020-05-23T13:32:58.000Z</published>
    <updated>2020-05-23T13:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于 Google 来说，虽然大部分时间都能够在科学环境中网上冲浪，但是<strong>难免有需要在普通环境中使用 Google 的情况，</strong>而对于 GitHub 来说，虽然目前可以无障碍访问，但是<strong>在普通环境中下载某些 Release（比如科学工具的客户端）的速度实在太慢。</strong></p><p>如果你也有和我一样的困扰，那么可以考虑<strong>使用 Cloudflare Workers 搭建属于自己的镜像网站，</strong>在普通环境中备用。</p><span id="more"></span><h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0 写在前面"></a>0 写在前面</h2><p>如果你只是在寻找临时的解决方案，而又不想费劲的话，那么可以直接使用我已经搭建好的镜像网站。</p><div class="note warning"><p>但是，请你务必遵守以下约定：</p><ol><li><p><strong>不滥用服务。</strong>因为每个 Cloudflare 账户每天只有 100,000 次请求的额度。</p></li><li><p><strong>不登录自己的任何账号。</strong>虽然我保证不拦截你的数据，但是防人之心不可无。</p></li><li><p><strong>不违反大陆的法律法规。</strong>虽然你需要科学，但是请保持理性。</p></li></ol></div><ul><li><p>Google 镜像网站：<a href="https://google.progcz.workers.dev/">https://google.progcz.workers.dev/</a></p></li><li><p>GitHub 镜像网站：<a href="https://github.progcz.workers.dev/">https://github.progcz.workers.dev/</a></p></li></ul><h2 id="1-注册并登录-Cloudflare-账号"><a href="#1-注册并登录-Cloudflare-账号" class="headerlink" title="1 注册并登录 Cloudflare 账号"></a>1 注册并登录 Cloudflare 账号</h2><p>这没啥好说的，前往 <a href="https://www.cloudflare.com/">Cloudflare 官网</a>自行注册并登录，然后<strong>点击「Workers」。</strong></p><img data-src="https://image.progcz.com/2020/05/06.png" style="zoom:100%"/><h2 id="2-创建新的-Worker-应用"><a href="#2-创建新的-Worker-应用" class="headerlink" title="2 创建新的 Worker 应用"></a>2 创建新的 Worker 应用</h2><p>进入 Workers 页面之后，新用户需要设置用户名（比如 <code>progcz</code>），然后<strong>点击「创建 Worker」。</strong></p><img data-src="https://image.progcz.com/2020/05/07.png" style="zoom:100%"/><h2 id="3-部署-Worker-应用"><a href="#3-部署-Worker-应用" class="headerlink" title="3 部署 Worker 应用"></a>3 部署 Worker 应用</h2><p><strong>自行修改应用名（比如 <code>test</code>），将 <a href="https://github.com/ProgCZ/code-cloud-a/blob/master/2020/05/cf-workers-mirrors/index.js">index.js</a> 中的代码拷贝至脚本中，点击「保存并部署」，</strong>然后就可以通过 <a href="https://test.progcz.workers.dev/">https://test.progcz.workers.dev/</a>（注意替换应用名 <code>test</code> 和用户名 <code>progcz</code>）访问 Google 的镜像网站了。</p><img data-src="https://image.progcz.com/2020/05/08.png" style="zoom:100%"/><h2 id="4-自定义-index-js-脚本"><a href="#4-自定义-index-js-脚本" class="headerlink" title="4 自定义 index.js 脚本"></a>4 自定义 index.js 脚本</h2><div class="note info"><p>上文的 <a href="https://github.com/ProgCZ/code-cloud-a/blob/master/2020/05/cf-workers-mirrors/index.js">index.js</a> 其实来自于 <a href="https://github.com/Berkeley-Reject/Workers-Proxy">Berkeley-Reject/Workers-Proxy</a> 仓库，但是代码中设置了对于国内访问的屏蔽，所以为了避免误用，我就在自行修改之后保存了一份。</p></div><p>可以通过修改以下部分来搭建不同的镜像网站：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Website you intended to retrieve for users.</span></span><br><span class="line"><span class="keyword">const</span> upstream = <span class="string">&#x27;www.google.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Custom pathname for the upstream website.</span></span><br><span class="line"><span class="keyword">const</span> upstream_path = <span class="string">&#x27;/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Website you intended to retrieve for users using mobile devices.</span></span><br><span class="line"><span class="keyword">const</span> upstream_mobile = <span class="string">&#x27;www.google.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Countries and regions where you wish to suspend your service.</span></span><br><span class="line"><span class="keyword">const</span> blocked_region = [<span class="string">&#x27;KP&#x27;</span>, <span class="string">&#x27;SY&#x27;</span>, <span class="string">&#x27;PK&#x27;</span>, <span class="string">&#x27;CU&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// IP addresses which you wish to block from using your service.</span></span><br><span class="line"><span class="keyword">const</span> blocked_ip_address = [<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Whether to use HTTPS protocol for upstream address.</span></span><br><span class="line"><span class="keyword">const</span> https = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Whether to disable cache.</span></span><br><span class="line"><span class="keyword">const</span> disable_cache = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace texts.</span></span><br><span class="line"><span class="keyword">const</span> replace_dict = &#123;</span><br><span class="line">    <span class="string">&#x27;$upstream&#x27;</span>: <span class="string">&#x27;$custom_domain&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;//google.com&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p>需要注意的是，上述代码只是 <a href="https://github.com/ProgCZ/code-cloud-a/blob/master/2020/05/cf-workers-mirrors/index.js">index.js</a> 的一小部分。</p></div><p>比如，对于 GitHub 来说，我们只需要<strong>将 <code>upstream</code>、<code>upstream_mobile</code> 和 <code>replace_dict</code> 中的 <code>google.com</code> 修改为 <code>github.com</code> 即可。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于 Google 来说，虽然大部分时间都能够在科学环境中网上冲浪，但是&lt;strong&gt;难免有需要在普通环境中使用 Google 的情况，&lt;/strong&gt;而对于 GitHub 来说，虽然目前可以无障碍访问，但是&lt;strong&gt;在普通环境中下载某些 Release（比如科学工具的客户端）的速度实在太慢。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你也有和我一样的困扰，那么可以考虑&lt;strong&gt;使用 Cloudflare Workers 搭建属于自己的镜像网站，&lt;/strong&gt;在普通环境中备用。&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="折腾" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="GitHub" scheme="https://progcz.com/tags/GitHub/"/>
    
    <category term="Cloudflare" scheme="https://progcz.com/tags/Cloudflare/"/>
    
    <category term="Google" scheme="https://progcz.com/tags/Google/"/>
    
    <category term="Mirror" scheme="https://progcz.com/tags/Mirror/"/>
    
  </entry>
  
  <entry>
    <title>记录一次「卖」微信公众号的经历</title>
    <link href="https://progcz.com/posts/record-for-sell-wechat-official-account/"/>
    <id>https://progcz.com/posts/record-for-sell-wechat-official-account/</id>
    <published>2020-05-14T08:44:03.000Z</published>
    <updated>2020-05-14T08:44:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>因为腾讯在两年前关闭了新注册微信公众号的「留言」功能，所以新注册微信公众号必须通过一些特殊方法才能拥有「留言」功能，「账号迁移」便是其中之一。</strong></p><p>刚好，我有一个闲置已久的微信公众号，于是联系到经办人将自己的微信公众号「卖」了出去。<strong>两个工作日</strong>的时间就把整个流程走完了，大部分手续都是经办人的事情，需要我来配合的地方并不多。</p><img data-src="https://image.progcz.com/2020/05/03.png" style="zoom:100%"/><span id="more"></span><h2 id="0-事情起因"><a href="#0-事情起因" class="headerlink" title="0 事情起因"></a>0 事情起因</h2><p>几天前，在逛 V2EX 的时候，看到一个<a href="https://www.v2ex.com/t/668420">帖子</a>，里面讲到：</p><blockquote><p>做公众号，特别是近期注册的都想要留言功能。但是 2018 年 3 月 12 日之后注册的微信公众号默认没有留言功能。</p><p>新号想要留言功能，基本上就一条路花几千找人做迁移有留言功能的老号才行。</p></blockquote><p>巧合的是，在此之前的几天，我想起自己有个闲置已久的微信公众号，当时觉得没什么用了，于是申请了账号注销，七天后再次确认即可彻底注销。看到这个帖子之后，我立马终止了注销流程，开始琢磨怎么把它卖掉。</p><h2 id="1-迁移过程"><a href="#1-迁移过程" class="headerlink" title="1 迁移过程"></a>1 迁移过程</h2><p>简单搜索之后，我了解到腾讯关闭了新注册微信公众号的「留言」功能，想要开通的话需要一些特殊方法，具体可以参考<a href="https://zhuanlan.zhihu.com/p/63996356">微信公众号留言开通最全攻略</a>。</p><p>同时，我联系到一个专业的经办人，可以帮忙「卖」掉带有「留言」功能的微信公众号。</p><div class="note info"><p>接下来，从我的角度来描述一下大概的流程：</p><ol><li><p>第一天，经办人登录我的微信公众号，确认微信公众号的基本信息及违规记录。</p></li><li><p>随后，经办人要求我提供身份证正反面的照片，照片需要带有「公众号迁移」字样的水印。<strong>提供照片之后，经办人付给了我一半的费用。</strong></p></li><li><p>三个小时后，经办人要求我进行电子公证，此处需要进行人脸识别。</p></li><li><p>第二天，经办人再次登录我的微信公众号。</p></li><li><p>随后，经办人要求我扫码对「账号迁移」进行确认，此时微信需要对迁移申请进行审核。</p></li><li><p>四个小时后，微信对迁移申请的审核通过，经办人要求再次对「账号迁移」进行确认。<strong>最终确认之后，经办人付给了我另外一半的费用。</strong></p></li></ol></div><p>以上就是我需要做的事情，总体来说不算麻烦，何乐而不为。</p><h2 id="2-推广"><a href="#2-推广" class="headerlink" title="2 推广"></a>2 推广</h2><img data-src="https://image.progcz.com/2020/05/04.png" style="zoom:100%"/><p><strong>如果你也有一个在 2018 年 03 月 12 日之前注册而又闲置的微信公众号，可以通过「下方的评论区」或「<a href="/about/">关于</a>页面的其他联系方式」联系到我，</strong>我可以把这个比较靠谱的经办人推荐给你。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;因为腾讯在两年前关闭了新注册微信公众号的「留言」功能，所以新注册微信公众号必须通过一些特殊方法才能拥有「留言」功能，「账号迁移」便是其中之一。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;刚好，我有一个闲置已久的微信公众号，于是联系到经办人将自己的微信公众号「卖」了出去。&lt;strong&gt;两个工作日&lt;/strong&gt;的时间就把整个流程走完了，大部分手续都是经办人的事情，需要我来配合的地方并不多。&lt;/p&gt;
&lt;img data-src=&quot;https://image.progcz.com/2020/05/03.png&quot; style=&quot;zoom:100%&quot;/&gt;</summary>
    
    
    
    <category term="生活" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="经历" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="微信公众号" scheme="https://progcz.com/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
    <category term="推广" scheme="https://progcz.com/tags/%E6%8E%A8%E5%B9%BF/"/>
    
  </entry>
  
  <entry>
    <title>Linux 系统中 socket 编程的入门必知</title>
    <link href="https://progcz.com/posts/basics-about-socket-in-linux/"/>
    <id>https://progcz.com/posts/basics-about-socket-in-linux/</id>
    <published>2020-04-27T07:01:49.000Z</published>
    <updated>2020-04-27T07:01:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机通信领域，socket 被译为「套接字」，是计算机之间进行通信的一种约定，本文介绍 socket 编程的入门必知，可以作为基础手册进行查阅。</p><span id="more"></span><h2 id="1-socket-编程基础"><a href="#1-socket-编程基础" class="headerlink" title="1 socket 编程基础"></a>1 socket 编程基础</h2><h3 id="1-1-socket-的不同类型"><a href="#1-1-socket-的不同类型" class="headerlink" title="1.1 socket 的不同类型"></a>1.1 socket 的不同类型</h3><ul><li><p><code>SOCK_STREAM</code>：流格式套接字，使用 TCP 协议进行数据传输。</p></li><li><p><code>SOCK_DGRAM</code>：数据报格式套接字，使用 UDP 协议进行数据传输。</p></li></ul><h3 id="1-2-socket-的不同函数"><a href="#1-2-socket-的不同函数" class="headerlink" title="1.2 socket 的不同函数"></a>1.2 socket 的不同函数</h3><h4 id="1-2-1-socket"><a href="#1-2-1-socket" class="headerlink" title="1.2.1 socket()"></a>1.2.1 <code>socket()</code></h4><p>用于创建套接字，确定套接字的各项属性：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>af</code> 为地址族，也就是IP地址类型，常用的有 <code>AF_INET</code> 和 <code>AF_INET6</code>，前者表示 IPv4 地址，后者表示 IPv6 地址。</p></li><li><p><code>type</code> 为数据传输方式，也就是套接字类型，常用的有 <code>SOCK_STREAM</code> 和 <code>SOCK_DGRAM</code>。</p></li><li><p><code>protocol</code> 为传输协议，常用的有 <code>IPPROTO_TCP</code> 和 <code>IPPTOTO_UDP</code>，前者表示 TCP 传输协议，后者表示 UDP 传输协议。</p></li></ul><h4 id="1-2-2-bind-和-connect"><a href="#1-2-2-bind-和-connect" class="headerlink" title="1.2.2 bind() 和 connect()"></a>1.2.2 <code>bind()</code> 和 <code>connect()</code></h4><p>服务端使用 <code>bind()</code> 将套接字和特定的 IP 地址、端口绑定起来：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sock, struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>客户端使用 <code>connect()</code> 将套接字和特定的 IP 地址、端口绑定起来：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sock, struct sockaddr *serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>sock</code> 为套接字文件描述符。</p></li><li><p><code>addr</code> 为 <code>sockaddr</code> 结构体变量的指针。</p></li><li><p><code>addrlen</code> 为 <code>addr</code> 变量的大小，可以由 <code>sizeof()</code> 计算得到。</p></li></ul><h4 id="1-2-3-listen-和-accept"><a href="#1-2-3-listen-和-accept" class="headerlink" title="1.2.3 listen() 和 accept()"></a>1.2.3 <code>listen()</code> 和 <code>accept()</code></h4><p>服务端使用 <code>listen()</code> 使套接字进入被动监听状态：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sock, inr backlog)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>sock</code> 为需要进入监听状态的套接字文件描述符。</p></li><li><p><code>backlog</code> 为请求队列的最大长度。其中，请求队列也就是请求的接收缓冲区，可以设置为 <code>SOMAXCONN</code>，由系统决定请求队列长度。当请求队列已满时，不再接收新的请求，客户端会收到 <code>ECONNREFUSED</code> 错误。</p></li></ul><p>之后调用 <code>accept()</code> 函数，使进程处于阻塞状态，直到接收到客户端的请求：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sock, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>accept()</code> 返回一个新的套接字用于和客户端通信。</p><h4 id="1-2-4-write-和-read"><a href="#1-2-4-write-和-read" class="headerlink" title="1.2.4 write() 和 read()"></a>1.2.4 <code>write()</code> 和 <code>read()</code></h4><p>服务端使用 <code>write()</code> 向套接字写入数据，传送给客户端：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>fd</code> 为需要写入的文件描述符，此处即套接字文件描述符。</p></li><li><p><code>buf</code> 为需要写入的数据的缓冲区地址。</p></li><li><p><code>nbytes</code> 为需要写入的数据的字节数。</p></li></ul><p>需要注意的是，写入成功则返回写入的字节数，失败则返回 <code>-1</code>。</p><p>客户端使用 <code>read()</code> 从套接字读入数据：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure><p>需要注意的是，读取成功则返回读取的字节数（在文件结尾返回 <code>0</code>），失败则返回 <code>-1</code>。</p><h2 id="2-socket-编程样例"><a href="#2-socket-编程样例" class="headerlink" title="2 socket 编程样例"></a>2 socket 编程样例</h2><h3 id="2-1-服务端代码-server-cpp"><a href="#2-1-服务端代码-server-cpp" class="headerlink" title="2.1 服务端代码 server.cpp"></a>2.1 服务端代码 <code>server.cpp</code></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> serv_sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将套接字与 IP、端口绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">    <span class="built_in">bind</span>(serv_sock, (struct sockaddr*)&amp;serv_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入监听状态，等待用户发起请求</span></span><br><span class="line">    <span class="built_in">listen</span>(serv_sock, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端请求</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_addr_size = <span class="built_in"><span class="keyword">sizeof</span></span>(clnt_addr);</span><br><span class="line">    <span class="keyword">int</span> clnt_sock = <span class="built_in">accept</span>(serv_sock, (struct sockaddr*)&amp;clnt_addr, &amp;clnt_addr_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向客户端发送数据</span></span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(clnt_sock, str, <span class="built_in"><span class="keyword">sizeof</span></span>(str));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-客户端代码-client-cpp"><a href="#2-2-客户端代码-client-cpp" class="headerlink" title="2.2 客户端代码 client.cpp"></a>2.2 客户端代码 <code>client.cpp</code></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向服务端发送请求</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">    <span class="built_in">connect</span>(sock, (struct sockaddr*)&amp;serv_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取服务端传回的数据</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">40</span>];</span><br><span class="line">    <span class="built_in">read</span>(sock, buffer, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer)<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Massage: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在计算机通信领域，socket 被译为「套接字」，是计算机之间进行通信的一种约定，本文介绍 socket 编程的入门必知，可以作为基础手册进行查阅。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://progcz.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="开发基础" scheme="https://progcz.com/categories/%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Linux" scheme="https://progcz.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用 GitHub Actions 实现 Hexo 博客的自动部署</title>
    <link href="https://progcz.com/posts/apply-github-actions-to-deploy-hexo-blog/"/>
    <id>https://progcz.com/posts/apply-github-actions-to-deploy-hexo-blog/</id>
    <published>2020-04-27T05:09:33.000Z</published>
    <updated>2020-04-27T05:09:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub Actions 是 GitHub 推出的持续集成服务，可以用于自动执行「代码测试」、「项目部署」等重复劳动，自然也可以用于 Hexo 等静态博客的生成、部署过程，从而不依赖于本地环境，便于迁移。</p><span id="more"></span><p>GitHub Actions 官方介绍：<a href="https://github.com/features/actions">https://github.com/features/actions</a></p><p>GitHub Actions 入门教程：<a href="https://p3terx.com/archives/github-actions-started-tutorial.html">https://p3terx.com/archives/github-actions-started-tutorial.html</a></p><h2 id="1-分支设计"><a href="#1-分支设计" class="headerlink" title="1 分支设计"></a>1 分支设计</h2><p><a href="https://github.com/ProgCZ/blog-cloud">ProgCZ/blog-cloud</a> 包含两个分支：</p><ul><li><p><code>master</code> 分支：用于存放<strong>解析后的静态文件</strong>，也就是托管于 GitHub Pages 的静态网页，无需在本地保存。</p></li><li><p><code>source</code> 分支：用于存放<strong>解析前的源文件</strong>，需要与本地同步。</p></li></ul><p>也就是说，我们希望达成的效果如下：<strong>在本地撰写文章后，将其手动提交至 <code>source</code> 分支，从而触发 GitHub Actions 生成静态文件，将其自动部署至 <code>master</code> 分支。</strong></p><h2 id="2-工作流设计"><a href="#2-工作流设计" class="headerlink" title="2 工作流设计"></a>2 工作流设计</h2><h3 id="2-1-详细描述"><a href="#2-1-详细描述" class="headerlink" title="2.1 详细描述"></a>2.1 详细描述</h3><ol><li><p><strong>工作流由 <code>source</code> 分支的 <code>push</code> 操作触发。</strong></p> <div class="note warning"><p>之前我把工作流文件放在 <code>master</code> 分支下，希望通过</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">source</span></span><br></pre></td></tr></table></figure><p>来触发工作流，但是一直没能成功，所以这里建议将工作流文件放在 <code>source</code> 分支下。</p></div></li><li><p><strong>配置工作流环境（与本地保持一致）：系统为 Ubuntu 16.04，Node.js 版本为 12.x。</strong></p></li><li><p><strong>下拉 <code>source</code> 分支至 <code>blog-source-ws</code> 文件夹中。</strong></p></li><li><p><strong>安装 <code>hexo-cli</code> 工具，版本为 3.1.0（与本地保持一致）。</strong></p></li><li><p><strong>安装插件，依赖文件为 <code>blog-source-ws/package.json</code>。</strong></p> <div class="note warning"><p>为了使插件保持稳定，我把所有版本号前的 <code>^</code> 全部删除，因为 <code>^</code> 表示将插件更新到当前 major version（也就是第一位数字）中的最新版本。</p><p>完整依赖文件如下所示：</p><figure class="highlight json"><figcaption><span>code</span><a href="https://github.com/ProgCZ/blog-cloud/blob/source/package.json">package.json</a></figcaption><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;hexo-site&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;private&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;hexo generate&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;clean&quot;</span>: <span class="string">&quot;hexo clean&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;deploy&quot;</span>: <span class="string">&quot;hexo deploy&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;server&quot;</span>: <span class="string">&quot;hexo server&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hexo&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;4.2.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hexo&quot;</span>: <span class="string">&quot;4.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-generator-archive&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-generator-category&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-generator-index&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-generator-feed&quot;</span>: <span class="string">&quot;2.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-generator-sitemap&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-generator-searchdb&quot;</span>: <span class="string">&quot;1.3.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-generator-tag&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-html-minifier&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-renderer-ejs&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-renderer-stylus&quot;</span>: <span class="string">&quot;1.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-renderer-marked&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-server&quot;</span>: <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细心的读者可能看到，除了默认插件以外，我额外添加了四个插件，分别是：</p><ul><li><p><code>hexo-generator-feed</code> 用于生成 RSS 文件。</p></li><li><p><code>hexo-generator-sitemap</code> 用于生成站点地图文件，提交给 Google 之后可以提高网页收录效率。</p></li><li><p><code>hexo-generator-searchdb</code> 用于生成搜索文件。</p></li><li><p><code>hexo-html-minifier</code> 用于压缩 html 文件（删除大量空白和换行），可以加快网页加载速度。</p></li></ul></div></li><li><p><strong>下拉 <code>master</code> 分支至 <code>blog-source-ws/pubic</code> 文件夹中。</strong></p></li><li><p><strong>配置时区和用户信息后，通过</strong></p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -a | egrep -v <span class="string">&#x27;^\.&#123;1,2&#125;$&#x27;</span> | egrep -v .git | xargs rm -rf</span><br></pre></td></tr></table></figure><p> <strong>清空 <code>blog-source-ws/pubic</code> 文件夹（相当于 <code>hexo clean</code>），再通过</strong></p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p> <strong>在 <code>blog-source-ws/pubic</code> 文件夹中生成静态文件，再通过</strong></p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add -A</span><br><span class="line">$ git commit -m <span class="string">&quot;Update blog: `date &#x27;+%Y-%m-%d %H:%M:%S&#x27;`&quot;</span></span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p> <strong>将静态文件手动提交至 <code>master</code> 分支。</strong></p></li></ol><h3 id="2-2-完整代码"><a href="#2-2-完整代码" class="headerlink" title="2.2 完整代码"></a>2.2 完整代码</h3><figure class="highlight yaml"><figcaption><span>code</span><a href="https://github.com/ProgCZ/blog-cloud/blob/source/.github/workflows/auto-hexo.yml">auto-hexo.yml</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Auto</span> <span class="string">Hexo</span></span><br><span class="line"><span class="attr">on:</span> <span class="string">push</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">Worker:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-16.04</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&#x27;12.x&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">ref:</span> <span class="string">source</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&#x27;blog-source-ws&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Hexo</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli@3.1.0</span></span><br><span class="line">        <span class="string">cd</span> <span class="string">blog-source-ws</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">ref:</span> <span class="string">master</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&#x27;blog-source-ws/public&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Regenerate</span> <span class="string">and</span> <span class="string">Deploy</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">export</span> <span class="string">TZ=&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">        <span class="string">cd</span> <span class="string">blog-source-ws/public</span></span><br><span class="line">        <span class="string">ls</span> <span class="string">-a</span> <span class="string">|</span> <span class="string">egrep</span> <span class="string">-v</span> <span class="string">&#x27;^\.&#123;1,2&#125;$&#x27;</span> <span class="string">|</span> <span class="string">egrep</span> <span class="string">-v</span> <span class="string">.git</span> <span class="string">|</span> <span class="string">xargs</span> <span class="string">rm</span> <span class="string">-rf</span></span><br><span class="line">        <span class="string">cd</span> <span class="string">..</span></span><br><span class="line">        <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line">        <span class="string">cd</span> <span class="string">public</span></span><br><span class="line">        <span class="string">git</span> <span class="string">config</span> <span class="string">--local</span> <span class="string">user.name</span> <span class="string">&quot;NAME&quot;</span></span><br><span class="line">        <span class="string">git</span> <span class="string">config</span> <span class="string">--local</span> <span class="string">user.email</span> <span class="string">&quot;NAME@EXAMPLE.COM&quot;</span></span><br><span class="line">        <span class="string">git</span> <span class="string">add</span> <span class="string">-A</span></span><br><span class="line">        <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">&quot;Update blog: `date &#x27;+%Y-%m-%d %H:%M:%S&#x27;`&quot;</span></span><br><span class="line">        <span class="string">git</span> <span class="string">push</span> <span class="string">origin</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>需要注意以下几点：</p><ul><li><p><strong><code>ls -a | egrep -v &#39;^\.&#123;1,2&#125;$&#39; | egrep -v .git | xargs rm -rf</code> 相当于 <code>hexo clean</code>，</strong>但是该命令只是删除 <code>blog-source-ws/public</code> 文件夹内除了以 <code>.git</code> 为前缀的文件或文件夹以外的所有文件或文件夹，而 <code>hexo clean</code> 直接删除 <code>blog-source-ws/public</code> 文件夹。</p></li><li><p>两个分支属于同一仓库，<strong>使用 <code>actions/checkout</code>（相当于 <code>git pull</code>）之后可以直接 <code>git push</code>，</strong>而不需要配置其他教程（比如<a href="https://mystryl.com/2019/10/github-actions/">这篇文章</a>）中出现的秘钥。</p></li></ul><h2 id="3-自动部署效果"><a href="#3-自动部署效果" class="headerlink" title="3 自动部署效果"></a>3 自动部署效果</h2><p>可以在<a href="https://github.com/ProgCZ/blog-cloud/actions?query=branch:source">这里</a>看到，部署时间大概在 40 秒左右，随着文章数量不断增多，部署时间也会不断增加，但是总不可能超过 6 小时的限制（GitHub Actions 的使用限制可以在<a href="https://help.github.com/en/actions/getting-started-with-github-actions/about-github-actions#usage-limits">这里</a>查看）。</p><p>只要 GitHub 没有警告版本过期，上述方案就可以一直使用下去，即使 GitHub 警告版本过期，也可以尝试更改版本号，一般都会向下兼容，所以目测支撑个四五年应该没有问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;GitHub Actions 是 GitHub 推出的持续集成服务，可以用于自动执行「代码测试」、「项目部署」等重复劳动，自然也可以用于 Hexo 等静态博客的生成、部署过程，从而不依赖于本地环境，便于迁移。&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="折腾" scheme="https://progcz.com/categories/%E7%94%9F%E6%B4%BB/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="博客" scheme="https://progcz.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="GitHub" scheme="https://progcz.com/tags/GitHub/"/>
    
    <category term="教程" scheme="https://progcz.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="GitHub Actions" scheme="https://progcz.com/tags/GitHub-Actions/"/>
    
    <category term="Hexo" scheme="https://progcz.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>CMake 教程：从零开始编写 CMakeLists.txt</title>
    <link href="https://progcz.com/posts/cmake-tutorial-write-cmakelists-txt-from-the-very-beginning/"/>
    <id>https://progcz.com/posts/cmake-tutorial-write-cmakelists-txt-from-the-very-beginning/</id>
    <published>2020-03-17T02:24:00.000Z</published>
    <updated>2020-03-17T02:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>CMake 是跨平台的开源工具，可以用于编译、测试和打包软件，本文从零开始编写一个比较基础的 <code>CMakeLists.txt</code>，记录其特有的语法。</p><span id="more"></span><p>CMake 官网：<a href="https://cmake.org/">https://cmake.org/</a></p><p>CMake 源码地址（镜像）：<a href="https://github.com/Kitware/CMake">https://github.com/Kitware/CMake</a></p><p>CMake 英文教程（最新版本）：<a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">https://cmake.org/cmake/help/latest/guide/tutorial/index.html</a></p><p>CMake 文档搜索（最新版本）：<a href="https://cmake.org/cmake/help/latest/search.html">https://cmake.org/cmake/help/latest/search.html</a></p><div class="note warning"><p>本文使用 Ubuntu 当前版本为 <code>16.04</code>，使用 CMake 当前版本为 <code>3.17.20200315-ga6d95f5</code>，<code>CMakeLists.txt</code> 设置 CMake 最低版本为 <code>3.5</code>。因而，命令和语法可能与读者所用版本有所不同，望周知。</p></div><h2 id="0-教程源码"><a href="#0-教程源码" class="headerlink" title="0 教程源码"></a>0 教程源码</h2><p>GitHub 地址：<a href="https://github.com/ProgCZ/code-cloud-a/tree/master/2020/03/cmake-tutorial">https://github.com/ProgCZ/code-cloud-a/tree/master/2020/03/cmake-tutorial</a></p><p>读者可以下载整个仓库，进入指定目录查看源码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --depth=1 https://github.com/ProgCZ/code-cloud-a.git</span><br><span class="line">$ <span class="built_in">cd</span> code-cloud-a/2020/03/cmake-tutorial</span><br></pre></td></tr></table></figure><h2 id="1-创建基础模板"><a href="#1-创建基础模板" class="headerlink" title="1 创建基础模板"></a>1 创建基础模板</h2><p><strong>根目录中的 <code>CMakeLists.txt</code> 文件一览：</strong></p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the project name and version</span></span><br><span class="line"><span class="keyword">project</span>(Tutorial VERSION <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify the C++ standard</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># configure a header file to pass some of the CMake settings</span></span><br><span class="line"><span class="comment"># to the source code</span></span><br><span class="line"><span class="keyword">configure_file</span>(TutorialConfig.h.in TutorialConfig.h)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the binary tree to the search path for include files</span></span><br><span class="line"><span class="comment"># so that we will find TutorialConfig.h</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(Tutorial PUBLIC</span><br><span class="line">                           <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="1-1-设置-CMake-最低版本"><a href="#1-1-设置-CMake-最低版本" class="headerlink" title="1.1 设置 CMake 最低版本"></a>1.1 设置 CMake 最低版本</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION &lt;min&gt;[...&lt;max&gt;] [FATAL_ERROR])</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://cmake.org/cmake/help/latest/command/cmake_minimum_required.html">https://cmake.org/cmake/help/latest/command/cmake_minimum_required.html</a></p></blockquote><h3 id="1-2-设置项目名称和版本"><a href="#1-2-设置项目名称和版本" class="headerlink" title="1.2 设置项目名称和版本"></a>1.2 设置项目名称和版本</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">project</span>(&lt;<span class="keyword">PROJECT</span>-NAME&gt; [&lt;language-name&gt;...])</span><br><span class="line"><span class="keyword">project</span>(&lt;<span class="keyword">PROJECT</span>-NAME&gt;</span><br><span class="line">        [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]</span><br><span class="line">        [DESCRIPTION &lt;<span class="keyword">project</span>-description-<span class="keyword">string</span>&gt;]</span><br><span class="line">        [HOMEPAGE_URL &lt;url-<span class="keyword">string</span>&gt;]</span><br><span class="line">        [LANGUAGES &lt;language-name&gt;...])</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">project</span>(Tutorial VERSION <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure><ul><li><p>上述指令设置变量：</p><ul><li><p><code>PROJECT_NAME</code></p></li><li><p><code>PROJECT_SOURCE_DIR</code> 和 <code>&lt;PROJECT-NAME&gt;_SOURCE_DIR</code></p></li><li><p><code>PROJECT_BINARY_DIR</code> 和 <code>&lt;PROJECT-NAME&gt;_BINARY_DIR</code></p></li></ul></li><li><p>选项 <code>VERSION</code> 设置变量：</p><ul><li><p><code>PROJECT_VERSION</code> 和 <code>&lt;PROJECT-NAME&gt;_VERSION</code></p></li><li><p><code>PROJECT_VERSION_MAJOR</code> 和 <code>&lt;PROJECT-NAME&gt;_VERSION_MAJOR</code></p></li><li><p><code>PROJECT_VERSION_MINOR</code> 和 <code>&lt;PROJECT-NAME&gt;_VERSION_MINOR</code></p></li><li><p><code>PROJECT_VERSION_PATCH</code> 和 <code>&lt;PROJECT-NAME&gt;_VERSION_PATCH</code></p></li><li><p><code>PROJECT_VERSION_TWEAK</code> 和 <code>&lt;PROJECT-NAME&gt;_VERSION_TWEAK</code></p></li></ul></li></ul><blockquote><p>参考：<a href="https://cmake.org/cmake/help/latest/command/project.html">https://cmake.org/cmake/help/latest/command/project.html</a></p></blockquote><h3 id="1-3-设置-C-标准"><a href="#1-3-设置-C-标准" class="headerlink" title="1.3 设置 C++ 标准"></a>1.3 设置 C++ 标准</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><h3 id="1-4-传递-CMake-变量"><a href="#1-4-传递-CMake-变量" class="headerlink" title="1.4 传递 CMake 变量"></a>1.4 传递 CMake 变量</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">configure_file</span>(&lt;input&gt; &lt;output&gt;</span><br><span class="line">               [COPYONLY] [ESCAPE_QUOTES] [@ONLY]</span><br><span class="line">               [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ])</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">configure_file</span>(TutorialConfig.h.in TutorialConfig.h)</span><br></pre></td></tr></table></figure><p>可以将头文件模板 <code>TutorialConfig.h.in</code>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TutorialConfig.h.in</span></span><br><span class="line"><span class="comment">// the configured options and settings for Tutorial</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@</span></span><br></pre></td></tr></table></figure><p>在预处理阶段改写为头文件 <code>TutorialConfig.h</code>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TutorialConfig.h</span></span><br><span class="line"><span class="comment">// the configured options and settings for Tutorial</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tutorial_VERSION_MAJOR 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tutorial_VERSION_MINOR 0</span></span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://cmake.org/cmake/help/latest/command/configure_file.html">https://cmake.org/cmake/help/latest/command/configure_file.html</a></p></blockquote><h3 id="1-5-添加可执行文件"><a href="#1-5-添加可执行文件" class="headerlink" title="1.5 添加可执行文件"></a>1.5 添加可执行文件</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">add_executable</span>(&lt;name&gt; [WIN32] [MACOSX_BUNDLE]</span><br><span class="line">               [EXCLUDE_FROM_ALL]</span><br><span class="line">               [source1] [source2 ...])</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial main.cpp)</span><br></pre></td></tr></table></figure><p>上述指令从源代码 <code>main.cpp</code>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TutorialConfig.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; Version: &quot;</span></span><br><span class="line">            &lt;&lt; Tutorial_VERSION_MAJOR &lt;&lt; <span class="string">&quot;.&quot;</span></span><br><span class="line">            &lt;&lt; Tutorial_VERSION_MINOR &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>]</span><br><span class="line">            &lt;&lt; <span class="string">&quot; number&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> inputValue = std::<span class="built_in">stod</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> outputValue = <span class="built_in">sqrt</span>(inputValue);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The square root of &quot;</span> &lt;&lt; inputValue</span><br><span class="line">        &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; outputValue &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译产生可执行文件 <code>Tutorial</code>。</p><blockquote><p>参考：<a href="https://cmake.org/cmake/help/latest/command/add_executable.html">https://cmake.org/cmake/help/latest/command/add_executable.html</a></p></blockquote><h3 id="1-6-添加-include-目录"><a href="#1-6-添加-include-目录" class="headerlink" title="1.6 添加 include 目录"></a>1.6 添加 <code>include</code> 目录</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(&lt;<span class="keyword">target</span>&gt; [SYSTEM] [BEFORE]</span><br><span class="line">    &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">    [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(Tutorial PUBLIC</span><br><span class="line">                           <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>上述指令添加 <code>include</code> 目录，使编译器能够找到头文件 <code>TutorialConfig.h</code>。</p><blockquote><p>参考：<a href="https://cmake.org/cmake/help/latest/command/target_include_directories.html">https://cmake.org/cmake/help/latest/command/target_include_directories.html</a></p></blockquote><h3 id="1-7-编译项目"><a href="#1-7-编译项目" class="headerlink" title="1.7 编译项目"></a>1.7 编译项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">$ cmake .. &amp;&amp; cmake --build .</span><br><span class="line">-- The C compiler identification is GNU 5.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 5.4.0</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc - works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - <span class="keyword">done</span></span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++ - works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - <span class="keyword">done</span></span><br><span class="line">-- Configuring <span class="keyword">done</span></span><br><span class="line">-- Generating <span class="keyword">done</span></span><br><span class="line">-- Build files have been written to: /home/peter/Projects/test_cmake_ws/build</span><br><span class="line">Scanning dependencies of target Tutorial</span><br><span class="line">[ 50%] Building CXX object CMakeFiles/Tutorial.dir/main.cpp.o</span><br><span class="line">[100%] Linking CXX executable Tutorial</span><br><span class="line">[100%] Built target Tutorial</span><br></pre></td></tr></table></figure><h3 id="1-8-运行项目"><a href="#1-8-运行项目" class="headerlink" title="1.8 运行项目"></a>1.8 运行项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./Tutorial 10</span><br><span class="line">The square root of 10 is 3.16228</span><br><span class="line">$ ./Tutorial</span><br><span class="line">./Tutorial Version: 1.0</span><br><span class="line">Usage: ./Tutorial number</span><br></pre></td></tr></table></figure><h2 id="2-加入自定义库"><a href="#2-加入自定义库" class="headerlink" title="2 加入自定义库"></a>2 加入自定义库</h2><p>某些情况下，需要添加一个自定义库，比如 <code>MathFunctions</code> 库：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── main.cpp</span><br><span class="line">├── MathFunctions</span><br><span class="line">│   ├── MathFunctions.h</span><br><span class="line">│   └── mysqrt.cpp</span><br></pre></td></tr></table></figure><hr><p><strong><code>MathFunctions</code> 目录中的 <code>CMakeLists.txt</code> 文件一览：</strong></p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(MathFunctions mysqrt.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># state that anybody linking to us needs to include the current source dir</span></span><br><span class="line"><span class="comment"># to find MathFunctions.h, while we don&#x27;t.</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(MathFunctions</span><br><span class="line">    INTERFACE <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-1-为库的用户添加库"><a href="#2-1-为库的用户添加库" class="headerlink" title="2.1 为库的用户添加库"></a>2.1 为库的用户添加库</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">add_library</span>(&lt;name&gt; [STATIC | SHARED | MODULE]</span><br><span class="line">            [EXCLUDE_FROM_ALL]</span><br><span class="line">            [source1] [source2 ...])</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">add_library</span>(MathFunctions mysqrt.cpp)</span><br></pre></td></tr></table></figure><p>参考：<a href="https://cmake.org/cmake/help/latest/command/add_library.html">https://cmake.org/cmake/help/latest/command/add_library.html</a></p><h3 id="2-2-为库的用户添加-include-目录"><a href="#2-2-为库的用户添加-include-目录" class="headerlink" title="2.2 为库的用户添加 include 目录"></a>2.2 为库的用户添加 <code>include</code> 目录</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(MathFunctions</span><br><span class="line">    INTERFACE <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure><p>上述指令<strong>为库的用户</strong>添加 <code>include</code> 目录，使编译器能够找到头文件 <code>MathFunctions.h</code>。</p><hr><p><strong>根目录中的<code>CMakeLists.txt</code> 文件一览：</strong></p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the project name and version</span></span><br><span class="line"><span class="keyword">project</span>(Tutorial VERSION <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify the C++ standard</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># should we use our own math functions</span></span><br><span class="line"><span class="keyword">option</span>(USE_MYMATH <span class="string">&quot;Use tutorial provided math implementation&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># configure a header file to pass some of the CMake settings</span></span><br><span class="line"><span class="comment"># to the source code</span></span><br><span class="line"><span class="keyword">configure_file</span>(TutorialConfig.h.in TutorialConfig.h)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the MathFunctions library</span></span><br><span class="line"><span class="keyword">if</span>(USE_MYMATH)</span><br><span class="line">    <span class="keyword">add_subdirectory</span>(MathFunctions)</span><br><span class="line">    <span class="keyword">list</span>(APPEND EXTRA_LIBS MathFunctions)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Tutorial PUBLIC <span class="variable">$&#123;EXTRA_LIBS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the binary tree to the search path for include files</span></span><br><span class="line"><span class="comment"># so that we will find TutorialConfig.h</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(Tutorial PUBLIC</span><br><span class="line">                           <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-3-传递-USE-MYMATH-选项"><a href="#2-3-传递-USE-MYMATH-选项" class="headerlink" title="2.3 传递 USE_MYMATH 选项"></a>2.3 传递 <code>USE_MYMATH</code> 选项</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">option</span>(&lt;variable&gt; <span class="string">&quot;&lt;help_text&gt;&quot;</span> [value])</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">option</span>(USE_MYMATH <span class="string">&quot;Use tutorial provided math implementation&quot;</span> <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><p>修改头文件模板 <code>TutorialConfig.h.in</code>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the configured options and settings for Tutorial</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@</span></span><br><span class="line"><span class="meta">#cmakedefine USE_MYMATH</span></span><br></pre></td></tr></table></figure><p>根据 <code>USE_MYMATH</code> 选项判断使用哪个函数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MathFunctions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">double</span> outputValue = <span class="built_in">mysqrt</span>(inputValue);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">double</span> outputValue = <span class="built_in">sqrt</span>(inputValue);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The square root of &quot;</span> &lt;&lt; inputValue</span><br><span class="line">        &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; outputValue &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-添加-MathFunctions-目录"><a href="#2-4-添加-MathFunctions-目录" class="headerlink" title="2.4 添加 MathFunctions 目录"></a>2.4 添加 <code>MathFunctions</code> 目录</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(MathFunctions)</span><br></pre></td></tr></table></figure><p>参考：<a href="https://cmake.org/cmake/help/latest/command/add_subdirectory.html">https://cmake.org/cmake/help/latest/command/add_subdirectory.html</a></p><h3 id="2-5-添加链接库"><a href="#2-5-添加链接库" class="headerlink" title="2.5 添加链接库"></a>2.5 添加链接库</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">list</span>(APPEND &lt;<span class="keyword">list</span>&gt; [&lt;element&gt;...])</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">list</span>(APPEND EXTRA_LIBS MathFunctions)</span><br></pre></td></tr></table></figure><p>参考：<a href="https://cmake.org/cmake/help/latest/command/list.html">https://cmake.org/cmake/help/latest/command/list.html</a></p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(&lt;<span class="keyword">target</span>&gt;</span><br><span class="line">                      &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...</span><br><span class="line">                      [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Tutorial PUBLIC <span class="variable">$&#123;EXTRA_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure><p>参考：<a href="https://cmake.org/cmake/help/latest/command/target_link_libraries.html">https://cmake.org/cmake/help/latest/command/target_link_libraries.html</a></p><h3 id="2-6-编译项目"><a href="#2-6-编译项目" class="headerlink" title="2.6 编译项目"></a>2.6 编译项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake -DUSE_MYMATH=ON .. &amp;&amp; cmake --build .</span><br><span class="line">$ cmake -DUSE_MYMATH=OFF .. &amp;&amp; cmake --build .</span><br></pre></td></tr></table></figure><h2 id="3-安装和测试"><a href="#3-安装和测试" class="headerlink" title="3 安装和测试"></a>3 安装和测试</h2><h3 id="3-1-设置安装目录"><a href="#3-1-设置安装目录" class="headerlink" title="3.1 设置安装目录"></a>3.1 设置安装目录</h3><p><strong>在 <code>MathFunctions</code> 目录中的 <code>CMakeLists.txt</code> 文件最后添加：</strong></p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS MathFunctions DESTINATION lib)</span><br><span class="line"><span class="keyword">install</span>(FILES MathFunctions.h DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><p><strong>在根目录中的 <code>CMakeLists.txt</code> 文件最后添加：</strong></p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS Tutorial DESTINATION bin)</span><br><span class="line"><span class="keyword">install</span>(FILES <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/TutorialConfig.h&quot;</span></span><br><span class="line">    DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><h3 id="3-2-安装项目"><a href="#3-2-安装项目" class="headerlink" title="3.2 安装项目"></a>3.2 安装项目</h3><p>CMake 的 <code>3.15</code> 以下版本只能使用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><p>CMake 的 <code>3.15</code> 及以上版本可以使用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ sudo cmake --install .</span><br></pre></td></tr></table></figure><p>上述指令默认将项目安装在 <code>/usr/local/</code> 路径下，可以指定安装路径：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo cmake --install . --prefix /tmp/</span><br></pre></td></tr></table></figure><p>安装之后就可以直接调用 <code>Tutorial</code>，而不是 <code>./Tutorial</code>。</p><h3 id="3-3-设置测试样例"><a href="#3-3-设置测试样例" class="headerlink" title="3.3 设置测试样例"></a>3.3 设置测试样例</h3><p><strong>在根目录中的 <code>CMakeLists.txt</code> 文件最后添加：</strong></p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># does the application run</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME Runs <span class="keyword">COMMAND</span> Tutorial <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># does the usage message work?</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME Usage <span class="keyword">COMMAND</span> Tutorial)</span><br><span class="line"><span class="keyword">set_tests_properties</span>(Usage</span><br><span class="line">    PROPERTIES PASS_REGULAR_EXPRESSION <span class="string">&quot;Usage:.*number&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># define a function to simplify adding tests</span></span><br><span class="line"><span class="keyword">function</span>(do_test <span class="keyword">target</span> arg result)</span><br><span class="line">    <span class="keyword">add_test</span>(NAME Comp<span class="variable">$&#123;arg&#125;</span> <span class="keyword">COMMAND</span> <span class="variable">$&#123;target&#125;</span> <span class="variable">$&#123;arg&#125;</span>)</span><br><span class="line">    <span class="keyword">set_tests_properties</span>(Comp<span class="variable">$&#123;arg&#125;</span></span><br><span class="line">        PROPERTIES PASS_REGULAR_EXPRESSION <span class="variable">$&#123;result&#125;</span>)</span><br><span class="line"><span class="keyword">endfunction</span>(do_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># do a bunch of result based tests</span></span><br><span class="line">do_test(Tutorial <span class="number">5</span> <span class="string">&quot;5 is 2.236&quot;</span>)</span><br><span class="line">do_test(Tutorial -<span class="number">25</span> <span class="string">&quot;-25 is [-nan|nan|0]&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="3-3-1-简单测试"><a href="#3-3-1-简单测试" class="headerlink" title="3.3.1 简单测试"></a>3.3.1 简单测试</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME &lt;name&gt; <span class="keyword">COMMAND</span> &lt;<span class="keyword">command</span>&gt; [&lt;arg&gt;...]</span><br><span class="line">         [CONFIGURATIONS &lt;config&gt;...]</span><br><span class="line">         [WORKING_DIRECTORY &lt;dir&gt;]</span><br><span class="line">         [COMMAND_EXPAND_LISTS])</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME Runs <span class="keyword">COMMAND</span> Tutorial <span class="number">25</span>)</span><br></pre></td></tr></table></figure><p>上述指令简单测试项目是否能够运行，通过则表示未报错、未崩溃、返回 <code>0</code>。</p><blockquote><p>参考：<a href="https://cmake.org/cmake/help/latest/command/add_test.html">https://cmake.org/cmake/help/latest/command/add_test.html</a></p></blockquote><h4 id="3-3-2-对比测试"><a href="#3-3-2-对比测试" class="headerlink" title="3.3.2 对比测试"></a>3.3.2 对比测试</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME &lt;name&gt; <span class="keyword">COMMAND</span> &lt;<span class="keyword">command</span>&gt; [&lt;arg&gt;...]</span><br><span class="line">         [CONFIGURATIONS &lt;config&gt;...]</span><br><span class="line">         [WORKING_DIRECTORY &lt;dir&gt;]</span><br><span class="line">         [COMMAND_EXPAND_LISTS])</span><br><span class="line"><span class="keyword">set_tests_properties</span>(test1 [test2...] PROPERTIES prop1 value1 prop2 value2)</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME Usage <span class="keyword">COMMAND</span> Tutorial)</span><br><span class="line"><span class="keyword">set_tests_properties</span>(Usage</span><br><span class="line">    PROPERTIES PASS_REGULAR_EXPRESSION <span class="string">&quot;Usage:.*number&quot;</span>)</span><br></pre></td></tr></table></figure><p>上述指令对比测试项目的输出与正则表达式是否匹配，可以将其封装为函数：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">function</span>(do_test <span class="keyword">target</span> arg result)</span><br><span class="line">    <span class="keyword">add_test</span>(NAME Comp<span class="variable">$&#123;arg&#125;</span> <span class="keyword">COMMAND</span> <span class="variable">$&#123;target&#125;</span> <span class="variable">$&#123;arg&#125;</span>)</span><br><span class="line">    <span class="keyword">set_tests_properties</span>(Comp<span class="variable">$&#123;arg&#125;</span></span><br><span class="line">        PROPERTIES PASS_REGULAR_EXPRESSION <span class="variable">$&#123;result&#125;</span>)</span><br><span class="line"><span class="keyword">endfunction</span>(do_test)</span><br></pre></td></tr></table></figure><h3 id="3-4-测试项目"><a href="#3-4-测试项目" class="headerlink" title="3.4 测试项目"></a>3.4 测试项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ ctest -VV</span><br><span class="line">UpdateCTestConfiguration  from :/home/peter/Projects/test_cmake_ws/build/DartConfiguration.tcl</span><br><span class="line">UpdateCTestConfiguration  from :/home/peter/Projects/test_cmake_ws/build/DartConfiguration.tcl</span><br><span class="line">Test project /home/peter/Projects/test_cmake_ws/build</span><br><span class="line">Constructing a list of tests</span><br><span class="line">Done constructing a list of tests</span><br><span class="line">Updating <span class="built_in">test</span> list <span class="keyword">for</span> fixtures</span><br><span class="line">Added 0 tests to meet fixture requirements</span><br><span class="line">Checking <span class="built_in">test</span> dependency graph...</span><br><span class="line">Checking <span class="built_in">test</span> dependency graph end</span><br><span class="line"><span class="built_in">test</span> 1</span><br><span class="line">    Start 1: Runs</span><br><span class="line"></span><br><span class="line">1: Test <span class="built_in">command</span>: /home/peter/Projects/test_cmake_ws/build/Tutorial <span class="string">&quot;25&quot;</span></span><br><span class="line">1: Test timeout computed to be: 10000000</span><br><span class="line">1: The square root of 25 is 5</span><br><span class="line">1/4 Test <span class="comment">#1: Runs .............................   Passed    0.03 sec</span></span><br><span class="line"><span class="built_in">test</span> 2</span><br><span class="line">    Start 2: Usage</span><br><span class="line"></span><br><span class="line">2: Test <span class="built_in">command</span>: /home/peter/Projects/test_cmake_ws/build/Tutorial</span><br><span class="line">2: Test timeout computed to be: 10000000</span><br><span class="line">2: /home/peter/Projects/test_cmake_ws/build/Tutorial Version: 1.0</span><br><span class="line">2: Usage: /home/peter/Projects/test_cmake_ws/build/Tutorial number</span><br><span class="line">2/4 Test <span class="comment">#2: Usage ............................   Passed    0.00 sec</span></span><br><span class="line"><span class="built_in">test</span> 3</span><br><span class="line">    Start 3: Comp5</span><br><span class="line"></span><br><span class="line">3: Test <span class="built_in">command</span>: /home/peter/Projects/test_cmake_ws/build/Tutorial <span class="string">&quot;5&quot;</span></span><br><span class="line">3: Test timeout computed to be: 10000000</span><br><span class="line">3: The square root of 5 is 2.23607</span><br><span class="line">3/4 Test <span class="comment">#3: Comp5 ............................   Passed    0.00 sec</span></span><br><span class="line"><span class="built_in">test</span> 4</span><br><span class="line">    Start 4: Comp-25</span><br><span class="line"></span><br><span class="line">4: Test <span class="built_in">command</span>: /home/peter/Projects/test_cmake_ws/build/Tutorial <span class="string">&quot;-25&quot;</span></span><br><span class="line">4: Test timeout computed to be: 10000000</span><br><span class="line">4: The square root of -25 is -nan</span><br><span class="line">4/4 Test <span class="comment">#4: Comp-25 ..........................   Passed    0.01 sec</span></span><br><span class="line"></span><br><span class="line">100% tests passed, 0 tests failed out of 4</span><br><span class="line"></span><br><span class="line">Total Test time (real) =   0.12 sec</span><br></pre></td></tr></table></figure><h2 id="4-写在最后"><a href="#4-写在最后" class="headerlink" title="4 写在最后"></a>4 写在最后</h2><p>未来一段时间可能会找一些优秀的 C++ 项目源码来阅读，学习编码技巧的同时也能进一步了解如何编写项目的 <code>CMakeLists.txt</code>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;CMake 是跨平台的开源工具，可以用于编译、测试和打包软件，本文从零开始编写一个比较基础的 &lt;code&gt;CMakeLists.txt&lt;/code&gt;，记录其特有的语法。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://progcz.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="编程语言" scheme="https://progcz.com/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="CPP" scheme="https://progcz.com/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CPP/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Linux" scheme="https://progcz.com/tags/Linux/"/>
    
    <category term="教程" scheme="https://progcz.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="CMake" scheme="https://progcz.com/tags/CMake/"/>
    
    <category term="CMakeLists.txt" scheme="https://progcz.com/tags/CMakeLists-txt/"/>
    
  </entry>
  
</feed>
