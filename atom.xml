<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ProgCZ&#39;s Blog</title>
  
  
  <link href="https://progcz.com/atom.xml" rel="self"/>
  
  <link href="https://progcz.com/"/>
  <updated>2021-08-09T01:18:18.000Z</updated>
  <id>https://progcz.com/</id>
  
  <author>
    <name>ProgCZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2021 August LeetCoding Challenge - Week 2</title>
    <link href="https://progcz.com/posts/1628470617/"/>
    <id>https://progcz.com/posts/1628470617/</id>
    <published>2021-08-09T00:57:37.000Z</published>
    <updated>2021-08-09T01:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 八月挑战专题，第二周，每日随缘更新。</p><span id="more"></span><h2 id="August-8th-Rank-Transform-of-a-Matrix"><a href="#August-8th-Rank-Transform-of-a-Matrix" class="headerlink" title="August 8th: Rank Transform of a Matrix"></a>August 8th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/614/week-2-august-8th-august-14th/3874/">Rank Transform of a Matrix</a></h2><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定 <code>m*n</code> 的矩阵 <code>matrix</code>，返回矩阵中每个元素的 <code>rank</code>。</p><p>其中，<code>rank</code> 遵循以下规则：</p><ul><li><p><code>rank</code> 从 <code>1</code> 开始。</p></li><li><p>对于在同一行或同一列的 <code>p</code> 和 <code>q</code>，</p><ul><li><p>如果 <code>p &lt; q</code>，那么 <code>rank(p) &lt; rank(q)</code>。</p></li><li><p>如果 <code>p == q</code>，那么 <code>rank(p) == rank(q)</code>。</p></li><li><p>如果 <code>p &gt; q</code>，那么 <code>rank(p) &gt; rank(q)</code>。</p></li></ul></li><li><p><code>rank</code> 应该尽可能地小。</p></li></ul><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><blockquote><p>参考：<a href="https://leetcode.com/problems/rank-transform-of-a-matrix/discuss/1391380/C%2B%2BPython-HashMap-and-Sort-and-UnionFind-Visualize-picture-Clean-and-Concise">[C++/Python] HashMap &amp; Sort &amp; UnionFind - Visualize picture - Clean &amp; Concise</a></p></blockquote><p>首先，找到同一数字的所有位置。</p><p>其次，在某个数字的所有位置中，找到在同一行和同一列的位置，以是否为同一 <code>rank</code> 聚合起来。</p><p>最后，找到同一行和同一列中目前的最大值，<code>+1</code> 即可。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(M*N*log(M*N))</code></p></li><li><p>时间：<code>O(M*N)</code></p></li></ul><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == parent[u]) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">return</span> parent[u] = <span class="built_in">Find</span>(parent[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent.<span class="built_in">count</span>(u) == <span class="number">0</span>) parent[u] = u;</span><br><span class="line">        <span class="keyword">if</span> (parent.<span class="built_in">count</span>(v) == <span class="number">0</span>) parent[v] = v;</span><br><span class="line">        <span class="keyword">int</span> pu = <span class="built_in">Find</span>(u), pv = <span class="built_in">Find</span>(v);</span><br><span class="line">        <span class="keyword">if</span> (pu != pv) parent[pu] = pv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">matrixRankTransform</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        map&lt;<span class="keyword">int</span>, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; groupByValue;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; ++r)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c)</span><br><span class="line">                groupByValue[matrix[r][c]].<span class="built_in">push_back</span>(&#123;r, c&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rank</span><span class="params">(m+n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; [_, cells]  : groupByValue) &#123;</span><br><span class="line">            UnionFind uf;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; [r, c] : cells)</span><br><span class="line">                uf.<span class="built_in">Union</span>(r, c + m);</span><br><span class="line"></span><br><span class="line">            unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; groups;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; [u, _] : uf.parent) &#123;</span><br><span class="line">                groups[uf.<span class="built_in">Find</span>(u)].<span class="built_in">push_back</span>(u);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; [_, group] : groups) &#123;</span><br><span class="line">                <span class="keyword">int</span> maxRank = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i : group) maxRank = <span class="built_in">max</span>(maxRank, rank[i]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i : group) rank[i] = maxRank + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; [r, c] : cells) matrix[r][c] = rank[r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 八月挑战专题，第二周，每日随缘更新。&lt;/p&gt;</summary>
    
    
    
    <category term="A3 - LeetCode" scheme="https://progcz.com/categories/A3-LeetCode/"/>
    
    <category term="B4 - LeetCoding Challenge" scheme="https://progcz.com/categories/A3-LeetCode/B4-LeetCoding-Challenge/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Problem 7 - Reverse Integer</title>
    <link href="https://progcz.com/posts/1627951198/"/>
    <id>https://progcz.com/posts/1627951198/</id>
    <published>2021-08-03T00:40:37.000Z</published>
    <updated>2021-08-03T00:49:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/reverse-integer/">https://leetcode.com/problems/reverse-integer/</a></p><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定 32 位整数 <code>x</code>，返回反转后的数字，如果存在溢出，则返回 <code>0</code>。</p><span id="more"></span><h2 id="解法一：模运算"><a href="#解法一：模运算" class="headerlink" title="解法一：模运算"></a>解法一：模运算</h2><p>通过模运算来反转 <code>x</code> 即可。</p><p>需要注意的是，判断反转后的数字 <code>res</code> 是否会溢出，这个判断不能在每次模运算之后（因为如果溢出，此时已经溢出），而应该在每次模运算之前，判断 <code>res</code> 是否超出了 <code>INT_MAX/10</code>。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(1)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(res) &gt; INT_MAX/<span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-integer/&quot;&gt;https://leetcode.com/problems/reverse-integer/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h3&gt;&lt;p&gt;给定 32 位整数 &lt;code&gt;x&lt;/code&gt;，返回反转后的数字，如果存在溢出，则返回 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="A3 - LeetCode" scheme="https://progcz.com/categories/A3-LeetCode/"/>
    
    <category term="B1 - LeetCode Problems" scheme="https://progcz.com/categories/A3-LeetCode/B1-LeetCode-Problems/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Math" scheme="https://progcz.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Problem 5 - Longest Palindromic Substring</title>
    <link href="https://progcz.com/posts/1627949478/"/>
    <id>https://progcz.com/posts/1627949478/</id>
    <published>2021-08-03T00:12:10.000Z</published>
    <updated>2021-08-03T00:27:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/longest-palindromic-substring/">https://leetcode.com/problems/longest-palindromic-substring/</a></p><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定字符串 <code>s</code>，返回其中的最长回文子串。</p><span id="more"></span><h2 id="解法一：遍历扩散"><a href="#解法一：遍历扩散" class="headerlink" title="解法一：遍历扩散"></a>解法一：遍历扩散</h2><p>遍历字符串 <code>s</code>，从每个字符的位置 <code>i</code> 向外扩散，寻找最长回文子串。</p><p>需要注意的是，回文子串的长度有奇偶之分，因此：对于奇数长度，从 <code>i</code> 扩散，对于偶数长度，从 <code>i</code> 和 <code>i+1</code> 向外扩散。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(1)</code></p></li><li><p>时间：<code>O(n^2)</code></p></li></ul><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), ss_start = <span class="number">0</span>, ss_length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">helper</span>(s, i, i, ss_start, ss_length);</span><br><span class="line">            <span class="built_in">helper</span>(s, i, i+<span class="number">1</span>, ss_start, ss_length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(ss_start, ss_length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(string&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span>&amp; ss_start, <span class="keyword">int</span>&amp; ss_length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left; ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ss_length &lt; right - left - <span class="number">1</span>) &#123;</span><br><span class="line">            ss_start = left + <span class="number">1</span>;</span><br><span class="line">            ss_length = right - left - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：马拉车算法"><a href="#解法二：马拉车算法" class="headerlink" title="解法二：马拉车算法"></a>解法二：马拉车算法</h2><p>以前写过，参见：<a href="/posts/apply-manacher-s-algorithm-to-solve-longest-palindromic-substring-problem/">使用马拉车算法解决最长回文子串问题</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-substring/&quot;&gt;https://leetcode.com/problems/longest-palindromic-substring/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h3&gt;&lt;p&gt;给定字符串 &lt;code&gt;s&lt;/code&gt;，返回其中的最长回文子串。&lt;/p&gt;</summary>
    
    
    
    <category term="A3 - LeetCode" scheme="https://progcz.com/categories/A3-LeetCode/"/>
    
    <category term="B1 - LeetCode Problems" scheme="https://progcz.com/categories/A3-LeetCode/B1-LeetCode-Problems/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="String" scheme="https://progcz.com/tags/String/"/>
    
    <category term="Dynamic Programming" scheme="https://progcz.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>2021 August LeetCoding Challenge - Week 1</title>
    <link href="https://progcz.com/posts/1627831620/"/>
    <id>https://progcz.com/posts/1627831620/</id>
    <published>2021-08-01T15:28:02.000Z</published>
    <updated>2021-08-08T03:21:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 八月挑战专题，第一周，每日随缘更新。</p><span id="more"></span><h2 id="August-1st-Making-A-Large-Island"><a href="#August-1st-Making-A-Large-Island" class="headerlink" title="August 1st: Making A Large Island"></a>August 1st: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/613/week-1-august-1st-august-7th/3835/">Making A Large Island</a></h2><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定 <code>n*n</code> 的矩阵，每格中的数字为 <code>0</code> 或 <code>1</code>，可以将其中的 <code>1</code> 个格子从 <code>0</code> 置为 <code>1</code>，求解矩阵中最大「岛屿」的面积。</p><p>其中，「岛屿」是指在上、下、左、右四个方向中，连通起来的 <code>1</code> 的区域。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><blockquote><p>参考：<a href="https://leetcode.com/problems/making-a-large-island/discuss/1376700/C%2B%2B-BFS-O(n2)-5-%3A(">C++ BFS  O(n^2) 5% :(</a></p></blockquote><p>首先，遍历矩阵，使用 BFS 探索所有的岛屿，标记为不同的 <code>flag</code>，并且使用 <code>record</code> 记录不同 <code>flag</code> 对应的岛屿面积 <code>cnt</code>。</p><p>其次，遍历矩阵，找出上、下、左、右四个方向所对应的 <code>flag</code>，累加其 <code>cnt</code> 即可。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(n^2)</code></p></li><li><p>时间：<code>O(n^4)</code></p></li></ul><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dirs[<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; record, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>(), cnt = <span class="number">0</span>;</span><br><span class="line">        queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">        grid[i][j] = flag;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, y] = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; dir : dirs) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = x + dir.first, ny = y + dir.second;</span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] == <span class="number">1</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">                    grid[nx][ny] = flag;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        record[flag] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestIsland</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>(), flag = <span class="number">2</span>, res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; record;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">bfs</span>(grid, record, i, j, flag++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                unordered_set&lt;<span class="keyword">int</span>&gt; us;</span><br><span class="line">                us.<span class="built_in">insert</span>(grid[i][j]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; dir : dirs) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ni = i + dir.first, nj = j + dir.second;</span><br><span class="line">                    <span class="keyword">if</span> (ni &gt;= <span class="number">0</span> &amp;&amp; ni &lt; n &amp;&amp; nj &gt;= <span class="number">0</span> &amp;&amp; nj &lt; n) &#123;</span><br><span class="line">                        us.<span class="built_in">insert</span>(grid[ni][nj]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> sum = !grid[i][j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; flag : us) &#123;</span><br><span class="line">                    sum += record[flag];</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-2nd-Two-Sum"><a href="#August-2nd-Two-Sum" class="headerlink" title="August 2nd: Two Sum"></a>August 2nd: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/613/week-1-august-1st-august-7th/3836/">Two Sum</a></h2><h3 id="大意-1"><a href="#大意-1" class="headerlink" title="大意"></a>大意</h3><p>给定数组 <code>nums</code> 和数字 <code>target</code>，要求在 <code>nums</code> 中找到两个数字，和为 <code>target</code>，返回这两个数字的下标。</p><p>题目保证有且只有一个解，而且同一个数字不能用两次。</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>以前做过，参见：<a href="/posts/leetcode-problem-two-sum/#%E8%A7%A3%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%80%9F%E5%8A%A9-hash-map%EF%BC%8C%E7%94%A8%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4">LeetCode Problem 1 - Two Sum</a></p><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(n)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; record;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = record.<span class="built_in">find</span>(target-nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (iter != record.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, iter-&gt;second&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            record[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-3rd-Subsets-II"><a href="#August-3rd-Subsets-II" class="headerlink" title="August 3rd: Subsets II"></a>August 3rd: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/613/week-1-august-1st-august-7th/3837/">Subsets II</a></h2><h3 id="大意-2"><a href="#大意-2" class="headerlink" title="大意"></a>大意</h3><p>给定一个数组 <code>nums</code>，其中可能有重复元素，返回所有可能的子集，要求子集之间不重复。</p><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>使用 <code>set&lt;vector&lt;int&gt;&gt; s</code> 来存放所有的子集，避免出现 <code>[1,2]</code> 和 <code>[1,2]</code> 这种重复 case。</p><p>将 <code>nums</code> 进行排序，避免出现 <code>[1,2,2]</code> 和 <code>[2,1,2]</code> 这种重复 case。</p><p>遍历 <code>nums</code>，将遍历到的 <code>num</code> 与 <code>s</code> 中的每个数组组成新的数组，添加至 <code>s</code> 中即可。</p><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(2^n)</code>（不确定）</p></li><li><p>时间：<code>O(n*2^n)</code></p></li></ul><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        set&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">        s.<span class="built_in">insert</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;&#125;);</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            set&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ts</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> vi : ts) &#123;</span><br><span class="line">                vi.<span class="built_in">push_back</span>(num);</span><br><span class="line">                s.<span class="built_in">insert</span>(vi);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-4th-Path-Sum-II"><a href="#August-4th-Path-Sum-II" class="headerlink" title="August 4th: Path Sum II"></a>August 4th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/613/week-1-august-1st-august-7th/3838/">Path Sum II</a></h2><h3 id="大意-3"><a href="#大意-3" class="headerlink" title="大意"></a>大意</h3><p>给定一个二叉树的根节点 <code>root</code> 和数字 <code>targetSum</code>，返回所有从根节点到叶节点的路径，要求路径上所有节点之和等于 <code>targetSum</code>。</p><h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>使用 DFS 即可。</p><h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(nlogn)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="keyword">int</span> targetSum) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root, res, path, sum, targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; res,</span></span></span><br><span class="line"><span class="function"><span class="params">             vector&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span>&amp; sum, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        sum += node-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == targetSum) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;left, res, path, sum, targetSum);</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;right, res, path, sum, targetSum);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        sum -= node-&gt;val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-5th-Stone-Game"><a href="#August-5th-Stone-Game" class="headerlink" title="August 5th: Stone Game"></a>August 5th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/613/week-1-august-1st-august-7th/3870/">Stone Game</a></h2><h3 id="大意-4"><a href="#大意-4" class="headerlink" title="大意"></a>大意</h3><p>给定数组 <code>piles</code>，数组中数字个数为偶数，数字之和为奇数。小明和小红轮流从数组的首位或末位取数，小红先手，直到取完为止，两者手中数字之和较大者胜。假设两者均以最优策略进行游戏，返回小红是否能够获胜。</p><h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><blockquote><p>参考：<a href="https://leetcode.com/problems/stone-game/discuss/1384652/C%2B%2BPython-DP-No-math-Easy-to-understand-Clean-and-Concise">[C++/Python] DP - No math - Easy to understand - Clean &amp; Concise</a></p></blockquote><h4 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(n^2)</code></p></li><li><p>时间：<code>O(n^2)</code></p></li></ul><h4 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGame</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = piles.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;pii&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;pii&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = n - <span class="number">1</span>; left &gt;= <span class="number">0</span>; --left) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> right = left; right &lt; n; ++right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                    dp[left][right] = <span class="built_in">make_pair</span>(piles[left], <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pii pickLeft = dp[left + <span class="number">1</span>][right];</span><br><span class="line">                pii pickRight = dp[left][right - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (piles[left] + pickLeft.second &gt; piles[right] + pickRight.second) &#123;</span><br><span class="line">                    dp[left][right] = <span class="built_in">make_pair</span>(piles[left] + pickLeft.second, pickLeft.first);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[left][right] = <span class="built_in">make_pair</span>(piles[right] + pickRight.second, pickRight.first);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [aliceScore, leeScore] = dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> aliceScore &gt; leeScore;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-6th-N-ary-Tree-Level-Order-Traversal"><a href="#August-6th-N-ary-Tree-Level-Order-Traversal" class="headerlink" title="August 6th: N-ary Tree Level Order Traversal"></a>August 6th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/613/week-1-august-1st-august-7th/3871/">N-ary Tree Level Order Traversal</a></h2><h3 id="大意-5"><a href="#大意-5" class="headerlink" title="大意"></a>大意</h3><p>给定一个树，将其按层级进行序列化。</p><h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3><p>使用 BFS 即可。</p><h4 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(n)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h4 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        queue&lt;Node*&gt; q; q.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tres;</span><br><span class="line">        queue&lt;Node*&gt; tq;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            tres.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> child : node-&gt;children) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!child) <span class="keyword">continue</span>;</span><br><span class="line">                tq.<span class="built_in">push</span>(child);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                q = tq;</span><br><span class="line">                <span class="keyword">while</span> (!tq.<span class="built_in">empty</span>()) tq.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (!tres.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(tres);</span><br><span class="line">                    tres.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-7th-Palindrome-Partitioning-II"><a href="#August-7th-Palindrome-Partitioning-II" class="headerlink" title="August 7th: Palindrome Partitioning II"></a>August 7th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/613/week-1-august-1st-august-7th/3872/">Palindrome Partitioning II</a></h2><h3 id="大意-6"><a href="#大意-6" class="headerlink" title="大意"></a>大意</h3><p>给定一个字符串 <code>s</code>，切分 <code>s</code> 使得每个子串都是回文子串，返回切分的最小次数。 </p><h3 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h3><blockquote><p>参考：<a href="https://www.cnblogs.com/grandyang/p/4271456.html">[LeetCode] Palindrome Partitioning II 拆分回文串之二 - 刷尽天下</a></p></blockquote><h4 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(n^2)</code></p></li><li><p>时间：<code>O(n^2)</code></p></li></ul><h4 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">p</span>(n, vector&lt;<span class="keyword">bool</span>&gt;(n));</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; (i - j &lt; <span class="number">2</span> || p[j + <span class="number">1</span>][i - <span class="number">1</span>])) &#123;</span><br><span class="line">                    p[j][i] = <span class="literal">true</span>;</span><br><span class="line">                    dp[i] = (j == <span class="number">0</span>) ? <span class="number">0</span> : <span class="built_in">min</span>(dp[i], dp[j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 八月挑战专题，第一周，每日随缘更新。&lt;/p&gt;</summary>
    
    
    
    <category term="A3 - LeetCode" scheme="https://progcz.com/categories/A3-LeetCode/"/>
    
    <category term="B4 - LeetCoding Challenge" scheme="https://progcz.com/categories/A3-LeetCode/B4-LeetCoding-Challenge/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>上海迪士尼乐园攻略：两人行一日游</title>
    <link href="https://progcz.com/posts/1624282620/"/>
    <id>https://progcz.com/posts/1624282620/</id>
    <published>2021-06-21T13:41:11.000Z</published>
    <updated>2021-06-26T06:24:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>从去年开始，女朋友就一直念着想去上海迪士尼乐园，然而疫情使得计划一拖再拖，直到上周六才如愿以偿。</p><p>不得不说，迪士尼乐园的确是真实世界中最接近于「童话王国」的地方，迪士尼作品中的经典形象在这里都触手可及。你可以是杰克船长的水手，也可以是冰雪女王的朋友；你可以坐在蜜罐里和小熊维尼打招呼，也可以跟着小飞侠穿梭在城市的上空。</p><p>迪士尼满足你的童心、少女心，以及对于浪漫的一切幻想。<del>只要你肯花钱。</del></p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/25.png"></p><span id="more"></span><div class="note info"><p>友情提示：上海迪士尼乐园的政策几乎每月一变，可能导致攻略失效，比如很多攻略中提到的 FP 早就不复存在了，所以以下内容与其称为攻略，不如说是记录，仅供参考。</p></div><h2 id="1-购买门票"><a href="#1-购买门票" class="headerlink" title="1 购买门票"></a>1 购买门票</h2><p>我是在美团上购买的门票，价格大概是官方打 93 折。</p><blockquote><p>需要注意的是，不管是什么渠道购买的门票，都会有一行类似的注意事项：</p><p><em>乐园门票一经售出不可转让、不可退款，除非法律另有规定。指定日门票可在尚有余票且补足票价差额的前提下，于有效日的两日前更换两次等值或者更高价值的指定日门票。</em></p><p>而且我当时看到只能更换为当月的门票，所以建议提前规划行程，尤其注意天气。</p></blockquote><h2 id="2-准备随身携带的物品"><a href="#2-准备随身携带的物品" class="headerlink" title="2 准备随身携带的物品"></a>2 准备随身携带的物品</h2><p>记得携带身份证、口罩（疫情期间）、手机、移动电源及数据线、一次性雨衣（漂流项目和下雨天气）、空的非玻璃水瓶（园区内直饮水）、防晒用品（夏季）、小风扇（夏季）等等。</p><p>不能携带自拍杆、折叠椅、自热食物等等。</p><p>更多参考<a href="https://www.shanghaidisneyresort.com/rules/">上海迪士尼乐园游客须知</a>。</p><h2 id="3-住宿"><a href="#3-住宿" class="headerlink" title="3 住宿"></a>3 住宿</h2><p>我本身在上海，不用考虑住宿，所以这一部分就跳过了。</p><h2 id="4-入园"><a href="#4-入园" class="headerlink" title="4 入园"></a>4 入园</h2><p>如果购买早享卡，可以提前一个小时入园。</p><p>如果不买早享卡，建议提前至少一个小时到达园区门口排队，有包游客需要过有包安检，比较慢，无包游客只需要过安检门，比较快。</p><blockquote><p>需要注意的是，同一订单的多张门票必须同时入园，所以要么分不同订单来购买门票，要么同行的人都排有包安检，除非大家都不带包。</p></blockquote><h2 id="5-游玩"><a href="#5-游玩" class="headerlink" title="5 游玩"></a>5 游玩</h2><p>提前下载好上海迪士尼乐园的 APP，入园后将同行门票绑定在同一个 APP 内，优先领取预约等候卡，没有预约等候卡的项目可以在游玩过程中视排队情况购买尊享卡。</p><ol><li><p>领取预约等候卡，等于拥有在高峰时段排队的资格。每天可领取预约等候卡的项目不固定，可以当日在 APP 内查询。</p></li><li><p>购买尊享卡，等于拥有在任意时段插队的资格。如果想买尊享卡的项目比较多，可以考虑八件套或者六件套。</p></li></ol><p>放张盗来的图，热门项目基本一览无余。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/26.png"></p><p>再来分享一波自己拍的照片。</p><p>两个必看的舞台剧：风暴来临·杰克船长之惊天特技大冒险 &amp; 冰雪奇缘·欢唱盛会。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/27.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/28.png"></div></div></div><p>在漫威总部见到了钢铁侠的历代战甲，还碰到了钢铁侠的 COS，可惜是个视频没办法传上来。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/29.png"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/30.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/31.png"></div></div></div><p>夜晚的旋转木马，可以说是如梦如幻了。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/32.png"></p><h2 id="6-就餐"><a href="#6-就餐" class="headerlink" title="6 就餐"></a>6 就餐</h2><p>图个省事，我和女朋友在园区内吃的午饭和晚饭，每顿人均 100 左右。</p><p>午饭在加勒比海盗附近的巴博萨烧烤，左图的秋刀鱼套餐很不错。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/33.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/34.png"></div></div></div><p>晚饭在创极速光轮附近的星露台餐厅，钢铁侠牛肉汉堡非常难吃，不放图了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从去年开始，女朋友就一直念着想去上海迪士尼乐园，然而疫情使得计划一拖再拖，直到上周六才如愿以偿。&lt;/p&gt;
&lt;p&gt;不得不说，迪士尼乐园的确是真实世界中最接近于「童话王国」的地方，迪士尼作品中的经典形象在这里都触手可及。你可以是杰克船长的水手，也可以是冰雪女王的朋友；你可以坐在蜜罐里和小熊维尼打招呼，也可以跟着小飞侠穿梭在城市的上空。&lt;/p&gt;
&lt;p&gt;迪士尼满足你的童心、少女心，以及对于浪漫的一切幻想。&lt;del&gt;只要你肯花钱。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/25.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A1 - 生活随笔" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="B1 - 经历" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/B1-%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="上海" scheme="https://progcz.com/tags/%E4%B8%8A%E6%B5%B7/"/>
    
    <category term="迪士尼" scheme="https://progcz.com/tags/%E8%BF%AA%E5%A3%AB%E5%B0%BC/"/>
    
    <category term="加勒比海盗" scheme="https://progcz.com/tags/%E5%8A%A0%E5%8B%92%E6%AF%94%E6%B5%B7%E7%9B%97/"/>
    
    <category term="漫威" scheme="https://progcz.com/tags/%E6%BC%AB%E5%A8%81/"/>
    
  </entry>
  
  <entry>
    <title>招商银行朝朝宝：余额宝和零钱通的最佳替代品</title>
    <link href="https://progcz.com/posts/1620777814/"/>
    <id>https://progcz.com/posts/1620777814/</id>
    <published>2021-05-12T00:05:49.000Z</published>
    <updated>2021-05-13T14:14:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我们看向历史的后视镜，2013 年面世的余额宝确实是一款影响十分深远的产品，它永久地改变了人们对于短期闲置现金的处置方式，更进一步地推动了无现金支付的发展。邯郸学步的零钱通后来也不断壮大，和余额宝一起，成为人们活期理财的首要选择。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/03.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/04.png"></div></div></div><p>达成这一切，靠的便是直击用户痛点的两个特性：<strong>高收益率</strong>和<strong>随时支取</strong>。</p><p>然而，眼看着互联网金融的繁荣发展，银行自然不能坐以待毙。</p><p>招商银行推出的<strong>朝朝宝</strong>便是这样一款狙击余额宝/零钱通的活期理财产品，极大地吸引了以招商银行卡为主力卡的用户，比如我。</p><span id="more"></span><h2 id="1-在余额宝出现之前，用于日常支出的钱都放在哪里？"><a href="#1-在余额宝出现之前，用于日常支出的钱都放在哪里？" class="headerlink" title="1 在余额宝出现之前，用于日常支出的钱都放在哪里？"></a>1 在余额宝出现之前，用于日常支出的钱都放在哪里？</h2><p>无非三个选择：钱包、银行卡的活期账户、支付宝的余额。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/05.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/06.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/07.png"></div></div></div><p>这样看来，钱包和银行卡的活期账户明显是更优的选择，因为</p><ul><li>如果场景不支持扫码，可以用钱包中的现金，或者 POS 机刷银行卡支付。</li><li>如果场景支持扫码，可以在支付宝中选择使用银行卡支付。</li></ul><p>更何况，放在银行卡里，还有聊胜于无的利息收入，放在支付宝余额里，就真的只是放着而已。</p><p>所以，<strong>用户好像没有什么动力，特地把银行卡里的钱转到支付宝里。</strong></p><h2 id="2-余额宝解决了什么痛点？"><a href="#2-余额宝解决了什么痛点？" class="headerlink" title="2 余额宝解决了什么痛点？"></a>2 余额宝解决了什么痛点？</h2><h3 id="2-1-高收益率"><a href="#2-1-高收益率" class="headerlink" title="2.1 高收益率"></a>2.1 高收益率</h3><p>众所周知，余额宝本质上属于货币基金。</p><blockquote><p>货币基金的运作方式可以简单理解为，基金将用户的钱集中起来，去跟银行谈一个利息较高的大额存款，再将利息作为收益返还给用户。</p></blockquote><p>好，这就为余额宝带来了第一个极具吸引力的特性：<strong>我把钱放在余额宝里，是有收益的，而且收益远高于银行卡的活期利息。</strong></p><div class="note info"><p>热知识：2014 年，余额宝的七日年化曾高达 6.76%，万份收益 1.8 元左右。</p></div><p>但是，用户还有个小问题：我为啥不选择其他货币基金？</p><h3 id="2-2-随时支取"><a href="#2-2-随时支取" class="headerlink" title="2.2 随时支取"></a>2.2 随时支取</h3><p>我们都知道，余额宝可以用于扫码支付、淘宝购物。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/08.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/09.png"></div></div></div><p>其支撑就在于，不同于当时的其他货币基金，余额宝提供了 T+0 的快速赎回方式。</p><p>好，第二个极具吸引力的特性向我们走来：<strong>我把钱放在余额宝里，24 小时均可取出，几分钟内到账。</strong></p><p>如今，众多「宝宝」类产品，比如天天基金的活期宝，其背后的货币基金也可以实现 T+0，但是无法打通消费场景，这是来自于支付宝的降维打击。</p><h2 id="3-余额宝还有什么缺点？"><a href="#3-余额宝还有什么缺点？" class="headerlink" title="3 余额宝还有什么缺点？"></a>3 余额宝还有什么缺点？</h2><h3 id="3-1-收益率不断下滑"><a href="#3-1-收益率不断下滑" class="headerlink" title="3.1 收益率不断下滑"></a>3.1 收益率不断下滑</h3><p>我不是经济专家，无法准确给出收益率下滑的原因。</p><p>但是对于一个用户而言，这就让我把钱转到余额宝里的动力越来越低。</p><div class="note warning"><p>内心 OS：每天就那么点收益，何必费那个劲呢？</p></div><h3 id="3-2-资金分散，不便管理"><a href="#3-2-资金分散，不便管理" class="headerlink" title="3.2 资金分散，不便管理"></a>3.2 资金分散，不便管理</h3><p>这实际上并不是余额宝的缺点，而是支付宝和微信支付二分天下带来的问题。</p><p>对于日常收支、投资理财，我有非常清晰的记录和规划。我每月初都会花十几分钟的时间整理一个表格，上面清晰地记录着我的每一分钱都放在什么地方，同时根据现状做出调整和规划。</p><p>具体到用于日常支出的短期闲置现金，我一般会在余额宝和零钱通分别放 5K 整。这样的话，下个月初我就能根据剩多少钱，快速算出上个月的支出。如果有异常，再去查看账单明细，看看是什么事情花费较多，有没有可优化的空间。</p><p>虽然管理两处也不是什么特别麻烦的事情，但是如果能合为一处岂不快哉。</p><h2 id="4-为什么推荐朝朝宝？"><a href="#4-为什么推荐朝朝宝？" class="headerlink" title="4 为什么推荐朝朝宝？"></a>4 为什么推荐朝朝宝？</h2><p>对于我而言，朝朝宝完美解决了上面两个缺点。</p><h3 id="4-1-收益方面"><a href="#4-1-收益方面" class="headerlink" title="4.1 收益方面"></a>4.1 收益方面</h3><p>朝朝宝的七日年化高达 3.10%，万分收益 0.8 元左右。</p><div class="note warning"><p>作为对比，支付宝的七日年化只有 2.12%，万份收益 0.5 元左右。</p></div><p>这一点主要得益于<strong>朝朝宝背后并不是货币基金，而是五款风险评级均为 R1 的招行代销理财产品，</strong>在收益较高的同时也保证了资金的安全性。</p><blockquote><p>其中一款代销理财细节可以看官网资料：<a href="http://www.cmbchina.com/cfweb/personal/saproductdetail.aspx?saaCod=D07&funCod=8920">招银理财招赢聚宝盆 1 号现金管理类理财计划</a></p></blockquote><p>当然，收益率会不会像余额宝一样下滑，还需要持续观察，至少现在是高的对吧。</p><h3 id="4-2-管理方面"><a href="#4-2-管理方面" class="headerlink" title="4.2 管理方面"></a>4.2 管理方面</h3><p>朝朝宝支持支付宝支付，微信支付，银行转账，ATM 取款，还信用卡、花呗和贷款，购买银行理财和基金等，如果不出意外的话，应该还支持 Apple Pay 或者其他 Pay（我没试过）。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/10.png"></p><p>我只需要每月初在朝朝宝里放 1W 整，不管是支付宝还是微信支付，在扫码后选择使用银行卡支付即可。</p><p>这样的话，我就可以集中管理生活中各个方面的支出情况，我直接大呼过瘾。</p><div class="note warning"><p>需要注意的是，朝朝宝最多可转入 5W，每日也最多可转出 5W，对于日常支出较多的人来说可能不是很友好。</p></div><h2 id="5-后记"><a href="#5-后记" class="headerlink" title="5 后记"></a>5 后记</h2><p>这不是朝朝宝的软文（招行也不至于卑贱到来找我写软文），单纯只是我想分享一下好的理财产品。不构成理财建议，但是如果对你有所帮助，那就再好不过了。也祝自己早日暴富！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当我们看向历史的后视镜，2013 年面世的余额宝确实是一款影响十分深远的产品，它永久地改变了人们对于短期闲置现金的处置方式，更进一步地推动了无现金支付的发展。邯郸学步的零钱通后来也不断壮大，和余额宝一起，成为人们活期理财的首要选择。&lt;/p&gt;
&lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot;&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/03.png&quot;&gt;&lt;/div&gt;&lt;div class=&quot;group-picture-column&quot;&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/04.png&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;达成这一切，靠的便是直击用户痛点的两个特性：&lt;strong&gt;高收益率&lt;/strong&gt;和&lt;strong&gt;随时支取&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然而，眼看着互联网金融的繁荣发展，银行自然不能坐以待毙。&lt;/p&gt;
&lt;p&gt;招商银行推出的&lt;strong&gt;朝朝宝&lt;/strong&gt;便是这样一款狙击余额宝/零钱通的活期理财产品，极大地吸引了以招商银行卡为主力卡的用户，比如我。&lt;/p&gt;</summary>
    
    
    
    <category term="A1 - 生活随笔" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="B3 - 理财" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/B3-%E7%90%86%E8%B4%A2/"/>
    
    
    <category term="招商银行" scheme="https://progcz.com/tags/%E6%8B%9B%E5%95%86%E9%93%B6%E8%A1%8C/"/>
    
    <category term="朝朝宝" scheme="https://progcz.com/tags/%E6%9C%9D%E6%9C%9D%E5%AE%9D/"/>
    
    <category term="余额宝" scheme="https://progcz.com/tags/%E4%BD%99%E9%A2%9D%E5%AE%9D/"/>
    
    <category term="零钱通" scheme="https://progcz.com/tags/%E9%9B%B6%E9%92%B1%E9%80%9A/"/>
    
    <category term="活期理财" scheme="https://progcz.com/tags/%E6%B4%BB%E6%9C%9F%E7%90%86%E8%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>从一封邮件谈谈我为什么不再想要评论系统</title>
    <link href="https://progcz.com/posts/1620608429/"/>
    <id>https://progcz.com/posts/1620608429/</id>
    <published>2021-05-10T01:01:20.000Z</published>
    <updated>2021-05-11T15:08:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>在重建站点的过程中，我曾经挣扎过要不要重设评论系统。</p><p>基础设施方面，适用于静态博客的各类评论系统都已经发展得比较成熟，比如独立服务的 <a href="https://blog.disqus.com/">Disqus</a>、依赖 GitHub Issues 的 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 和 <a href="https://github.com/utterance/utterances">Utterances</a>、依赖 LeanCloud 等的 <a href="https://github.com/xCss/Valine">Valine</a> 和 <a href="https://github.com/lizheming/waline">Waline</a>，选择颇多。</p><p>对于博客而言，评论系统可以让读者更方便地给出反馈，和作者交流彼此的观点和看法。</p><p>但是如你所见，我还是没有重设评论系统。</p><p>真正促使我放弃的，根本原因是<strong>互联网中随处可见的，无知、无营养甚至充满恶意的评论。</strong></p><p>而导火索则是这样一封邮件：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/01.png"></p><span id="more"></span><h2 id="1-事情起因（我的猜测）"><a href="#1-事情起因（我的猜测）" class="headerlink" title="1 事情起因（我的猜测）"></a>1 事情起因（我的猜测）</h2><p>这位朋友曾经使用 Cloudflare 搭过 Google Scholar 的镜像网站，突然发现不可用了，于是在 Google 搜索相关信息，看到了我一年前写的这篇文章：<a href="https://progcz.com/posts/use-cf-workers-build-google-and-github-mirrors/">使用 Cloudflare Workers 搭建 Google 和 GitHub 镜像网站</a>，认为是我的分享和传播导致了 Cloudflare 不可用，怒不可遏的同时又看到了我的邮箱，于是就有了上面那封邮件。</p><h2 id="2-我的看法"><a href="#2-我的看法" class="headerlink" title="2 我的看法"></a>2 我的看法</h2><p>这位朋友的核心观点在于：<strong>这样的知识，自己知道就好了，不要拿出来分享。</strong></p><p>可以说是非常自私了，而且多少有点逻辑的人都能看出这里面的问题：<strong>如果每个人都不分享这样的知识，那这位朋友又是从哪里获取到的呢？靠自己顿悟吗？</strong></p><p>我有时候也会很纳闷，为什么这么简单的道理，都没有出现在这类朋友的脑子里。</p><p>如果是其他网民，我可能可以理解。因为根据<a href="https://finance.sina.com.cn/tech/2020-09-29/doc-iivhuipp7144597.shtml">这篇文章</a>，2020 年网民的规模达 9.40 亿，其中学历达到本科及以上的仅为 8.8％。没有经历过高等教育的话，认知是会受到一定限制。</p><p>但是这位朋友提到了谷歌学术，说明至少已经到了高等教育的阶段，却依然这么狭隘，让我匪夷所思。</p><p>当然，这种情况不止发生了一次，在评论量较大的博客、在我认为社区氛围很好的 B 站和豆瓣，我都会频繁地看到这类评论，不然我也不会对互联网的评论环境如此失望。</p><h2 id="3-我的回复"><a href="#3-我的回复" class="headerlink" title="3 我的回复"></a>3 我的回复</h2><p>尽管无法理解，但我还是出于本能的 defence，回复了这封邮件：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/02.png"></p><p>看，这也是我不想要评论系统的原因之一，我不想为了这种事情 defence 啊。</p><p>人生已经很累了，照顾好自己的情绪都是一件非常困难的事情，就更不想陷入这种本不该存在的争论之中了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在重建站点的过程中，我曾经挣扎过要不要重设评论系统。&lt;/p&gt;
&lt;p&gt;基础设施方面，适用于静态博客的各类评论系统都已经发展得比较成熟，比如独立服务的 &lt;a href=&quot;https://blog.disqus.com/&quot;&gt;Disqus&lt;/a&gt;、依赖 GitHub Issues 的 &lt;a href=&quot;https://github.com/gitalk/gitalk&quot;&gt;Gitalk&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/utterance/utterances&quot;&gt;Utterances&lt;/a&gt;、依赖 LeanCloud 等的 &lt;a href=&quot;https://github.com/xCss/Valine&quot;&gt;Valine&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/lizheming/waline&quot;&gt;Waline&lt;/a&gt;，选择颇多。&lt;/p&gt;
&lt;p&gt;对于博客而言，评论系统可以让读者更方便地给出反馈，和作者交流彼此的观点和看法。&lt;/p&gt;
&lt;p&gt;但是如你所见，我还是没有重设评论系统。&lt;/p&gt;
&lt;p&gt;真正促使我放弃的，根本原因是&lt;strong&gt;互联网中随处可见的，无知、无营养甚至充满恶意的评论。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而导火索则是这样一封邮件：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/01.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A1 - 生活随笔" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="B2 - 折腾" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/B2-%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="Blog" scheme="https://progcz.com/tags/Blog/"/>
    
    <category term="Mail" scheme="https://progcz.com/tags/Mail/"/>
    
    <category term="Comment" scheme="https://progcz.com/tags/Comment/"/>
    
  </entry>
  
  <entry>
    <title>谈谈 Hexo 的主题现状以及我对 NexT 的细节改造</title>
    <link href="https://progcz.com/posts/1619784301/"/>
    <id>https://progcz.com/posts/1619784301/</id>
    <published>2021-04-30T15:05:45.000Z</published>
    <updated>2021-04-30T15:05:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>上次发文还是三月初，中间停更了这么久，主要原因在于，之前我对主题源码进行了侵入式的改造，难以升级享受最新的版本特性，于是我就想要重建这个博客站点，兼顾可升级和可改造。</p><p>那我就想，既然要重建，何不换个主题试一下？果然，试试就逝世。</p><span id="more"></span><h2 id="1-Hexo-主题"><a href="#1-Hexo-主题" class="headerlink" title="1 Hexo 主题"></a>1 Hexo 主题</h2><p>在静态博客框架中，Hexo 向来是最受青睐的选择，没有之一。</p><p>Jekyll 作为 GitHub 官方支持的框架，可以直接托管源码而无需手动生成静态网页，Hugo 借助 Go 语言的性能优势，号称全世界最快的框架，然而这两者都有一点远落后于 Hexo，那就是最为关键的<strong>主题生态</strong>。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/01.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/02.png"></div></div></div><p>作为一个想搭博客的人来说，审美能对自己胃口才是头等大事，所以主题生态只有枝繁叶茂才能留住众口难调的用户。</p><p>Hexo 使用 Node.js 开发，从语言层面上就吸引了大批优秀的前端工程师，精美主题可以说是层出不穷。</p><p>当然再好的主题也必然有令人不甚满意的地方，这里就把 Butterfly 单拎出来说说问题。</p><h3 id="1-1-Butterfly"><a href="#1-1-Butterfly" class="headerlink" title="1.1 Butterfly"></a>1.1 <a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></h3><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/03.png"></p><p>简洁好看，尤其是首屏的视觉效果，足够吸引眼球。这也是我刚开始重建的第一选择。</p><p>但是这个主题，说得严重一点，「金玉其外，败絮其中。」</p><p>我相信，任何用过 Butterfly 的人，一定会被 <code>_config.butterfly.yml</code> 中混乱的配置给搞得心烦意乱，举个栗子：</p><p>配置中有一段是关于网站默认的展示模式，可以选择明亮/暗黑：</p><figure class="highlight yaml"><figcaption><span>code</span><a href="https://github.com/jerryc127/hexo-theme-butterfly/blob/dev/_config.yml">_config.yml</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Default display mode (網站默認的顯示模式)</span></span><br><span class="line"><span class="comment"># light (default) / dark</span></span><br><span class="line"><span class="attr">display_mode:</span> <span class="string">light</span></span><br></pre></td></tr></table></figure><p>然而在后面又出现了一段是关于暗黑模式，可以选择是否开启：</p><figure class="highlight yaml"><figcaption><span>code</span><a href="https://github.com/jerryc127/hexo-theme-butterfly/blob/dev/_config.yml">_config.yml</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># dark mode</span></span><br><span class="line"><span class="attr">darkmode:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Toggle Button to switch dark/light mode</span></span><br><span class="line">    <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Switch dark/light mode automatically (自動切換 dark mode和 light mode)</span></span><br><span class="line">    <span class="comment"># autoChangeMode: 1  Following System Settings, if the system doesn&#x27;t support dark mode, it will switch dark mode between 6 pm to 6 am</span></span><br><span class="line">    <span class="comment"># autoChangeMode: 2  Switch dark mode between 6 pm to 6 am</span></span><br><span class="line">    <span class="comment"># autoChangeMode: false</span></span><br><span class="line">    <span class="attr">autoChangeMode:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这让我不禁想问：如果我在前面选了默认明亮模式，后面又选了开启暗黑模式，那主题到底是展现哪一种？只有试过之后才能知道，无疑增加了理解成本。</p><p>类似的问题还有很多，就不赘述了。总之这个配置文件折磨了我很久，最终不得不放弃。</p><div class="note warning"><p>不管怎样，我还是很尊重主题作者的，提供免费开源的主题给大家用，本身就非常值得敬佩。但还是那句话，「若批评不自由，则赞美无意义。」</p><p><del>而且感觉主题作者是个暴躁老哥，惹不太起。</del></p></div><h2 id="2-NexT-改造"><a href="#2-NexT-改造" class="headerlink" title="2 NexT 改造"></a>2 NexT 改造</h2><p>当然，我换过不止 Butterfly 一个主题，然而其他主题即便没有混乱的配置文件，也存在大量优化不到位的细节，所以兜兜转转又回到了 NexT 的怀抱。</p><h3 id="2-1-基本配置"><a href="#2-1-基本配置" class="headerlink" title="2.1 基本配置"></a>2.1 基本配置</h3><p><code>_config.yml</code> 和 <code>_config.next.yml</code> 中的配置基本都体现在 <a href="https://github.com/ProgCZ/progcz.github.io/commit/f3cdd681835389803f187024e06124960f48d251">commit f3cdd68</a> 中，不再赘述。</p><h3 id="2-2-特殊改造"><a href="#2-2-特殊改造" class="headerlink" title="2.2 特殊改造"></a>2.2 特殊改造</h3><p>特殊改造基本都体现在 <a href="https://github.com/ProgCZ/progcz.github.io/commit/3d56b383f78c1b260edb668ff7ed8e0d6f5232fd">commit 3d56b38</a> 中，没有污染博客源码，只是通过自定义的 js 和 css 来实现。</p><ol><li><p>替换站点标题中不规范的部分</p><p> 如果足够细心的话，你就会发现，在每个分类页面中，标题中的冒号都是英文冒号，不符合中文排版规范：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/04.png"></p><p> 替换后：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/05.png"></p></li><li><p>替换归档页面中不规范的部分</p><p> 归档页面中，表达冗余，且英文叹号也不符合中文排版规范：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/06.png"></p><p> 替换后：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/07.png"></p></li><li><p>替换文章信息中不规范的部分</p><p> 这个单纯是我看中文逗号不顺眼，不能表达分类之间的层级关系：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/08.png"></p><p> 替换后：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/09.png"></p></li><li><p>替换页脚中不规范的部分</p><p> 这个也单纯是我看 copyright 字符不顺眼，有点矮：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/10.png"></p><p> 替换后：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/11.png"></p></li><li><p>动画速度调整至 0.3s</p> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.animated</span> &#123;</span><br><span class="line">    <span class="attribute">animation-duration</span>: <span class="number">0.3s</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>侧边栏字体从 <code>font-size-smaller</code> 调大至 <code>font-size-small</code></p> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu-item</span> &#123;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: $font-size-small;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.links-of-author</span> &#123;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: $font-size-small;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.site-state-item-name</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: $font-size-small;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-后记"><a href="#3-后记" class="headerlink" title="3 后记"></a>3 后记</h2><p>折腾告一段落，静下心来好好写些文章吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上次发文还是三月初，中间停更了这么久，主要原因在于，之前我对主题源码进行了侵入式的改造，难以升级享受最新的版本特性，于是我就想要重建这个博客站点，兼顾可升级和可改造。&lt;/p&gt;
&lt;p&gt;那我就想，既然要重建，何不换个主题试一下？果然，试试就逝世。&lt;/p&gt;</summary>
    
    
    
    <category term="A1 - 生活随笔" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="B2 - 折腾" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/B2-%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="Blog" scheme="https://progcz.com/tags/Blog/"/>
    
    <category term="Hexo" scheme="https://progcz.com/tags/Hexo/"/>
    
    <category term="NexT" scheme="https://progcz.com/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Problem 3 - Longest Substring Without Repeating Characters</title>
    <link href="https://progcz.com/posts/leetcode-problem-longest-substring-without-repeating-characters/"/>
    <id>https://progcz.com/posts/leetcode-problem-longest-substring-without-repeating-characters/</id>
    <published>2021-02-26T01:08:46.000Z</published>
    <updated>2021-03-03T00:07:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a></p><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定字符串，输出最长不重复子串的长度。</p><span id="more"></span><h2 id="解法一：滑动窗口"><a href="#解法一：滑动窗口" class="headerlink" title="解法一：滑动窗口"></a>解法一：滑动窗口</h2><p>借助 <code>hash_map</code>，建立起<strong>子串中</strong>字符和出现次数的映射，如果 <code>hash_map</code> 中所有字符的出现次数均不大于 <code>1</code>，那么就说明当前子串为不重复子串。</p><p>滑动窗口的左右边界分别为 <code>beg</code> 和 <code>end</code>（均初始化为 <code>0</code>），</p><ol><li><p>在遍历 <code>hash_map</code> 后判断当前子串为不重复子串的情况下，<code>end</code> 不断右移，同时将 <code>hash_map</code> 中对应字符的出现次数 <code>+1</code>。</p></li><li><p>上述 <code>end</code> 的右移停止，说明 <code>end</code> 到达字符串末尾或者当前子串为重复子串，则记录不重复子串的最大长度。</p></li><li><p>在遍历 <code>hash_map</code> 后判断当前子串为重复子串的情况下，<code>beg</code> 不断右移，同时将 <code>hash_map</code> 中对应字符的出现次数 <code>-1</code>。</p></li><li><p>上述 <code>beg</code> 的右移停止，说明 <code>beg</code> 到达 <code>end</code> 或者当前子串不为重复子串，则重复整个流程。</p></li></ol><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(n)</code>（不太确定）</p></li><li><p>时间：<code>O(n)</code></p></li></ul><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; um;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> beg = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; <span class="built_in">helper</span>(um)) &#123;</span><br><span class="line">                um[s[end++]-<span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> len = (end == n &amp;&amp; <span class="built_in">helper</span>(um)) ?</span><br><span class="line">                (end - beg) : (end - beg - <span class="number">1</span>);</span><br><span class="line">            res = <span class="built_in">max</span>(res, len);</span><br><span class="line">            <span class="keyword">while</span> (beg &lt;= end &amp;&amp; !<span class="built_in">helper</span>(um)) &#123;</span><br><span class="line">                um[s[beg++]-<span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="keyword">const</span> unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; um)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = um.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (iter != um.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;second &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++iter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：记旧账"><a href="#解法二：记旧账" class="headerlink" title="解法二：记旧账"></a>解法二：记旧账</h2><p>对于当前字符来说，往前一个一个地推字符，如果某个字符出现了两次，那么该字符前一次出现的下标，一定是最长不重复子串起点的下标减一。</p><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间复杂度：<code>O(1)</code></p></li><li><p>时间复杂度：<code>O(n)</code></p></li></ul><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><blockquote><p>参考：<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1730/Shortest-O(n)-DP-solution-with-explanations">https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1730/Shortest-O(n)-DP-solution-with-explanations</a></p></blockquote><div class="note info"><p>因为 <code>char</code> 类型是 8 位，枚举值共有 256 种，所以可以使用 <code>array&lt;int, 256&gt;</code> 代替 <code>unordered_map&lt;char, int&gt;</code> 来实现字符和下标之间的映射。</p></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        array&lt;<span class="keyword">int</span>, 256&gt; arr; arr.<span class="built_in">fill</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, loc = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 等号右边的 `loc`，就是解法中提到的「前一次出现的下标」</span></span><br><span class="line">            <span class="comment">// 等号右边的 `arr[s[i]]`，就是当前字符的「前一次出现的下标」</span></span><br><span class="line">            <span class="comment">// 两者取最大，更新 `loc`，同时 `loc` 也就是：</span></span><br><span class="line">            <span class="comment">// 对于当前字符来说的，最长不重复子串起点的下标减一</span></span><br><span class="line">            loc = <span class="built_in">max</span>(loc, arr[s[i]]);</span><br><span class="line">            <span class="comment">// 计算：对于当前字符来说的，最长不重复子串的长度</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, i-loc);</span><br><span class="line">            <span class="comment">// 更新 `arr[s[i]]`</span></span><br><span class="line">            arr[s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-substring-without-repeating-characters/&quot;&gt;https://leetcode.com/problems/longest-substring-without-repeating-characters/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h3&gt;&lt;p&gt;给定字符串，输出最长不重复子串的长度。&lt;/p&gt;</summary>
    
    
    
    <category term="A3 - LeetCode" scheme="https://progcz.com/categories/A3-LeetCode/"/>
    
    <category term="B1 - LeetCode Problems" scheme="https://progcz.com/categories/A3-LeetCode/B1-LeetCode-Problems/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="String" scheme="https://progcz.com/tags/String/"/>
    
    <category term="Hash Table" scheme="https://progcz.com/tags/Hash-Table/"/>
    
    <category term="Two Pointers" scheme="https://progcz.com/tags/Two-Pointers/"/>
    
    <category term="Sliding Window" scheme="https://progcz.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Problem 2 - Add Two Numbers</title>
    <link href="https://progcz.com/posts/leetcode-problem-add-two-numbers/"/>
    <id>https://progcz.com/posts/leetcode-problem-add-two-numbers/</id>
    <published>2021-02-24T15:54:42.000Z</published>
    <updated>2021-02-26T00:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/add-two-numbers/">https://leetcode.com/problems/add-two-numbers/</a></p><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>将两个数字的每一位，逆序地拆成两个链表 <code>l1</code> 和 <code>l2</code>，计算这两个数字的和，结果以同样顺序的链表表示。</p><span id="more"></span><h2 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h2><p>递归遍历两个输入链表，对应节点相加，<code>%10</code> 的值存入输出链表的对应节点，<code>/10</code> 的值存入输出链表的下一节点。</p><p>边界条件：两个输入链表的对应节点都为空指针。</p><div class="note info"><p>在边界条件下，需要根据下一节点的值是否为 0 而决定是否抛弃该下一节点。为了实现这一点，同时保持代码的 <code>neat</code> 性，传入递归函数的输出链表的对应节点，需要自带下一节点，这就是 C++ 实现中 <code>new ListNode(0, new ListNode(0))</code> 的由来。</p></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(n)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* root = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">helper</span>(l1, l2, root);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(ListNode* l1, ListNode* l2, ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1 &amp;&amp; !l2) &#123;</span><br><span class="line">            node-&gt;next = node-&gt;next-&gt;val ? node-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        <span class="keyword">int</span> sum = node-&gt;val +</span><br><span class="line">            (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>);</span><br><span class="line">        node-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">        node-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum/<span class="number">10</span>);</span><br><span class="line">        l1 = l1 ? l1-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        l2 = l2 ? l2-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(l1, l2, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：循环"><a href="#解法二：循环" class="headerlink" title="解法二：循环"></a>解法二：循环</h2><p>思路基本上与<a href="#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9A%E9%80%92%E5%BD%92">解法一</a>保持一致，只是将递归形式改为循环形式，同时写法上更加 neat。</p><blockquote><p>参考：<a href="https://leetcode.com/problems/add-two-numbers/discuss/997/c++-Sharing-my-11-line-c++-solution-can-someone-make-it-even-more-concise">https://leetcode.com/problems/add-two-numbers/discuss/997/c++-Sharing-my-11-line-c++-solution-can-someone-make-it-even-more-concise</a></p></blockquote><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(n)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode root(0), *node = &amp;root;</span><br><span class="line">        <span class="keyword">int</span> extra = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || extra) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = extra + </span><br><span class="line">                (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>);</span><br><span class="line">            extra = sum/<span class="number">10</span>;</span><br><span class="line">            node-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            l1 = l1 ? l1-&gt;next : l1;</span><br><span class="line">            l2 = l2 ? l2-&gt;next : l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/add-two-numbers/&quot;&gt;https://leetcode.com/problems/add-two-numbers/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h3&gt;&lt;p&gt;将两个数字的每一位，逆序地拆成两个链表 &lt;code&gt;l1&lt;/code&gt; 和 &lt;code&gt;l2&lt;/code&gt;，计算这两个数字的和，结果以同样顺序的链表表示。&lt;/p&gt;</summary>
    
    
    
    <category term="A3 - LeetCode" scheme="https://progcz.com/categories/A3-LeetCode/"/>
    
    <category term="B1 - LeetCode Problems" scheme="https://progcz.com/categories/A3-LeetCode/B1-LeetCode-Problems/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Linked List" scheme="https://progcz.com/tags/Linked-List/"/>
    
    <category term="Math" scheme="https://progcz.com/tags/Math/"/>
    
    <category term="Recursion" scheme="https://progcz.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Problem 1 - Two Sum</title>
    <link href="https://progcz.com/posts/leetcode-problem-two-sum/"/>
    <id>https://progcz.com/posts/leetcode-problem-two-sum/</id>
    <published>2021-02-17T15:48:43.000Z</published>
    <updated>2021-02-19T15:49:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/two-sum/">https://leetcode.com/problems/two-sum/</a></p><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定数组 <code>nums</code> 和数字 <code>target</code>，要求在 <code>nums</code> 中找到两个数字，和为 <code>target</code>，返回这两个数字的下标。</p><p>保证有且只有一个解，而且同一个数字不能用两次。</p><span id="more"></span><h2 id="解法一：两层循环，暴力破解"><a href="#解法一：两层循环，暴力破解" class="headerlink" title="解法一：两层循环，暴力破解"></a>解法一：两层循环，暴力破解</h2><p>两层循环，遍历所有可能的数字组合，找到则返回下标。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(1)</code></p></li><li><p>时间：<code>O(n^2)</code></p></li></ul><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：借助-hash-map，用空间换时间"><a href="#解法二：借助-hash-map，用空间换时间" class="headerlink" title="解法二：借助 hash_map，用空间换时间"></a>解法二：借助 <code>hash_map</code>，用空间换时间</h2><p>既可以使用两次循环：</p><ul><li><p>第一次循环完成「记录」：借助 <code>hash_map</code>，建立数字 <code>target-nums[i]</code> 和下标 <code>i</code> 之间的映射。</p></li><li><p>第二次循环进行「查询」：如果数字 <code>nums[i]</code> 存在于 <code>hash_map</code> 中，而且不是同一数字（下标不同），说明可以「配对」，则返回该数字下标和 <code>hash_map</code> 中记录的另一数字下标。</p></li></ul><p>也可以使用单次循环：</p><ul><li>单次循环合并「记录」和「查询」：如果数字 <code>nums[i]</code> 存在于 <code>hash_map</code> 中，说明可以「配对」，则返回该数字下标和 <code>hash_map</code> 中记录的另一数字下标，否则建立数字 <code>target-nums[i]</code> 和下标 <code>i</code> 之间的映射。</li></ul><blockquote><p>单次循环参考：<a href="https://leetcode.com/problems/two-sum/discuss/13/Accepted-C++-O(n)-Solution/263">https://leetcode.com/problems/two-sum/discuss/13/Accepted-C++-O(n)-Solution/263</a></p></blockquote><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(n)</code>（不太确定）</p></li><li><p>时间：<code>O(n)</code></p><ul><li><code>hash_map</code> 插入、查询、删除的操作，时间复杂度均为 <code>O(1)</code>。</li></ul></li></ul><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><p>两次循环：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; um = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            um[target-nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (um.<span class="built_in">find</span>(nums[i]) != um.<span class="built_in">end</span>() &amp;&amp;</span><br><span class="line">                um[nums[i]] != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;um[nums[i]], i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>单次循环：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; um;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (um.<span class="built_in">find</span>(nums[i]) != um.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;um[nums[i]], i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            um[target-nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/two-sum/&quot;&gt;https://leetcode.com/problems/two-sum/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h3&gt;&lt;p&gt;给定数组 &lt;code&gt;nums&lt;/code&gt; 和数字 &lt;code&gt;target&lt;/code&gt;，要求在 &lt;code&gt;nums&lt;/code&gt; 中找到两个数字，和为 &lt;code&gt;target&lt;/code&gt;，返回这两个数字的下标。&lt;/p&gt;
&lt;p&gt;保证有且只有一个解，而且同一个数字不能用两次。&lt;/p&gt;</summary>
    
    
    
    <category term="A3 - LeetCode" scheme="https://progcz.com/categories/A3-LeetCode/"/>
    
    <category term="B1 - LeetCode Problems" scheme="https://progcz.com/categories/A3-LeetCode/B1-LeetCode-Problems/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Array" scheme="https://progcz.com/tags/Array/"/>
    
    <category term="Hash Table" scheme="https://progcz.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>充满仪式感的「全年总结」和不太可能坚持下去的「新年计划」</title>
    <link href="https://progcz.com/posts/summary-for-past-year-and-plan-for-new-year/"/>
    <id>https://progcz.com/posts/summary-for-past-year-and-plan-for-new-year/</id>
    <published>2021-01-02T12:34:35.000Z</published>
    <updated>2021-01-02T12:34:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>即使新建好了文档，我依然不知道到底该写些什么，但是「写」这个念头就像只怎么也赶不走的乌鸦，一直在我的头顶盘旋。</p><p>也许确实是因为仪式感吧，<strong>每到了辞旧迎新的时候，总该有些「落在纸面」的文字，先跟过去的一年和解，再把自己交代给未来的一年。</strong></p><p>也罢，就让我这个记忆力和行动力都逐渐退化的人，来一场「全年总结」和「新年计划」吧！</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/01.jpg" style="zoom:100%"/><span id="more"></span><h2 id="1-全年总结"><a href="#1-全年总结" class="headerlink" title="1 全年总结"></a>1 全年总结</h2><h3 id="1-1-失去的五个月"><a href="#1-1-失去的五个月" class="headerlink" title="1.1 失去的五个月"></a>1.1 失去的五个月</h3><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/02.jpg" style="zoom:100%"/><p>但凡回顾 2020，疫情是怎么都绕不开的话题。</p><p>不论性别，不论国籍，不论贫穷或富有，不论疾病或健康，只要你还是这颗蓝色星球上的原住民，或多或少都会受到疫情的影响，唯一的区别就在于这个「或多或少」。</p><p>非常幸运，也非常惭愧，我是「或少」中的一员。</p><p>不管是磕磕绊绊但还是顺利完成了的学位答辩，还是在家只吃不动而逐渐狂妄的体重涨幅，在这场全人类都无法幸免的灾难面前，看上去都是小事。</p><p>因此，我始终对在疫情中离开人世的生命感到惋惜，他们一定也在 2020 年伊始时，怀揣着对新年的希望，如今归于尘土；我也始终对在疫情中奋战在一线的医护人员保持敬意，他们以血肉之躯，构筑起保护我们的钢铁长城。</p><div class="note warning"><p>写得越来越像高考作文了。</p><p>Whatever, it’s just the way how i was raised and educated.</p></div><p>不是超级英雄，<strong>只能保护好自己，照顾好家人，足够了。</strong></p><h3 id="1-2-十九年寒窗"><a href="#1-2-十九年寒窗" class="headerlink" title="1.2 十九年寒窗"></a>1.2 十九年寒窗</h3><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/03.jpg" style="zoom:100%"/><p>毕业算是改变人生的事情当中，意外指数最低的事情了吧。</p><p>在这种意义下，与其说是改变人生，<strong>不如说是人生早就被安排成了列车的时刻表，毕业这件事情就在单线轨道的某个站点上等着，没有丝毫悬念。</strong></p><p>虽然，我今年所面临的毕业，与以往的毕业不尽相同：</p><ul><li><p>以往的毕业，从学校到学校，换了环境而已，依然是衣食无忧的学生，终极目标不过是分数、绩点和排名。</p></li><li><p>今年的毕业，从学校到公司，真正意义上的经济独立，终极目标切换成房子、车子和存款。</p></li></ul><p>当然，还是很感谢曾经作为学生的自己，至少为我打好了阶级跃迁的基础，在人生这一新的阶段能多抢跑几秒钟。</p><h3 id="1-3-职场与人生"><a href="#1-3-职场与人生" class="headerlink" title="1.3 职场与人生"></a>1.3 职场与人生</h3><p>互联网大厂的程序员工作，一言以蔽之：节奏快，工作忙，身体累。</p><p>比起初入职场的感想，我更想探讨的是，在人生意义这个问题上的心态转变。</p><p>这是个老生常谈的哲学命题，我明白。但我还是想说说自己的理解。</p><p>过去的二十几年，从我记事开始，我就一直在为别人而活。</p><p>说起来非常简单的生活：作为学生，考试考个好成绩；作为儿女，听长辈的话。这样，父母就会很开心，长辈就会称赞我（不管是不是虚情假意），同学也会尊重我（即便是以对待书呆子的态度）。</p><p>我好像从来没想过，自己想要什么。</p><p>或者说，是周围的人告诉我的「我想要的」：努力学习，努力赚钱，有套自己的房子，有个幸福的家庭。</p><p>直到我开始问我自己：然后呢？这一切之后呢？从生到死，人这一生到底是为了什么呢？</p><p>过去的一年里，我反复地思考人生的意义，在上下班通勤的路上，在漫长而枯燥的旅途中，在每个放纵自己而熬到很困的深夜里。</p><p>而每次我都只能得到同一个答案：<strong>人生的意义是为了开心，为了愉悦的体验，为了舒适的生活。</strong></p><p>又是个老生常谈的答案，我明白。但这次，我是真的相信它了。</p><h2 id="2-新年计划"><a href="#2-新年计划" class="headerlink" title="2 新年计划"></a>2 新年计划</h2><h3 id="2-1-工作"><a href="#2-1-工作" class="headerlink" title="2.1 工作"></a>2.1 工作</h3><p>无他，努力工作，赚钱买房。</p><div class="note warning"><p>但是要牢记的是，身体是革命的本钱！任何事情的达成都不能以牺牲身体健康为前提。</p></div><h3 id="2-2-读书"><a href="#2-2-读书" class="headerlink" title="2.2 读书"></a>2.2 读书</h3><p>在将 kindle 上未读的书目消灭至只有个位数之前，不再囤书了。</p><p>至于数量，不想做硬性要求，只求在有大块时间和舒适状态的时候，能想起来读书，而不是刷手机/看视频。</p><h3 id="2-3-按摩-健身"><a href="#2-3-按摩-健身" class="headerlink" title="2.3 按摩/健身"></a>2.3 按摩/健身</h3><p>每周二按摩，每周四健身。</p><h3 id="2-4-旅游"><a href="#2-4-旅游" class="headerlink" title="2.4 旅游"></a>2.4 旅游</h3><p>希望每年能有一次旅游，实际上 2021 的额度已经分给厦门了，毕竟厦大百年校庆，是时候回去看看了。</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/04.jpg" style="zoom:100%"/><hr><h2 id="3-番外"><a href="#3-番外" class="headerlink" title="3 番外"></a>3 番外</h2><p>新年第一天，去撸了猫猫狗狗，希望能把这份开心延续一整年吧。</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/05.jpg" style="zoom:100%"/>]]></content>
    
    
    <summary type="html">&lt;p&gt;即使新建好了文档，我依然不知道到底该写些什么，但是「写」这个念头就像只怎么也赶不走的乌鸦，一直在我的头顶盘旋。&lt;/p&gt;
&lt;p&gt;也许确实是因为仪式感吧，&lt;strong&gt;每到了辞旧迎新的时候，总该有些「落在纸面」的文字，先跟过去的一年和解，再把自己交代给未来的一年。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也罢，就让我这个记忆力和行动力都逐渐退化的人，来一场「全年总结」和「新年计划」吧！&lt;/p&gt;
&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/01.jpg&quot; style=&quot;zoom:100%&quot;/&gt;</summary>
    
    
    
    <category term="A0 - 总结与计划" scheme="https://progcz.com/categories/A0-%E6%80%BB%E7%BB%93%E4%B8%8E%E8%AE%A1%E5%88%92/"/>
    
    
    <category term="Plan" scheme="https://progcz.com/tags/Plan/"/>
    
    <category term="Summary" scheme="https://progcz.com/tags/Summary/"/>
    
    <category term="Happiness" scheme="https://progcz.com/tags/Happiness/"/>
    
  </entry>
  
  <entry>
    <title>2020 August LeetCoding Challenge - Week 2</title>
    <link href="https://progcz.com/posts/2020-august-leetcoding-challenge-week-2/"/>
    <id>https://progcz.com/posts/2020-august-leetcoding-challenge-week-2/</id>
    <published>2020-08-08T15:36:56.000Z</published>
    <updated>2020-08-16T02:42:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 八月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-August-LeetCoding-Challenge/">2020 August LeetCoding Challenge</a> 查看更多。</p><span id="more"></span><h2 id="August-8th-Path-Sum-III"><a href="#August-8th-Path-Sum-III" class="headerlink" title="August 8th: Path Sum III"></a>August 8th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/550/week-2-august-8th-august-14th/3417/">Path Sum III</a></h2><p>You are given a binary tree in which each node contains an integer value.</p><p>Find the number of paths that sum to a given value.</p><p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p><p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     &#x2F;  \</span><br><span class="line">    5   -3</span><br><span class="line">   &#x2F; \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用函数 <code>func</code> 对树进行深度优先搜索，对以 <code>node</code> 为起点且满足题目要求的路径进行计数。</p><p><code>pathSum(root-&gt;left, sum)</code> 和 <code>pathSum(root-&gt;right, sum)</code> 则是分别给左右节点一次「重新开始」的机会。</p><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(root, sum) + <span class="built_in">pathSum</span>(root-&gt;left, sum) + <span class="built_in">pathSum</span>(root-&gt;right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(TreeNode *node,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = node-&gt;val==sum ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="built_in">func</span>(node-&gt;left, sum-node-&gt;val) + <span class="built_in">func</span>(node-&gt;right, sum-node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>终究还是没能在工作日坚持下来，这个系列终止吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 八月挑战专题每日随缘更新，点击类别 &lt;a href=&quot;/categories/2020-August-LeetCoding-Challenge/&quot;&gt;2020 August LeetCoding Challenge&lt;/a&gt; 查看更多。&lt;/p&gt;</summary>
    
    
    
    <category term="A3 - LeetCode" scheme="https://progcz.com/categories/A3-LeetCode/"/>
    
    <category term="B4 - LeetCoding Challenge" scheme="https://progcz.com/categories/A3-LeetCode/B4-LeetCoding-Challenge/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Data Structure and Algorithm" scheme="https://progcz.com/tags/Data-Structure-and-Algorithm/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Challenge" scheme="https://progcz.com/tags/Challenge/"/>
    
  </entry>
  
  <entry>
    <title>2020 August LeetCoding Challenge - Week 1</title>
    <link href="https://progcz.com/posts/2020-august-leetcoding-challenge-week-1/"/>
    <id>https://progcz.com/posts/2020-august-leetcoding-challenge-week-1/</id>
    <published>2020-08-01T07:37:02.000Z</published>
    <updated>2020-08-08T03:31:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 八月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-August-LeetCoding-Challenge/">2020 August LeetCoding Challenge</a> 查看更多。</p><span id="more"></span><h2 id="August-1st-Detect-Capital"><a href="#August-1st-Detect-Capital" class="headerlink" title="August 1st: Detect Capital"></a>August 1st: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3409/">Detect Capital</a></h2><p>Given a word, you need to judge whether the usage of capitals in it is right or not.</p><p>We define the usage of capitals in a word to be right when one of the following cases holds:</p><ul><li><p>All letters in this word are capitals, like “USA”.</p></li><li><p>All letters in this word are not capitals, like “leetcode”.</p></li><li><p>Only the first letter in this word is capital, like “Google”.</p></li></ul><p>Otherwise, we define that this word doesn’t use capitals in a right way.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;USA&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;FlaG&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> The input will be a non-empty word consisting of uppercase and lowercase latin letters.</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>不管字符串 <code>word</code> 的写法是否正确，我都可以列举出其三种正确的写法，放入集合 <code>s</code> 中，判断最初的 <code>word</code> 是否存在于 <code>s</code> 中即可。</p><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">detectCapitalUse</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;string&gt; s;</span><br><span class="line">        string word_cp = word;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : word_cp) &#123;</span><br><span class="line">            ch = <span class="built_in">tolower</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">insert</span>(word_cp);</span><br><span class="line">        word_cp[<span class="number">0</span>] = <span class="built_in">toupper</span>(word_cp[<span class="number">0</span>]);</span><br><span class="line">        s.<span class="built_in">insert</span>(word_cp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : word_cp) &#123;</span><br><span class="line">            ch = <span class="built_in">toupper</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">insert</span>(word_cp);</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">find</span>(word) != s.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-2nd-Design-HashSet"><a href="#August-2nd-Design-HashSet" class="headerlink" title="August 2nd: Design HashSet"></a>August 2nd: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3410/">Design HashSet</a></h2><p>Design a HashSet without using any built-in hash table libraries.</p><p>To be specific, your design should include these functions:</p><ul><li><p><code>add(value)</code>: Insert a value into the HashSet.</p></li><li><p><code>contains(value)</code>: Return whether the value exists in the HashSet or not.</p></li><li><p><code>remove(value)</code>: Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing.</p></li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyHashSet hashSet &#x3D; new MyHashSet();</span><br><span class="line">hashSet.add(1);</span><br><span class="line">hashSet.add(2);</span><br><span class="line">hashSet.contains(1);    &#x2F;&#x2F; returns true</span><br><span class="line">hashSet.contains(3);    &#x2F;&#x2F; returns false (not found)</span><br><span class="line">hashSet.add(2);</span><br><span class="line">hashSet.contains(2);    &#x2F;&#x2F; returns true</span><br><span class="line">hashSet.remove(2);</span><br><span class="line">hashSet.contains(2);    &#x2F;&#x2F; returns false (already removed)</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p>All values will be in the range of <code>[0, 1000000]</code>.</p></li><li><p>The number of operations will be in the range of <code>[1, 10000]</code>.</p></li><li><p>Please do not use the built-in HashSet library.</p></li></ul><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>采用哈希函数 + 单向链表，将 <code>key</code> 取模后在链表中添加、删除和查找。</p><p>P.S. 空间换时间，当然可以把 <code>mod</code> 直接赋值为 <code>1000001</code>。</p><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyHashSet</span>() : <span class="built_in">mod</span>(<span class="number">1000</span>) &#123;</span><br><span class="line">        v.<span class="built_in">resize</span>(mod);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        v[key%mod].<span class="built_in">push_front</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        v[key%mod].<span class="built_in">remove</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;val : v[key%mod]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mod;</span><br><span class="line">    vector&lt;forward_list&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyHashSet* obj = new MyHashSet();</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;remove(key);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;contains(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="August-3rd-Valid-Palindrome"><a href="#August-3rd-Valid-Palindrome" class="headerlink" title="August 3rd: Valid Palindrome"></a>August 3rd: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3411/">Valid Palindrome</a></h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p><strong>Note:</strong> For the purpose of this problem, we define empty string as valid palindrome.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;race a car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>s</code> consists only of printable ASCII characters.</li></ul><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用首尾指针 <code>beg</code> 和 <code>end</code> 进行比较，如果不是数字或字母，直接跳过。</p><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> beg = <span class="number">0</span>, end = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (beg &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(s[beg])) &#123;</span><br><span class="line">                ++beg;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(s[end])) &#123;</span><br><span class="line">                --end;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[beg]) != <span class="built_in">tolower</span>(s[end])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++beg;</span><br><span class="line">            --end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-4th-Power-of-Four"><a href="#August-4th-Power-of-Four" class="headerlink" title="August 4th: Power of Four"></a>August 4th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3412/">Power of Four</a></h2><p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 16</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>每次累乘 4，实际上都是将二进制形式左移 2 位，循环判断即可。</p><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-5th-Add-and-Search-Word-Data-structure-design"><a href="#August-5th-Add-and-Search-Word-Data-structure-design" class="headerlink" title="August 5th: Add and Search Word - Data structure design"></a>August 5th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3413/">Add and Search Word - Data structure design</a></h2><p>Design a data structure that supports the following two operations:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void addWord(word)</span><br><span class="line">bool search(word)</span><br></pre></td></tr></table></figure><p>search(word) can search a literal word or a regular expression string containing only letters <code>a-z</code> or <code>.</code>. A <code>.</code> means it can represent any one letter.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addWord(&quot;bad&quot;)</span><br><span class="line">addWord(&quot;dad&quot;)</span><br><span class="line">addWord(&quot;mad&quot;)</span><br><span class="line">search(&quot;pad&quot;) -&gt; false</span><br><span class="line">search(&quot;bad&quot;) -&gt; true</span><br><span class="line">search(&quot;.ad&quot;) -&gt; true</span><br><span class="line">search(&quot;b..&quot;) -&gt; true</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>You may assume that all words are consist of lowercase letters <code>a-z</code>.</p><h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用 <code>um</code> 建立从字符串长度至字符串数组的映射，从而在查询的时候降低时间复杂度。妙啊。</p><h4 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">WordDictionary</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds a word into the data structure. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        um[word.<span class="built_in">size</span>()].<span class="built_in">push_back</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character &#x27;.&#x27; to represent any one letter. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str : um[word.<span class="built_in">size</span>()]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">is_match</span>(str, word)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_match</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[i] == <span class="string">&#x27;.&#x27;</span> || word2[i] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (word1[i] != word2[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, vector&lt;string&gt;&gt; um;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary* obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addWord(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="August-6th-Find-All-Duplicates-in-an-Array"><a href="#August-6th-Find-All-Duplicates-in-an-Array" class="headerlink" title="August 6th: Find All Duplicates in an Array"></a>August 6th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3414/">Find All Duplicates in an Array</a></h2><p>Given an array of integers, <code>1 ≤ a[i] ≤ n</code> (<code>n</code> = size of array), some elements appear <strong>twice</strong> and others appear <strong>once</strong>.</p><p>Find all the elements that appear <strong>twice</strong> in this array.</p><p>Could you do it without extra space and in <code>O(n)</code> runtime?</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[2,3]</span><br></pre></td></tr></table></figure><h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>没啥好说的，直接看代码吧。</p><h4 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; um;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            ++um[num];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : um) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t.second == <span class="number">2</span>) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(t.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-7th-Vertical-Order-Traversal-of-a-Binary-Tree"><a href="#August-7th-Vertical-Order-Traversal-of-a-Binary-Tree" class="headerlink" title="August 7th: Vertical Order Traversal of a Binary Tree"></a>August 7th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3415/">Vertical Order Traversal of a Binary Tree</a></h2><p>Given a binary tree, return the vertical order traversal of its nodes values.</p><p>For each node at position <code>(X, Y)</code>, its left and right children respectively will be at positions <code>(X-1, Y-1)</code> and <code>(X+1, Y-1)</code>.</p><p>Running a vertical line from <code>X = -infinity</code> to <code>X = +infinity</code>, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing <code>Y</code> coordinates).</p><p>If two nodes have the same position, then the value of the node that is reported first is the value that is smaller.</p><p>Return an list of non-empty reports in order of <code>X</code> coordinate.  Every report will have a list of values of nodes.</p><p><strong>Example 1:</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/06.png" style="zoom:100%"/><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[9],[3,15],[20],[7]]</span><br><span class="line">Explanation:</span><br><span class="line">Without loss of generality, we can assume the root node is at position (0, 0):</span><br><span class="line">Then, the node with value 9 occurs at position (-1, -1);</span><br><span class="line">The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2);</span><br><span class="line">The node with value 20 occurs at position (1, -1);</span><br><span class="line">The node with value 7 occurs at position (2, -2).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/07.png" style="zoom:50%"/><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7]</span><br><span class="line">Output: [[4],[2],[1,5,6],[3],[7]]</span><br><span class="line">Explanation:</span><br><span class="line">The node with value 5 and the node with value 6 have the same position according to the given scheme.</span><br><span class="line">However, in the report &quot;[1,5,6]&quot;, the node value of 5 comes first since 5 is smaller than 6.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><p>The tree will have between <code>1</code> and <code>1000</code> nodes.</p></li><li><p>Each node’s value will be between <code>0</code> and <code>1000</code>.</p></li></ol><h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，核心在于这个声明：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;&gt; m;</span><br></pre></td></tr></table></figure><p><strong>第一个 <code>int</code> 代表节点的 <code>x</code> 坐标，第二个 <code>int</code> 代表节点的 <code>y</code> 坐标，<code>vector&lt;int&gt;</code> 存放节点的值；而且，<code>x</code> 坐标按照默认升序排列，<code>y</code> 坐标按照指定降序排列，适应题目要求。</strong></p><p>其次，使用函数 <code>func</code> 遍历树，存放至对应的 <code>vector&lt;int&gt;</code> 中。</p><p>最后，遍历 <code>m</code>，将 <code>x</code> 坐标相同的点合并到 <code>v</code> 中，组织为 <code>res</code> 即可。</p><h4 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">verticalTraversal</span>(TreeNode* root) &#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;&gt; m;</span><br><span class="line">        <span class="built_in">func</span>(root, <span class="number">0</span>, <span class="number">0</span>, m);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> imp : m) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> ivp : imp.second) &#123;</span><br><span class="line">                <span class="built_in">sort</span>(ivp.second.<span class="built_in">begin</span>(), ivp.second.<span class="built_in">end</span>());</span><br><span class="line">                v.<span class="built_in">insert</span>(v.<span class="built_in">end</span>(), ivp.second.<span class="built_in">begin</span>(), ivp.second.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(TreeNode *node, <span class="keyword">int</span> x, <span class="keyword">int</span> y,</span></span></span><br><span class="line"><span class="function"><span class="params">              map&lt;<span class="keyword">int</span>, map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;&gt; &amp;m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        m[x][y].<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="built_in">func</span>(node-&gt;left, x<span class="number">-1</span>, y<span class="number">-1</span>, m);</span><br><span class="line">        <span class="built_in">func</span>(node-&gt;right, x+<span class="number">1</span>, y<span class="number">-1</span>, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 八月挑战专题每日随缘更新，点击类别 &lt;a href=&quot;/categories/2020-August-LeetCoding-Challenge/&quot;&gt;2020 August LeetCoding Challenge&lt;/a&gt; 查看更多。&lt;/p&gt;</summary>
    
    
    
    <category term="A3 - LeetCode" scheme="https://progcz.com/categories/A3-LeetCode/"/>
    
    <category term="B4 - LeetCoding Challenge" scheme="https://progcz.com/categories/A3-LeetCode/B4-LeetCoding-Challenge/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Data Structure and Algorithm" scheme="https://progcz.com/tags/Data-Structure-and-Algorithm/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Challenge" scheme="https://progcz.com/tags/Challenge/"/>
    
  </entry>
  
  <entry>
    <title>我的工作桌面长啥样</title>
    <link href="https://progcz.com/posts/what-does-my-work-desktop-look-like/"/>
    <id>https://progcz.com/posts/what-does-my-work-desktop-look-like/</id>
    <published>2020-08-01T07:11:15.000Z</published>
    <updated>2021-05-31T00:57:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉，已经入职两个月了。</p><p>在这两个月里，我一直在适应工作节奏，所以没有时间更新博客（虽然也没什么人看）。</p><p>在这两个月里，我的工作桌面也在不断进化，不断适应我的使用习惯，到现在也算是个初级形态了，所以打算在这里梳理一下（其实就是想晒装备）。</p><p>先来张工作桌面的整体照片过过瘾：</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/00.png" style="zoom:100%"/><span id="more"></span><h2 id="1-「公司发的」MacBook-Pro-16"><a href="#1-「公司发的」MacBook-Pro-16" class="headerlink" title="1 「公司发的」MacBook Pro 16"></a>1 「公司发的」MacBook Pro 16</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/01.png" style="zoom:100%"/><p>整个桌面都是围绕着 MacBook Pro 16 来布置的，具体配置：</p><table><thead><tr><th>条目</th><th>明细</th></tr></thead><tbody><tr><td>处理器</td><td>2.6 GHz 6‑core Intel Core i7</td></tr><tr><td>图形卡-1</td><td>AMD Radeon Pro 5300M 4 GB</td></tr><tr><td>图形卡-2</td><td>Intel UHD Graphics 630 1536 MB</td></tr><tr><td>内存</td><td>16 GB 2667 MHz DDR4</td></tr><tr><td>储存空间</td><td>512 GB SSD</td></tr></tbody></table><p>我已经过了那个对配置敏感的年纪，拿到这个电脑之后也只会感叹「好漂亮」和「好流畅」了。</p><p>在日常开发中，MacBook Pro 的性能确实绰绰有余，毕竟编译之类的苦差事都是在远程开发机上完成的，本地只是开开 Chrome 和 VS Code 而已。</p><p>P.S. 散热架也是公司发的，感觉薅了太多羊毛。</p><h2 id="2-「公司发的」Dell-U2720Q-4K-显示器"><a href="#2-「公司发的」Dell-U2720Q-4K-显示器" class="headerlink" title="2 「公司发的」Dell U2720Q 4K 显示器"></a>2 「公司发的」Dell U2720Q 4K 显示器</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/02.png" style="zoom:100%"/><p>两台 4K 显示器的幸福，我以前无法想象，现在除了开会和回家以外，MacBook Pro 基本上都是合盖的状态，因为两个显示器已经够我看的了，多了怕鼠标都挪不过来。</p><p>另外一个让人感到幸福的细节，就是可以使用单根 Type-C 数据线合并「显示」、「充电」和「扩展」的功能，显示器的下行接口可以外接键盘和鼠标，极大地节约了 MacBook Pro 的接口数量。</p><p>但是我有两台显示器，为了达到显示的最佳效果，还是不可避免地占用了 MacBook Pro 的两个接口。</p><h2 id="3-「自己买的」DURGOD-TAURUS-K320-茶轴机械键盘"><a href="#3-「自己买的」DURGOD-TAURUS-K320-茶轴机械键盘" class="headerlink" title="3 「自己买的」DURGOD TAURUS K320 茶轴机械键盘"></a>3 「自己买的」DURGOD TAURUS K320 茶轴机械键盘</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/03.png" style="zoom:100%"/><p>当时买这款机械键盘，主要是看中了 PBT 键帽，长期使用不打油的体验也是非常幸福。</p><h2 id="4-「自己买的」Logitech-MX-Master-2S-无线蓝牙鼠标"><a href="#4-「自己买的」Logitech-MX-Master-2S-无线蓝牙鼠标" class="headerlink" title="4 「自己买的」Logitech MX Master 2S 无线蓝牙鼠标"></a>4 「自己买的」Logitech MX Master 2S 无线蓝牙鼠标</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/04.png" style="zoom:50%"/><p>不解释，办公神器。</p><h2 id="5-「自己买的」AirPods-2-无线蓝牙耳机"><a href="#5-「自己买的」AirPods-2-无线蓝牙耳机" class="headerlink" title="5 「自己买的」AirPods 2 无线蓝牙耳机"></a>5 「自己买的」AirPods 2 无线蓝牙耳机</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/05.png" style="zoom:25%"/><p>MacBook Pro 的耳机孔在右侧，使用的有线耳机总是和使用鼠标的手发生干涉，所以我就入手了 AirPods，在一众无线蓝牙耳机中算是最省心的选择了，连接、音质和通话质量都足够稳定，别无他求。</p><h2 id="6-写在最后"><a href="#6-写在最后" class="headerlink" title="6 写在最后"></a>6 写在最后</h2><p>之前在 V2EX 看到一句话，与君共勉：</p><blockquote><p>入职以后，公司给每位员工发了一台电脑，表面上看是每个人拥有了一台电脑，其实是给每台电脑配了一个人。</p></blockquote><hr><h2 id="7-更新（2020-11-26）"><a href="#7-更新（2020-11-26）" class="headerlink" title="7 更新（2020-11-26）"></a>7 更新（2020-11-26）</h2><p>惯例，先放张工作桌面 2.0 的整体照片：</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/11/00.jpg" style="zoom:100%"/><p>改动：</p><ul><li><p>常年合盖使用的 MBP 被我挪到了左侧，这样键盘就可以向前推进，得到伸展的手臂感觉舒适了许多。</p></li><li><p>两个显示器都用包装盒架起了一定的高度，仰在椅子上的时候视线更加舒服了。</p></li><li><p>AirPods 2 =&gt; AirPods Pro，网吧工位少不了降噪。</p></li></ul><h2 id="8-更新（2021-05-31）"><a href="#8-更新（2021-05-31）" class="headerlink" title="8 更新（2021-05-31）"></a>8 更新（2021-05-31）</h2><p>可能是最终形态的工作桌面 3.0：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/11.png"></p><p>改动：</p><ul><li><p>MBP 16 背着实在有点重，换成 MBP 13</p></li><li><p>双屏虽然爽，但是没啥用，所以归还其中一个显示器，只看正面的显示器</p></li><li><p>键盘从杜咖茶轴换成阿米洛红轴，键位与 Mac 自带键盘保持一致</p></li><li><p>常年用鼠标，右手手指关节十分痛苦，所以换成妙控板，左右手交替操作</p></li><li><p>手机换成 iPhone 12 mini，和 AirPods Pro 都可以无线充电，所以买了绿联的无线充电板，随用随充</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;不知不觉，已经入职两个月了。&lt;/p&gt;
&lt;p&gt;在这两个月里，我一直在适应工作节奏，所以没有时间更新博客（虽然也没什么人看）。&lt;/p&gt;
&lt;p&gt;在这两个月里，我的工作桌面也在不断进化，不断适应我的使用习惯，到现在也算是个初级形态了，所以打算在这里梳理一下（其实就是想晒装备）。&lt;/p&gt;
&lt;p&gt;先来张工作桌面的整体照片过过瘾：&lt;/p&gt;
&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/00.png&quot; style=&quot;zoom:100%&quot;/&gt;</summary>
    
    
    
    <category term="A1 - 生活随笔" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="B2 - 折腾" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/B2-%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="Work" scheme="https://progcz.com/tags/Work/"/>
    
    <category term="Desktop" scheme="https://progcz.com/tags/Desktop/"/>
    
    <category term="MacBook Pro" scheme="https://progcz.com/tags/MacBook-Pro/"/>
    
  </entry>
  
  <entry>
    <title>记录一次在上海租房的经历</title>
    <link href="https://progcz.com/posts/record-for-rent-in-shanghai/"/>
    <id>https://progcz.com/posts/record-for-rent-in-shanghai/</id>
    <published>2020-06-13T07:08:48.000Z</published>
    <updated>2020-06-13T07:08:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>入职之前，我预留了一周的时间用来租房，本以为做好了充足的准备，但还是碰到了很多「租房新手」必踩的坑。果然，<strong>小马还是要自己过一遍河才能知道河水的深浅。</strong></p><p>所以，趁着自己的记忆还够新鲜，记录一下这次在上海租房的经历，为以后的自己留下亿点经验和教训。</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/06/00.png" style="zoom:100%"/><span id="more"></span><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1 需求"></a>1 需求</h2><p>在租房之前，需要<strong>梳理一遍自己的需求，哪些是必不可少的，哪些是可以妥协的。</strong></p><p>当然，下面列出的这些需求仅适用于我个人，读者需要自行甄别。</p><h3 id="1-1-必不可少的"><a href="#1-1-必不可少的" class="headerlink" title="1.1 必不可少的"></a>1.1 必不可少的</h3><div class="note warning"><p>对于「必不可少的」需求，一旦确定之后，即便中介再怎么花言巧语，也不能有半点动摇。</p></div><ul><li><p><strong>距离公司的步行时间不超过 15 分钟，</strong>能够有效提升幸福感。</p></li><li><p><strong>房子不在一楼或顶楼，</strong>避免一楼的过于潮湿和顶楼的过冷过热。</p></li><li><p><strong>房间的装修时间至少在一年以上，</strong>避免存在甲醛和苯等污染问题。</p><p>我刚开始租的就是新装修了一个月的房间，年少无知的我觉得只要通风就好了，结果在房间里面待了几个小时之后，嗓子就开始不舒服。所以，我只租了几天，就直接与房东违约，押金自然要不回来了，肉疼但还是保命要紧。</p></li><li><p><strong>独立卫生间，不必与他人分享马桶和浴室，</strong>不管从时间还是空间的角度，都能够有效提升幸福感。</p><p>预算充足的话，可以考虑<strong>「整租」独立的一居室</strong>；预算有限的话，可以考虑<strong>「合租」带独卫的卧室</strong>。</p></li><li><p><strong>家具和家电：床、空调、衣柜、洗衣机、热水器。</strong></p></li></ul><h3 id="1-2-可以妥协的"><a href="#1-2-可以妥协的" class="headerlink" title="1.2 可以妥协的"></a>1.2 可以妥协的</h3><ul><li><p><strong>可以晾衣服的地方。</strong></p><p>预算充足的话，可以考虑<strong>朝南阳台</strong>；预算有限的话，可以考虑<strong>朝南外窗（带外置晾衣架）</strong>。</p><p>当然，朝北也是可以的，毕竟洗衣机甩干后的衣服只要再风干就可以了。</p></li><li><p><strong>厨房。</strong></p></li><li><p><strong>家具和家电：冰箱、电视、沙发。</strong></p></li></ul><h3 id="1-3-其他"><a href="#1-3-其他" class="headerlink" title="1.3 其他"></a>1.3 其他</h3><h4 id="1-3-1-关于二房东"><a href="#1-3-1-关于二房东" class="headerlink" title="1.3.1 关于二房东"></a>1.3.1 关于二房东</h4><p>我之前看过的很多租房攻略都有提到：千万不要租二房东的房子。</p><p>但是，其实有相当一部分的房源都来自<strong>「职业」二房东</strong>，这种二房东并不是真正的租客，而是因为原房东手中有闲置的房子而又怕麻烦，于是将房子出租给二房东，由二房东来管理出租的事情。真正应该避开的是<strong>「非职业」二房东</strong>，这种二房东是真正的租客，但是因为某些原因而不得已将其转租，在这种情况下就很难保障自己的租房权益。</p><p>所以，可以要求<strong>查看二房东的原租房合同和原房东的房产证。</strong>查看租房合同是否长达数年，就可以大致判断是否为「职业」二房东。而且，查看租房合同的开始日期，也可以大致判断房间的装修时间。</p><h4 id="1-3-2-关于隔断"><a href="#1-3-2-关于隔断" class="headerlink" title="1.3.2 关于隔断"></a>1.3.2 关于隔断</h4><p>预算有限的话，一般只能考虑隔断的房间了。但是，隔断属于违规建筑，其最大的风险在于<strong>房间可能随时会被政府强拆。</strong></p><p>所以，可以要求<strong>在租房合同中注明：如果房间因为违规建筑而导致乙方无法居住，那么不算乙方违约，甲方需退还押金和剩余租金。</strong></p><div class="note info"><p>问：如何判断隔断？</p><p>答：实地看房时敲一下四周的墙。如果声音很闷，就是原装的墙，如果声音很响，就是隔断的墙。</p></div><h2 id="2-找房"><a href="#2-找房" class="headerlink" title="2 找房"></a>2 找房</h2><h3 id="2-1-短租"><a href="#2-1-短租" class="headerlink" title="2.1 短租"></a>2.1 短租</h3><p>我没有短租过，但是个人感觉短租的话直接选择<strong>自如或蛋壳</strong>即可，省心省力且价格也没有高很多。</p><p>但是，自如或蛋壳被人诟病最多的就是污染问题，所以需要实地看房，感受一下房间内的空气质量。</p><h3 id="2-2-长租"><a href="#2-2-长租" class="headerlink" title="2.2 长租"></a>2.2 长租</h3><p>长租的话还是建议找当地的<strong>大中介</strong>，比如链家、我爱我家等。</p><h2 id="3-看房"><a href="#3-看房" class="headerlink" title="3 看房"></a>3 看房</h2><p>这一步主要是看房间是否满足需求，同时检查一下房间内设施的基本情况，包括但不仅限于：</p><ul><li><p>检查是否新装修，是否存在污染问题。</p></li><li><p>检查防盗门、窗户是否完好。</p></li><li><p>检查家具、家电是否老化。</p></li><li><p>检查水管是否通畅、电路是否老化。</p></li><li><p>检查卫生情况。</p></li></ul><h2 id="4-签订合同"><a href="#4-签订合同" class="headerlink" title="4 签订合同"></a>4 签订合同</h2><p>大中介的合同一般没有什么问题，只是需要注意以下几点：</p><ul><li><p><strong>明确费用明细，</strong>包括但不仅限于：押金、房租、中介费、服务费、物业费、水电费、煤气费、宽带费、维修费等。</p></li><li><p><strong>明确房东和房客的违约条款。</strong></p></li><li><p><strong>拍照或录像记录房间内设施的基本情况，</strong>避免后续的维修纠纷。</p></li><li><p><strong>（独居女生尤其注意）与房东沟通是否可以换锁。</strong></p></li><li><p><strong>与房东当面签订合同，拍照留存房东的身份证、房产证，如果是二房东，拍照留存二房东的原租房合同和原房东的身份证、房产证。</strong></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;入职之前，我预留了一周的时间用来租房，本以为做好了充足的准备，但还是碰到了很多「租房新手」必踩的坑。果然，&lt;strong&gt;小马还是要自己过一遍河才能知道河水的深浅。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，趁着自己的记忆还够新鲜，记录一下这次在上海租房的经历，为以后的自己留下亿点经验和教训。&lt;/p&gt;
&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/06/00.png&quot; style=&quot;zoom:100%&quot;/&gt;</summary>
    
    
    
    <category term="A1 - 生活随笔" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="B1 - 经历" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/B1-%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="Life" scheme="https://progcz.com/tags/Life/"/>
    
    <category term="Shanghai" scheme="https://progcz.com/tags/Shanghai/"/>
    
    <category term="Rent" scheme="https://progcz.com/tags/Rent/"/>
    
  </entry>
  
  <entry>
    <title>记录使用 IFTTT + Telegram 订阅 RSS 的推送模板</title>
    <link href="https://progcz.com/posts/record-use-ifttt-tg-sub-rss-push-template/"/>
    <id>https://progcz.com/posts/record-use-ifttt-tg-sub-rss-push-template/</id>
    <published>2020-05-24T10:30:11.000Z</published>
    <updated>2020-05-24T10:30:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于大部分使用 RSS 的人来说，RSS 最大的优势便是能够提供<strong>「聚合阅读」</strong>的功能，也就是在一个地方阅读多篇不同来源的文章，而且可以自主选择订阅源，拒绝推荐引擎的「投喂」。然而对于我来说，RSS 还有一个重要的作用在于能够提供<strong>「即时通知」</strong>的功能，也就是<strong>「一旦发生了什么，请立刻通知我」</strong>。</p><p>所以，为了实现<strong>「即时通知」</strong>的功能，<strong>可以使用 IFTTT 将 RSS 订阅内容推送至 Telegram 的对话、群组或公开频道，形成属于自己的「信息流」。</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/10.png" style="zoom:100%"/><span id="more"></span><h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0 写在前面"></a>0 写在前面</h2><p>本文不介绍具体教程，只记录其中使用的推送模板，留作以后参考。</p><p><strong>如果你想了解具体教程，推荐参考<a href="https://sword.studio/157.html">这篇文章</a>。</strong></p><p>另外，<strong>如果你也使用 <a href="https://docs.rsshub.app/">RSSHub</a>，推荐参考<a href="https://docs.rsshub.app/install/#bu-shu-dao-vercel-zeit-now">官方文档</a>将其部署至 <a href="https://vercel.com/">Vercel</a>，</strong>从而搭建属于自己的订阅引擎。</p><h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1 应用场景"></a>1 应用场景</h2><p>在 Telegram 中，我创建了两个公开频道，分别是：</p><ul><li><p><strong><a href="https://t.me/ProgCZChannel">ProgCZ’s Blog - Channel</a> 用于同步本博客更新的文章。</strong></p></li><li><p><strong><a href="https://t.me/ProgCZFlow">ProgCZ’s Flow</a> 用于建立专属于自己的信息流。</strong></p></li></ul><h2 id="2-推送模板"><a href="#2-推送模板" class="headerlink" title="2 推送模板"></a>2 推送模板</h2><p>在 IFTTT 中，需要设置推送模板，分为两种情况：</p><ul><li><p><strong>对于内容较多的订阅源（比如博客文章），只是推送其标题、链接和来源，</strong>模板如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标题：&lt;b&gt;&#123;&#123;EntryTitle&#125;&#125;&lt;&#x2F;b&gt;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">链接：&lt;b&gt;&#123;&#123;EntryUrl&#125;&#125;&lt;&#x2F;b&gt;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">来自：&lt;a href&#x3D;&quot;&#123;&#123;FeedUrl&#125;&#125;&quot;&gt;&#123;&#123;FeedTitle&#125;&#125;&lt;&#x2F;a&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure><p>同时，<strong>开启「网页预览」功能。</strong></p></li><li><p><strong>对于内容较少的订阅源（比如购物优惠），推送其标题、内容、链接和来源，</strong>模板如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标题：&lt;b&gt;&#123;&#123;EntryTitle&#125;&#125;&lt;&#x2F;b&gt;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&#123;&#123;EntryContent&#125;&#125;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">链接：&lt;b&gt;&#123;&#123;EntryUrl&#125;&#125;&lt;&#x2F;b&gt;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">来自：&lt;a href&#x3D;&quot;&#123;&#123;FeedUrl&#125;&#125;&quot;&gt;&#123;&#123;FeedTitle&#125;&#125;&lt;&#x2F;a&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure><p>同时，<strong>关闭「网页预览」功能。</strong></p></li></ul><h2 id="3-预览效果"><a href="#3-预览效果" class="headerlink" title="3 预览效果"></a>3 预览效果</h2><p>如果你想预览效果，可以在科学环境中访问 <a href="https://t.me/s/ProgCZChannel">ProgCZ’s Blog - Channel</a> 和 <a href="https://t.me/s/ProgCZFlow">ProgCZ’s Flow</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于大部分使用 RSS 的人来说，RSS 最大的优势便是能够提供&lt;strong&gt;「聚合阅读」&lt;/strong&gt;的功能，也就是在一个地方阅读多篇不同来源的文章，而且可以自主选择订阅源，拒绝推荐引擎的「投喂」。然而对于我来说，RSS 还有一个重要的作用在于能够提供&lt;strong&gt;「即时通知」&lt;/strong&gt;的功能，也就是&lt;strong&gt;「一旦发生了什么，请立刻通知我」&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以，为了实现&lt;strong&gt;「即时通知」&lt;/strong&gt;的功能，&lt;strong&gt;可以使用 IFTTT 将 RSS 订阅内容推送至 Telegram 的对话、群组或公开频道，形成属于自己的「信息流」。&lt;/strong&gt;&lt;/p&gt;
&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/10.png&quot; style=&quot;zoom:100%&quot;/&gt;</summary>
    
    
    
    <category term="A1 - 生活随笔" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="B2 - 折腾" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/B2-%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="IFTTT" scheme="https://progcz.com/tags/IFTTT/"/>
    
    <category term="Telegram" scheme="https://progcz.com/tags/Telegram/"/>
    
    <category term="RSS" scheme="https://progcz.com/tags/RSS/"/>
    
  </entry>
  
  <entry>
    <title>使用 Cloudflare Workers 搭建 Google 和 GitHub 镜像网站</title>
    <link href="https://progcz.com/posts/use-cf-workers-build-google-and-github-mirrors/"/>
    <id>https://progcz.com/posts/use-cf-workers-build-google-and-github-mirrors/</id>
    <published>2020-05-23T13:32:58.000Z</published>
    <updated>2020-05-23T13:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于 Google 来说，虽然大部分时间都能够在科学环境中网上冲浪，但是<strong>难免有需要在普通环境中使用 Google 的情况，</strong>而对于 GitHub 来说，虽然目前可以无障碍访问，但是<strong>在普通环境中下载某些 Release（比如科学工具的客户端）的速度实在太慢。</strong></p><p>如果你也有和我一样的困扰，那么可以考虑<strong>使用 Cloudflare Workers 搭建属于自己的镜像网站，</strong>在普通环境中备用。</p><span id="more"></span><h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0 写在前面"></a>0 写在前面</h2><p>如果你只是在寻找临时的解决方案，而又不想费劲的话，那么可以直接使用我已经搭建好的镜像网站。</p><div class="note warning"><p>但是，请你务必遵守以下约定：</p><ol><li><p><strong>不滥用服务。</strong>因为每个 Cloudflare 账户每天只有 100,000 次请求的额度。</p></li><li><p><strong>不登录自己的任何账号。</strong>虽然我保证不拦截你的数据，但是防人之心不可无。</p></li><li><p><strong>不违反大陆的法律法规。</strong>虽然你需要科学，但是请保持理性。</p></li></ol></div><ul><li><p>Google 镜像网站：<a href="https://google.progcz.workers.dev/">https://google.progcz.workers.dev/</a></p></li><li><p>GitHub 镜像网站：<a href="https://github.progcz.workers.dev/">https://github.progcz.workers.dev/</a></p></li></ul><h2 id="1-注册并登录-Cloudflare-账号"><a href="#1-注册并登录-Cloudflare-账号" class="headerlink" title="1 注册并登录 Cloudflare 账号"></a>1 注册并登录 Cloudflare 账号</h2><p>这没啥好说的，前往 <a href="https://www.cloudflare.com/">Cloudflare 官网</a>自行注册并登录，然后<strong>点击「Workers」。</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/06.png" style="zoom:100%"/><h2 id="2-创建新的-Worker-应用"><a href="#2-创建新的-Worker-应用" class="headerlink" title="2 创建新的 Worker 应用"></a>2 创建新的 Worker 应用</h2><p>进入 Workers 页面之后，新用户需要设置用户名（比如 <code>progcz</code>），然后<strong>点击「创建 Worker」。</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/07.png" style="zoom:100%"/><h2 id="3-部署-Worker-应用"><a href="#3-部署-Worker-应用" class="headerlink" title="3 部署 Worker 应用"></a>3 部署 Worker 应用</h2><p><strong>自行修改应用名（比如 <code>test</code>），将 <a href="https://github.com/ProgCZ/code-cloud-a/blob/master/2020/05/cf-workers-mirrors/index.js">index.js</a> 中的代码拷贝至脚本中，点击「保存并部署」，</strong>然后就可以通过 <a href="https://test.progcz.workers.dev/">https://test.progcz.workers.dev/</a>（注意替换应用名 <code>test</code> 和用户名 <code>progcz</code>）访问 Google 的镜像网站了。</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/08.png" style="zoom:100%"/><h2 id="4-自定义-index-js-脚本"><a href="#4-自定义-index-js-脚本" class="headerlink" title="4 自定义 index.js 脚本"></a>4 自定义 index.js 脚本</h2><div class="note info"><p>上文的 <a href="https://github.com/ProgCZ/code-cloud-a/blob/master/2020/05/cf-workers-mirrors/index.js">index.js</a> 其实来自于 <a href="https://github.com/Berkeley-Reject/Workers-Proxy">Berkeley-Reject/Workers-Proxy</a> 仓库，但是代码中设置了对于国内访问的屏蔽，所以为了避免误用，我就在自行修改之后保存了一份。</p></div><p>可以通过修改以下部分来搭建不同的镜像网站：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Website you intended to retrieve for users.</span></span><br><span class="line"><span class="keyword">const</span> upstream = <span class="string">&#x27;www.google.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Custom pathname for the upstream website.</span></span><br><span class="line"><span class="keyword">const</span> upstream_path = <span class="string">&#x27;/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Website you intended to retrieve for users using mobile devices.</span></span><br><span class="line"><span class="keyword">const</span> upstream_mobile = <span class="string">&#x27;www.google.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Countries and regions where you wish to suspend your service.</span></span><br><span class="line"><span class="keyword">const</span> blocked_region = [<span class="string">&#x27;KP&#x27;</span>, <span class="string">&#x27;SY&#x27;</span>, <span class="string">&#x27;PK&#x27;</span>, <span class="string">&#x27;CU&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// IP addresses which you wish to block from using your service.</span></span><br><span class="line"><span class="keyword">const</span> blocked_ip_address = [<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Whether to use HTTPS protocol for upstream address.</span></span><br><span class="line"><span class="keyword">const</span> https = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Whether to disable cache.</span></span><br><span class="line"><span class="keyword">const</span> disable_cache = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace texts.</span></span><br><span class="line"><span class="keyword">const</span> replace_dict = &#123;</span><br><span class="line">    <span class="string">&#x27;$upstream&#x27;</span>: <span class="string">&#x27;$custom_domain&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;//google.com&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p>需要注意的是，上述代码只是 <a href="https://github.com/ProgCZ/code-cloud-a/blob/master/2020/05/cf-workers-mirrors/index.js">index.js</a> 的一小部分。</p></div><p>比如，对于 GitHub 来说，我们只需要<strong>将 <code>upstream</code>、<code>upstream_mobile</code> 和 <code>replace_dict</code> 中的 <code>google.com</code> 修改为 <code>github.com</code> 即可。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于 Google 来说，虽然大部分时间都能够在科学环境中网上冲浪，但是&lt;strong&gt;难免有需要在普通环境中使用 Google 的情况，&lt;/strong&gt;而对于 GitHub 来说，虽然目前可以无障碍访问，但是&lt;strong&gt;在普通环境中下载某些 Release（比如科学工具的客户端）的速度实在太慢。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你也有和我一样的困扰，那么可以考虑&lt;strong&gt;使用 Cloudflare Workers 搭建属于自己的镜像网站，&lt;/strong&gt;在普通环境中备用。&lt;/p&gt;</summary>
    
    
    
    <category term="A1 - 生活随笔" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="B2 - 折腾" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/B2-%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="GitHub" scheme="https://progcz.com/tags/GitHub/"/>
    
    <category term="Cloudflare" scheme="https://progcz.com/tags/Cloudflare/"/>
    
    <category term="Google" scheme="https://progcz.com/tags/Google/"/>
    
    <category term="Mirror" scheme="https://progcz.com/tags/Mirror/"/>
    
  </entry>
  
  <entry>
    <title>2020 May LeetCoding Challenge - Week 4</title>
    <link href="https://progcz.com/posts/2020-may-leetcoding-challenge-week-4/"/>
    <id>https://progcz.com/posts/2020-may-leetcoding-challenge-week-4/</id>
    <published>2020-05-22T11:55:57.000Z</published>
    <updated>2020-05-28T11:24:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 五月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-May-LeetCoding-Challenge/">2020 May LeetCoding Challenge</a> 查看更多。</p><span id="more"></span><h2 id="May-22nd-Sort-Characters-By-Frequency"><a href="#May-22nd-Sort-Characters-By-Frequency" class="headerlink" title="May 22nd: Sort Characters By Frequency"></a>May 22nd: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3337/">Sort Characters By Frequency</a></h2><p>Given a string, sort it in decreasing order based on the frequency of characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;tree&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;eert&quot;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">&#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.</span><br><span class="line">So &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Both &#39;c&#39; and &#39;a&#39; appear three times, so &quot;aaaccc&quot; is also a valid answer.</span><br><span class="line">Note that &quot;cacaca&quot; is incorrect, as the same characters must be together.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;Aabb&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;bbAa&quot;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">&quot;bbaA&quot; is also a valid answer, but &quot;Aabb&quot; is incorrect.</span><br><span class="line">Note that &#39;A&#39; and &#39;a&#39; are treated as two different characters.</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用 <code>vector&lt;pair&lt;int, char&gt;&gt; vec(256)</code> 保存字符串 <code>s</code> 中<strong>每个字符出现的次数</strong>及<strong>字符本身</strong>。从大到小进行排序之后，重新拼接成新的字符串 <code>res</code> 即可。</p><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">frequencySort</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;&gt; <span class="built_in">vec</span>(<span class="number">256</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[ch].first++ == <span class="number">0</span>) &#123;</span><br><span class="line">                vec[ch].second = ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">rbegin</span>(), vec.<span class="built_in">rend</span>());</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : vec) &#123;</span><br><span class="line">            res += <span class="built_in">string</span>(p.first, p.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-23rd-Interval-List-Intersections"><a href="#May-23rd-Interval-List-Intersections" class="headerlink" title="May 23rd: Interval List Intersections"></a>May 23rd: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3338/">Interval List Intersections</a></h2><p>Given two lists of <strong>closed</strong> intervals, each list of intervals is pairwise disjoint and in sorted order.</p><p>Return the intersection of these two interval lists.</p><p><em>(Formally, a closed interval <code>[a, b]</code> (with <code>a &lt;= b</code>) denotes the set of real numbers <code>x</code> with <code>a &lt;= x &lt;= b</code>. The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3].)</em></p><p><strong>Example 1:</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/05.png" style="zoom:80%"/><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A &#x3D; [[0,2],[5,10],[13,23],[24,25]], B &#x3D; [[1,5],[8,12],[15,24],[25,26]]</span><br><span class="line">Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]</span><br><span class="line">Reminder: The inputs and the desired output are lists of Interval objects, and not arrays or lists.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p><code>0 &lt;= A.length &lt; 1000</code></p></li><li><p><code>0 &lt;= B.length &lt; 1000</code></p></li><li><p><code>0 &lt;= A[i].start, A[i].end, B[i].start, B[i].end &lt; 10^9</code></p></li></ul><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>因为 <code>A</code> 和 <code>B</code> 的数据量都不大，所以可以嵌套遍历。在遍历过程中：</p><ul><li><p><strong>如果 <code>a</code> 的右界小于 <code>b</code> 的左界，说明两者不相交，而且因为 <code>B</code> 有序，所以 <code>b</code> 之后的区间也不可能与 <code>a</code> 相交，跳出小循环。</strong></p></li><li><p><strong>如果 <code>a</code> 的左界大于 <code>b</code> 的右界，说明两者不相交，进入下一次小循环。</strong></p></li></ul><p>如果两者相交，那么两者<strong>左界的最大值和右界的最小值之间就是相交的区间。</strong></p><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">intervalIntersection</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; B) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : A) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> b : B) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[<span class="number">1</span>] &lt; b[<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (a[<span class="number">0</span>] &gt; b[<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;<span class="built_in">max</span>(a[<span class="number">0</span>], b[<span class="number">0</span>]), <span class="built_in">min</span>(a[<span class="number">1</span>], b[<span class="number">1</span>])&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-24th-Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#May-24th-Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="May 24th: Construct Binary Search Tree from Preorder Traversal"></a>May 24th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3339/">Construct Binary Search Tree from Preorder Traversal</a></h2><p>Return the root node of a binary <strong>search</strong> tree that matches the given <code>preorder</code> traversal.</p><p><em>(Recall that a binary search tree is a binary tree where for every node, any descendant of <code>node.left</code> has a value <code>&lt; node.val</code>, and any descendant of <code>node.right</code> has a value <code>&gt; node.val</code>. Also recall that a preorder traversal displays the value of the <code>node</code> first, then traverses <code>node.left</code>, then traverses <code>node.right</code>.)</em></p><p>It’s guaranteed that for the given test cases there is always possible to find a binary search tree with the given requirements.</p><p><strong>Example 1:</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/09.png" style="zoom:80%"/><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [8,5,1,7,10,12]</span><br><span class="line">Output: [8,5,10,1,7,null,12]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><p><code>1 &lt;= preorder.length &lt;= 100</code></p></li><li><p><code>1 &lt;= preorder[i] &lt;= 10^8</code></p></li><li><p>The values of <code>preorder</code> are distinct.</p></li></ul><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p><strong>利用 <code>func</code> 函数将 <code>preorder</code> 的 <code>[beg, end]</code> 区间分割为根节点、左子树和右子树。</strong>具体地：</p><ul><li><p>对于根节点，因为 <code>preorder</code> 是前序遍历，所以<strong>根节点必然是 <code>preorder[beg]</code>。</strong></p></li><li><p>对于左子树和右子树，在 <code>preorder</code> 的 <code>[beg+1, end]</code> 区间内遍历寻找第一个大于 <code>preorder[beg]</code> 的数字，其下标为 <code>idx</code>，那么<strong>左子树必然是 <code>preorder[beg+1, idx-1]</code>，右子树必然是 <code>preorder[idx, end]</code>。</strong></p></li></ul><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstFromPreorder</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">func</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;preorder, <span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beg &gt; end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = beg + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt;= end &amp;&amp; preorder[idx] &lt; preorder[beg]) ++idx;</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[beg]);</span><br><span class="line">        node-&gt;left = <span class="built_in">func</span>(preorder, beg+<span class="number">1</span>, idx<span class="number">-1</span>);</span><br><span class="line">        node-&gt;right = <span class="built_in">func</span>(preorder, idx, end);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-25th-Uncrossed-Lines"><a href="#May-25th-Uncrossed-Lines" class="headerlink" title="May 25th: Uncrossed Lines"></a>May 25th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3340/">Uncrossed Lines</a></h2><p>We write the integers of <code>A</code> and <code>B</code> (in the order they are given) on two separate horizontal lines.</p><p>Now, we may draw connecting lines: a straight line connecting two numbers <code>A[i]</code> and <code>B[j]</code> such that:</p><ul><li><p><code>A[i] == B[j]</code>;</p></li><li><p>The line we draw does not intersect any other connecting (non-horizontal) line.</p></li></ul><p>Note that a connecting lines cannot intersect even at the endpoints: each number can only belong to one connecting line.</p><p>Return the maximum number of connecting lines we can draw in this way.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A &#x3D; [1,4,2], B &#x3D; [1,2,4]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We can draw 2 uncrossed lines as in the diagram.</span><br><span class="line">We cannot draw 3 uncrossed lines, because the line from A[1]&#x3D;4 to B[2]&#x3D;4 will intersect the line from A[2]&#x3D;2 to B[1]&#x3D;2.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A &#x3D; [2,5,1,2,5], B &#x3D; [10,5,2,1,5,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A &#x3D; [1,3,7,1,7,5], B &#x3D; [1,9,2,5,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p><code>1 &lt;= A.length &lt;= 500</code></p></li><li><p><code>1 &lt;= B.length &lt;= 500</code></p></li><li><p><code>1 &lt;= A[i], B[i] &lt;= 2000</code></p></li></ul><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://leetcode.com/problems/uncrossed-lines/discuss/650947/C%2B%2B-DP-with-explanation">C++ DP with explanation</a></p><p>P.S. 嗨，看着动态规划的代码感觉还挺好理解的，自己写就写不出来。</p><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.<span class="built_in">size</span>(), n = B.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i] == B[j]) dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span> + dp[i][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="built_in">max</span>(dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-26th-Contiguous-Array"><a href="#May-26th-Contiguous-Array" class="headerlink" title="May 26th: Contiguous Array"></a>May 26th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3341/">Contiguous Array</a></h2><p>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,1,0]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> The length of the given binary array will not exceed 50,000.</p><h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://www.cnblogs.com/grandyang/p/6529857.html">[LeetCode] 525. Contiguous Array 相连的数组 - 刷尽天下</a></p><p>遍历 <code>nums</code> 中的数字 <code>num</code>，如果为 <code>1</code> 则累加 <code>1</code> 至 <code>sum</code>，如果为 <code>0</code> 则累加 <code>-1</code> 至 <code>sum</code>。</p><p>使用 <code>map&lt;int, int&gt; m</code> 记录首次出现某个 <code>sum</code> 的下标，如果之后再次出现该 <code>sum</code>，说明两者之间的子数组满足题目要求，寻找其长度的最大值即可。</p><h4 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(), sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sum += nums[i] ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(sum)) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, i-m[sum]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                m[sum] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-27th-Possible-Bipartition"><a href="#May-27th-Possible-Bipartition" class="headerlink" title="May 27th: Possible Bipartition"></a>May 27th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3342/">Possible Bipartition</a></h2><p>Given a set of <code>N</code> people (numbered <code>1, 2, ..., N</code>), we would like to split everyone into two groups of <strong>any</strong> size.</p><p>Each person may dislike some other people, and they should not go into the same group.</p><p>Formally, if <code>dislikes[i] = [a, b]</code>, it means it is not allowed to put the people numbered <code>a</code> and <code>b</code> into the same group.</p><p>Return <code>true</code> if and only if it is possible to split everyone into two groups in this way.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 4, dislikes &#x3D; [[1,2],[1,3],[2,4]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: group1 [1,4], group2 [2,3]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 3, dislikes &#x3D; [[1,2],[1,3],[2,3]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 5, dislikes &#x3D; [[1,2],[2,3],[3,4],[4,5],[1,5]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p><code>1 &lt;= N &lt;= 2000</code></p></li><li><p><code>0 &lt;= dislikes.length &lt;= 10000</code></p></li><li><p><code>1 &lt;= dislikes[i][j] &lt;= N</code></p></li><li><p><code>dislikes[i][0] &lt; dislikes[i][1]</code></p></li><li><p>There does not exist <code>i != j</code> for which <code>dislikes[i] == dislikes[j]</code>.</p></li></ul><h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://www.cnblogs.com/grandyang/p/10317141.html">[LeetCode] 886. Possible Bipartition 可能的二分图 - 刷尽天下</a></p><p>放弃治疗，直接看大佬的解法吧。</p><h4 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">possibleBipartition</span><span class="params">(<span class="keyword">int</span> N, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; dislikes)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">g</span>(N+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(N+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> dislike : dislikes) &#123;</span><br><span class="line">            g[dislike[<span class="number">0</span>]][dislike[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">            g[dislike[<span class="number">1</span>]][dislike[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">colors</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (colors[i] == <span class="number">0</span> &amp;&amp; !<span class="built_in">func</span>(g, i, <span class="number">1</span>, colors)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; g, <span class="keyword">int</span> cur, <span class="keyword">int</span> color, vector&lt;<span class="keyword">int</span>&gt;&amp; colors)</span> </span>&#123;</span><br><span class="line">        colors[cur] = color;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[cur][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (colors[i] == color) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (colors[i] == <span class="number">0</span> &amp;&amp; !<span class="built_in">func</span>(g, i, -color, colors)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-28th-Counting-Bits"><a href="#May-28th-Counting-Bits" class="headerlink" title="May 28th: Counting Bits"></a>May 28th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3343/">Counting Bits</a></h2><p>Given a non negative integer number <strong>num</strong>. For every numbers <strong>i</strong> in the range <strong>0 ≤ i ≤ num</strong> calculate the number of 1’s in their binary representation and return them as an array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: [0,1,1]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure><h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>充分利用之前的结果：计算 <code>i</code> 中 <code>1</code> 的个数，那么只需要知道 <code>i&gt;&gt;1</code> 中 <code>1</code> 的个数（即 <code>res[i&gt;&gt;1]</code>）和 <code>i</code> 的最后一位是否为 <code>1</code>（即 <code>i&amp;0x1</code>），相加即可。</p><h4 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(res[i&gt;&gt;<span class="number">1</span>]+(i&amp;<span class="number">0x1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 五月挑战专题每日随缘更新，点击类别 &lt;a href=&quot;/categories/2020-May-LeetCoding-Challenge/&quot;&gt;2020 May LeetCoding Challenge&lt;/a&gt; 查看更多。&lt;/p&gt;</summary>
    
    
    
    <category term="A3 - LeetCode" scheme="https://progcz.com/categories/A3-LeetCode/"/>
    
    <category term="B4 - LeetCoding Challenge" scheme="https://progcz.com/categories/A3-LeetCode/B4-LeetCoding-Challenge/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Data Structure and Algorithm" scheme="https://progcz.com/tags/Data-Structure-and-Algorithm/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Challenge" scheme="https://progcz.com/tags/Challenge/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Weekly Contest 189 (1450 - 1453)</title>
    <link href="https://progcz.com/posts/leetcode-weekly-contest-189-1450-1453/"/>
    <id>https://progcz.com/posts/leetcode-weekly-contest-189-1450-1453/</id>
    <published>2020-05-17T06:53:16.000Z</published>
    <updated>2020-05-17T06:53:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 周赛专题每周随缘更新，点击类别 <a href="/categories/LeetCode-Weekly-Contest/">LeetCode Weekly Contest</a> 查看更多。</p><p>本次比赛通过 <code>3</code> 题，时间为 <code>0:48:25</code>，排名为 <code>2708/13036</code>。</p><span id="more"></span><h2 id="1450-Number-of-Students-Doing-Homework-at-a-Given-Time-Easy"><a href="#1450-Number-of-Students-Doing-Homework-at-a-Given-Time-Easy" class="headerlink" title="1450. Number of Students Doing Homework at a Given Time #Easy"></a><a href="https://leetcode.com/contest/weekly-contest-189/problems/number-of-students-doing-homework-at-a-given-time/">1450. Number of Students Doing Homework at a Given Time</a> #Easy</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>侮辱智商，不解释了。</p><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">busyStudent</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; startTime, vector&lt;<span class="keyword">int</span>&gt;&amp; endTime, <span class="keyword">int</span> queryTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = startTime.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (startTime[i] &lt;= queryTime &amp;&amp; endTime[i] &gt;= queryTime) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1451-Rearrange-Words-in-a-Sentence-Medium"><a href="#1451-Rearrange-Words-in-a-Sentence-Medium" class="headerlink" title="1451. Rearrange Words in a Sentence #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-189/problems/rearrange-words-in-a-sentence">1451. Rearrange Words in a Sentence</a> #Medium</h2><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用 <code>vector&lt;pair&lt;vector&lt;int&gt;, string&gt;&gt; vec</code> 存放分割后的子字符串，<strong>其中 <code>vector&lt;int&gt;</code> 包含两个数字，第一个为字符串的长度，第二个为字符串的序号，</strong>从而在之后的 <code>sort</code> 中按照字符串的长度排序，如果长度相等，则按照字符串的原顺序排序。</p><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">arrangeWords</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        text[<span class="number">0</span>] -= <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        text.<span class="built_in">push_back</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, cur = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        vector&lt;pair&lt;vector&lt;<span class="keyword">int</span>&gt;, string&gt;&gt; vec;</span><br><span class="line">        <span class="keyword">while</span> ((cur = text.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>, pre)) != string::npos) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;cur-pre, cnt++&#125;,</span><br><span class="line">                                    text.<span class="built_in">substr</span>(pre, cur-pre)));</span><br><span class="line">            pre = cur+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : vec) res += p.second + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">        res[<span class="number">0</span>] += <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1452-People-Whose-List-of-Favorite-Companies-Is-Not-a-Subset-of-Another-List-Medium"><a href="#1452-People-Whose-List-of-Favorite-Companies-Is-Not-a-Subset-of-Another-List-Medium" class="headerlink" title="1452. People Whose List of Favorite Companies Is Not a Subset of Another List #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-189/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/">1452. People Whose List of Favorite Companies Is Not a Subset of Another List</a> #Medium</h2><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，<strong>将每组公司从 <code>vector&lt;string&gt;</code> 重新组织为 <code>set&lt;string&gt;</code>，</strong>从而方便后续查找。</p><p>其次，嵌套遍历，<strong>其中 <code>b1</code> 用于标记 <code>vec[i]</code> 是否包含于其他任何组，<code>b2</code> 用于标记 <code>vec[i]</code> 是否包含于 <code>vec[j]</code>。</strong></p><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">peopleIndexes</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; favoriteCompanies)</span> </span>&#123;</span><br><span class="line">        vector&lt;set&lt;string&gt;&gt; vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> vs : favoriteCompanies) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(set&lt;string&gt;(vs.<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">bool</span> b1 = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vec[i].<span class="built_in">size</span>() &gt;= vec[j].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">bool</span> b2 = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> s : vec[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (vec[j].<span class="built_in">find</span>(s) == vec[j].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        b2 = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (b2) b1 = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!b1) res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1453-Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard-Hard"><a href="#1453-Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard-Hard" class="headerlink" title="1453. Maximum Number of Darts Inside of a Circular Dartboard #Hard"></a><a href="https://leetcode.com/contest/weekly-contest-189/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/">1453. Maximum Number of Darts Inside of a Circular Dartboard</a> #Hard</h2><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/discuss/636416/c%2B%2B-O(n2logn)-angular-sweep-(with-picture)">[c++] O(n^2logn), angular sweep (with picture)</a></p><p>又是放弃治疗系列，直接看大佬的解法吧。</p><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numPoints</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">double</span>&gt;&gt; <span class="built_in">dist</span>(n, vector&lt;<span class="keyword">double</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                dist[i][j] = dist[j][i] = <span class="built_in">sqrt</span>((points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) * (points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) +</span><br><span class="line">                                               (points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]) * (points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            vector&lt;pair&lt;<span class="keyword">double</span>, <span class="keyword">bool</span>&gt;&gt; angles;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != i &amp;&amp; dist[i][j] &lt;= <span class="number">2</span> * r) &#123;</span><br><span class="line">                    <span class="keyword">double</span> A = <span class="built_in">atan2</span>(points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>], points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">double</span> B = <span class="built_in">acos</span>(dist[i][j] / (<span class="number">2.0</span> * r));</span><br><span class="line">                    <span class="keyword">double</span> alpha = A - B;</span><br><span class="line">                    <span class="keyword">double</span> beta = A + B;</span><br><span class="line">                    angles.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(alpha, <span class="literal">false</span>));</span><br><span class="line">                    angles.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(beta, <span class="literal">true</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(angles.<span class="built_in">begin</span>(), angles.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = angles.<span class="built_in">begin</span>(); it != angles.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((*it).second == <span class="literal">false</span>) ++cnt;</span><br><span class="line">                <span class="keyword">else</span> --cnt;</span><br><span class="line">                res = <span class="built_in">max</span>(res, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 周赛专题每周随缘更新，点击类别 &lt;a href=&quot;/categories/LeetCode-Weekly-Contest/&quot;&gt;LeetCode Weekly Contest&lt;/a&gt; 查看更多。&lt;/p&gt;
&lt;p&gt;本次比赛通过 &lt;code&gt;3&lt;/code&gt; 题，时间为 &lt;code&gt;0:48:25&lt;/code&gt;，排名为 &lt;code&gt;2708/13036&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="A3 - LeetCode" scheme="https://progcz.com/categories/A3-LeetCode/"/>
    
    <category term="B2 - LeetCode Weekly Contest" scheme="https://progcz.com/categories/A3-LeetCode/B2-LeetCode-Weekly-Contest/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Data Structure and Algorithm" scheme="https://progcz.com/tags/Data-Structure-and-Algorithm/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
  </entry>
  
</feed>
