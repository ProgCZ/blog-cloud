<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ProgCZ&#39;s Blog</title>
  
  
  <link href="https://progcz.com/atom.xml" rel="self"/>
  
  <link href="https://progcz.com/"/>
  <updated>2021-05-27T01:20:51.000Z</updated>
  <id>https://progcz.com/</id>
  
  <author>
    <name>ProgCZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>未来的七个月想做点什么</title>
    <link href="https://progcz.com/posts/1622073720/"/>
    <id>https://progcz.com/posts/1622073720/</id>
    <published>2021-05-27T00:05:33.000Z</published>
    <updated>2021-05-27T01:20:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>想做却还没做的，还很多。写来也是为了给自己梳理下思路，因为最近被这些事情搞得很乱。</p><span id="more"></span><h2 id="1-考取教师资格证"><a href="#1-考取教师资格证" class="headerlink" title="1 考取教师资格证"></a>1 考取教师资格证</h2><p>自打高中，我就认为自己是个很适合当老师的人。大学以来，（迫于生计）兼职做家教，甚至带十几个小学生的辅导班，这些经历更是印证了自己的想法。</p><p>当个程序员不好吗？互联网大厂绝无可能让我干到退休，我没那个身体素质，公司也没那个善心。</p><p>所以，还是给自己铺条后路。</p><p>书已经买好了，准备参加 11 月的考试。</p><p>大致的时间规划是：<strong>06-09 月慢慢看书，图稳，10-11 月突击复习，图精。</strong></p><h2 id="2-买房"><a href="#2-买房" class="headerlink" title="2 买房"></a>2 买房</h2><p>只要国运不崩，上海的房价只可能涨不可能跌。所以，先上车后置换。</p><p>大致的时间规划是：<strong>10 月底之前（最晚 12 月底之前）看好房子，签好合同。</strong></p><h2 id="3-坚持阅读和练习写作"><a href="#3-坚持阅读和练习写作" class="headerlink" title="3 坚持阅读和练习写作"></a>3 坚持阅读和练习写作</h2><p>最近半年，阅读的时间太少。</p><p>大致的规划是：<strong>每天抽出至少 30 分钟来阅读。</strong></p><p>至于写作，私心是希望自己能写出这样的句子：</p><div class="note success"><p><strong>国庆时回了趟老家。老房间的旧床实在是太好睡了。随便一个睡姿里，都重叠着以往时光里无数个我的同一姿态。</strong></p><p>from 夜晚的潜水艇 by 陈春成</p></div><p>大致的规划是：<strong>找个靠谱的写作课程，开始写作训练。</strong></p><h2 id="4-学习投资和理财"><a href="#4-学习投资和理财" class="headerlink" title="4 学习投资和理财"></a>4 学习投资和理财</h2><p>倒不是吹嘘，我在投资和理财方面的知识要比大部分人要强一些，但多数都是零碎的、不成系统的。</p><p>大致的规划是：<strong>从最基础的概念（比如 PE、PB 等）开始研究，逐步形成自己的投资/理财体系。</strong></p><div class="note info"><p>这也算是给自己铺的后路之一吧。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;想做却还没做的，还很多。写来也是为了给自己梳理下思路，因为最近被这些事情搞得很乱。&lt;/p&gt;</summary>
    
    
    
    <category term="A00 - 总结与计划" scheme="https://progcz.com/categories/A00-%E6%80%BB%E7%BB%93%E4%B8%8E%E8%AE%A1%E5%88%92/"/>
    
    
    <category term="Plan" scheme="https://progcz.com/tags/Plan/"/>
    
  </entry>
  
  <entry>
    <title>招商银行朝朝宝：余额宝和零钱通的最佳替代品</title>
    <link href="https://progcz.com/posts/1620777814/"/>
    <id>https://progcz.com/posts/1620777814/</id>
    <published>2021-05-12T00:05:49.000Z</published>
    <updated>2021-05-13T14:14:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我们看向历史的后视镜，2013 年面世的余额宝确实是一款影响十分深远的产品，它永久地改变了人们对于短期闲置现金的处置方式，更进一步地推动了无现金支付的发展。邯郸学步的零钱通后来也不断壮大，和余额宝一起，成为人们活期理财的首要选择。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/03.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/04.png"></div></div></div><p>达成这一切，靠的便是直击用户痛点的两个特性：<strong>高收益率</strong>和<strong>随时支取</strong>。</p><p>然而，眼看着互联网金融的繁荣发展，银行自然不能坐以待毙。</p><p>招商银行推出的<strong>朝朝宝</strong>便是这样一款狙击余额宝/零钱通的活期理财产品，极大地吸引了以招商银行卡为主力卡的用户，比如我。</p><span id="more"></span><h2 id="1-在余额宝出现之前，用于日常支出的钱都放在哪里？"><a href="#1-在余额宝出现之前，用于日常支出的钱都放在哪里？" class="headerlink" title="1 在余额宝出现之前，用于日常支出的钱都放在哪里？"></a>1 在余额宝出现之前，用于日常支出的钱都放在哪里？</h2><p>无非三个选择：钱包、银行卡的活期账户、支付宝的余额。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/05.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/06.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/07.png"></div></div></div><p>这样看来，钱包和银行卡的活期账户明显是更优的选择，因为</p><ul><li>如果场景不支持扫码，可以用钱包中的现金，或者 POS 机刷银行卡支付。</li><li>如果场景支持扫码，可以在支付宝中选择使用银行卡支付。</li></ul><p>更何况，放在银行卡里，还有聊胜于无的利息收入，放在支付宝余额里，就真的只是放着而已。</p><p>所以，<strong>用户好像没有什么动力，特地把银行卡里的钱转到支付宝里。</strong></p><h2 id="2-余额宝解决了什么痛点？"><a href="#2-余额宝解决了什么痛点？" class="headerlink" title="2 余额宝解决了什么痛点？"></a>2 余额宝解决了什么痛点？</h2><h3 id="2-1-高收益率"><a href="#2-1-高收益率" class="headerlink" title="2.1 高收益率"></a>2.1 高收益率</h3><p>众所周知，余额宝本质上属于货币基金。</p><blockquote><p>货币基金的运作方式可以简单理解为，基金将用户的钱集中起来，去跟银行谈一个利息较高的大额存款，再将利息作为收益返还给用户。</p></blockquote><p>好，这就为余额宝带来了第一个极具吸引力的特性：<strong>我把钱放在余额宝里，是有收益的，而且收益远高于银行卡的活期利息。</strong></p><div class="note info"><p>热知识：2014 年，余额宝的七日年化曾高达 6.76%，万份收益 1.8 元左右。</p></div><p>但是，用户还有个小问题：我为啥不选择其他货币基金？</p><h3 id="2-2-随时支取"><a href="#2-2-随时支取" class="headerlink" title="2.2 随时支取"></a>2.2 随时支取</h3><p>我们都知道，余额宝可以用于扫码支付、淘宝购物。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/08.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/09.png"></div></div></div><p>其支撑就在于，不同于当时的其他货币基金，余额宝提供了 T+0 的快速赎回方式。</p><p>好，第二个极具吸引力的特性向我们走来：<strong>我把钱放在余额宝里，24 小时均可取出，几分钟内到账。</strong></p><p>如今，众多「宝宝」类产品，比如天天基金的活期宝，其背后的货币基金也可以实现 T+0，但是无法打通消费场景，这是来自于支付宝的降维打击。</p><h2 id="3-余额宝还有什么缺点？"><a href="#3-余额宝还有什么缺点？" class="headerlink" title="3 余额宝还有什么缺点？"></a>3 余额宝还有什么缺点？</h2><h3 id="3-1-收益率不断下滑"><a href="#3-1-收益率不断下滑" class="headerlink" title="3.1 收益率不断下滑"></a>3.1 收益率不断下滑</h3><p>我不是经济专家，无法准确给出收益率下滑的原因。</p><p>但是对于一个用户而言，这就让我把钱转到余额宝里的动力越来越低。</p><div class="note warning"><p>内心 OS：每天就那么点收益，何必费那个劲呢？</p></div><h3 id="3-2-资金分散，不便管理"><a href="#3-2-资金分散，不便管理" class="headerlink" title="3.2 资金分散，不便管理"></a>3.2 资金分散，不便管理</h3><p>这实际上并不是余额宝的缺点，而是支付宝和微信支付二分天下带来的问题。</p><p>对于日常收支、投资理财，我有非常清晰的记录和规划。我每月初都会花十几分钟的时间整理一个表格，上面清晰地记录着我的每一分钱都放在什么地方，同时根据现状做出调整和规划。</p><p>具体到用于日常支出的短期闲置现金，我一般会在余额宝和零钱通分别放 5K 整。这样的话，下个月初我就能根据剩多少钱，快速算出上个月的支出。如果有异常，再去查看账单明细，看看是什么事情花费较多，有没有可优化的空间。</p><p>虽然管理两处也不是什么特别麻烦的事情，但是如果能合为一处岂不快哉。</p><h2 id="4-为什么推荐朝朝宝？"><a href="#4-为什么推荐朝朝宝？" class="headerlink" title="4 为什么推荐朝朝宝？"></a>4 为什么推荐朝朝宝？</h2><p>对于我而言，朝朝宝完美解决了上面两个缺点。</p><h3 id="4-1-收益方面"><a href="#4-1-收益方面" class="headerlink" title="4.1 收益方面"></a>4.1 收益方面</h3><p>朝朝宝的七日年化高达 3.10%，万分收益 0.8 元左右。</p><div class="note warning"><p>作为对比，支付宝的七日年化只有 2.12%，万份收益 0.5 元左右。</p></div><p>这一点主要得益于<strong>朝朝宝背后并不是货币基金，而是五款风险评级均为 R1 的招行代销理财产品，</strong>在收益较高的同时也保证了资金的安全性。</p><blockquote><p>其中一款代销理财细节可以看官网资料：<a href="http://www.cmbchina.com/cfweb/Personal/saproductdetail.aspx?saaCod=D07&funCod=8924&type=prodintro">招银理财招赢聚宝盆5号现金管理类理财计划</a></p></blockquote><p>当然，收益率会不会像余额宝一样下滑，还需要持续观察，至少现在是高的对吧。</p><h3 id="4-2-管理方面"><a href="#4-2-管理方面" class="headerlink" title="4.2 管理方面"></a>4.2 管理方面</h3><p>朝朝宝支持支付宝支付，微信支付，银行转账，ATM 取款，还信用卡、花呗和贷款，购买银行理财和基金等，如果不出意外的话，应该还支持 Apple Pay 或者其他 Pay（我没试过）。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/10.png"></p><p>我只需要每月初在朝朝宝里放 1W 整，不管是支付宝还是微信支付，在扫码后选择使用银行卡支付即可。</p><p>这样的话，我就可以集中管理生活中各个方面的支出情况，我直接大呼过瘾。</p><div class="note warning"><p>需要注意的是，朝朝宝最多可转入 5W，每日也最多可转出 5W，对于日常支出较多的人来说可能不是很友好。</p></div><h2 id="5-后记"><a href="#5-后记" class="headerlink" title="5 后记"></a>5 后记</h2><p>这不是朝朝宝的软文（招行也不至于卑贱到来找我写软文），单纯只是我想分享一下好的理财产品。不构成理财建议，但是如果对你有所帮助，那就再好不过了。也祝自己早日暴富！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当我们看向历史的后视镜，2013 年面世的余额宝确实是一款影响十分深远的产品，它永久地改变了人们对于短期闲置现金的处置方式，更进一步地推动了无现金支付的发展。邯郸学步的零钱通后来也不断壮大，和余额宝一起，成为人们活期理财的首要选择。&lt;/p&gt;
&lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot;&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/03.png&quot;&gt;&lt;/div&gt;&lt;div class=&quot;group-picture-column&quot;&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/04.png&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;达成这一切，靠的便是直击用户痛点的两个特性：&lt;strong&gt;高收益率&lt;/strong&gt;和&lt;strong&gt;随时支取&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然而，眼看着互联网金融的繁荣发展，银行自然不能坐以待毙。&lt;/p&gt;
&lt;p&gt;招商银行推出的&lt;strong&gt;朝朝宝&lt;/strong&gt;便是这样一款狙击余额宝/零钱通的活期理财产品，极大地吸引了以招商银行卡为主力卡的用户，比如我。&lt;/p&gt;</summary>
    
    
    
    <category term="A01 - 生活随笔" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="理财" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E7%90%86%E8%B4%A2/"/>
    
    
    <category term="招商银行" scheme="https://progcz.com/tags/%E6%8B%9B%E5%95%86%E9%93%B6%E8%A1%8C/"/>
    
    <category term="朝朝宝" scheme="https://progcz.com/tags/%E6%9C%9D%E6%9C%9D%E5%AE%9D/"/>
    
    <category term="余额宝" scheme="https://progcz.com/tags/%E4%BD%99%E9%A2%9D%E5%AE%9D/"/>
    
    <category term="零钱通" scheme="https://progcz.com/tags/%E9%9B%B6%E9%92%B1%E9%80%9A/"/>
    
    <category term="活期理财" scheme="https://progcz.com/tags/%E6%B4%BB%E6%9C%9F%E7%90%86%E8%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>从一封邮件谈谈我为什么不再想要评论系统</title>
    <link href="https://progcz.com/posts/1620608429/"/>
    <id>https://progcz.com/posts/1620608429/</id>
    <published>2021-05-10T01:01:20.000Z</published>
    <updated>2021-05-11T15:08:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>在重建站点的过程中，我曾经挣扎过要不要重设评论系统。</p><p>基础设施方面，适用于静态博客的各类评论系统都已经发展得比较成熟，比如独立服务的 <a href="https://blog.disqus.com/">Disqus</a>、依赖 GitHub Issues 的 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 和 <a href="https://github.com/utterance/utterances">Utterances</a>、依赖 LeanCloud 等的 <a href="https://github.com/xCss/Valine">Valine</a> 和 <a href="https://github.com/lizheming/waline">Waline</a>，选择颇多。</p><p>对于博客而言，评论系统可以让读者更方便地给出反馈，和作者交流彼此的观点和看法。</p><p>但是如你所见，我还是没有重设评论系统。</p><p>真正促使我放弃的，根本原因是<strong>互联网中随处可见的，无知、无营养甚至充满恶意的评论。</strong></p><p>而导火索则是这样一封邮件：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/01.png"></p><span id="more"></span><h2 id="1-事情起因（我的猜测）"><a href="#1-事情起因（我的猜测）" class="headerlink" title="1 事情起因（我的猜测）"></a>1 事情起因（我的猜测）</h2><p>这位朋友曾经使用 Cloudflare 搭过 Google Scholar 的镜像网站，突然发现不可用了，于是在 Google 搜索相关信息，看到了我一年前写的这篇文章：<a href="https://progcz.com/posts/use-cf-workers-build-google-and-github-mirrors/">使用 Cloudflare Workers 搭建 Google 和 GitHub 镜像网站</a>，认为是我的分享和传播导致了 Cloudflare 不可用，怒不可遏的同时又看到了我的邮箱，于是就有了上面那封邮件。</p><h2 id="2-我的看法"><a href="#2-我的看法" class="headerlink" title="2 我的看法"></a>2 我的看法</h2><p>这位朋友的核心观点在于：<strong>这样的知识，自己知道就好了，不要拿出来分享。</strong></p><p>可以说是非常自私了，而且多少有点逻辑的人都能看出这里面的问题：<strong>如果每个人都不分享这样的知识，那这位朋友又是从哪里获取到的呢？靠自己顿悟吗？</strong></p><p>我有时候也会很纳闷，为什么这么简单的道理，都没有出现在这类朋友的脑子里。</p><p>如果是其他网民，我可能可以理解。因为根据<a href="https://finance.sina.com.cn/tech/2020-09-29/doc-iivhuipp7144597.shtml">这篇文章</a>，2020 年网民的规模达 9.40 亿，其中学历达到本科及以上的仅为 8.8％。没有经历过高等教育的话，认知是会受到一定限制。</p><p>但是这位朋友提到了谷歌学术，说明至少已经到了高等教育的阶段，却依然这么狭隘，让我匪夷所思。</p><p>当然，这种情况不止发生了一次，在评论量较大的博客、在我认为社区氛围很好的 B 站和豆瓣，我都会频繁地看到这类评论，不然我也不会对互联网的评论环境如此失望。</p><h2 id="3-我的回复"><a href="#3-我的回复" class="headerlink" title="3 我的回复"></a>3 我的回复</h2><p>尽管无法理解，但我还是出于本能的 defence，回复了这封邮件：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/02.png"></p><p>看，这也是我不想要评论系统的原因之一，我不想为了这种事情 defence 啊。</p><p>人生已经很累了，照顾好自己的情绪都是一件非常困难的事情，就更不想陷入这种本不该存在的争论之中了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在重建站点的过程中，我曾经挣扎过要不要重设评论系统。&lt;/p&gt;
&lt;p&gt;基础设施方面，适用于静态博客的各类评论系统都已经发展得比较成熟，比如独立服务的 &lt;a href=&quot;https://blog.disqus.com/&quot;&gt;Disqus&lt;/a&gt;、依赖 GitHub Issues 的 &lt;a href=&quot;https://github.com/gitalk/gitalk&quot;&gt;Gitalk&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/utterance/utterances&quot;&gt;Utterances&lt;/a&gt;、依赖 LeanCloud 等的 &lt;a href=&quot;https://github.com/xCss/Valine&quot;&gt;Valine&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/lizheming/waline&quot;&gt;Waline&lt;/a&gt;，选择颇多。&lt;/p&gt;
&lt;p&gt;对于博客而言，评论系统可以让读者更方便地给出反馈，和作者交流彼此的观点和看法。&lt;/p&gt;
&lt;p&gt;但是如你所见，我还是没有重设评论系统。&lt;/p&gt;
&lt;p&gt;真正促使我放弃的，根本原因是&lt;strong&gt;互联网中随处可见的，无知、无营养甚至充满恶意的评论。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而导火索则是这样一封邮件：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/01.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A01 - 生活随笔" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="感悟" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="Blog" scheme="https://progcz.com/tags/Blog/"/>
    
    <category term="Mail" scheme="https://progcz.com/tags/Mail/"/>
    
    <category term="Comment" scheme="https://progcz.com/tags/Comment/"/>
    
  </entry>
  
  <entry>
    <title>谈谈 Hexo 的主题现状以及我对 NexT 的细节改造</title>
    <link href="https://progcz.com/posts/1619784301/"/>
    <id>https://progcz.com/posts/1619784301/</id>
    <published>2021-04-30T15:05:45.000Z</published>
    <updated>2021-04-30T15:05:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>上次发文还是三月初，中间停更了这么久，主要原因在于，之前我对主题源码进行了侵入式的改造，难以升级享受最新的版本特性，于是我就想要重建这个博客站点，兼顾可升级和可改造。</p><p>那我就想，既然要重建，何不换个主题试一下？果然，试试就逝世。</p><span id="more"></span><h2 id="1-Hexo-主题"><a href="#1-Hexo-主题" class="headerlink" title="1 Hexo 主题"></a>1 Hexo 主题</h2><p>在静态博客框架中，Hexo 向来是最受青睐的选择，没有之一。</p><p>Jekyll 作为 GitHub 官方支持的框架，可以直接托管源码而无需手动生成静态网页，Hugo 借助 Go 语言的性能优势，号称全世界最快的框架，然而这两者都有一点远落后于 Hexo，那就是最为关键的<strong>主题生态</strong>。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/01.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/02.png"></div></div></div><p>作为一个想搭博客的人来说，审美能对自己胃口才是头等大事，所以主题生态只有枝繁叶茂才能留住众口难调的用户。</p><p>Hexo 使用 Node.js 开发，从语言层面上就吸引了大批优秀的前端工程师，精美主题可以说是层出不穷。</p><p>当然再好的主题也必然有令人不甚满意的地方，这里就把 Butterfly 单拎出来说说问题。</p><h3 id="1-1-Butterfly"><a href="#1-1-Butterfly" class="headerlink" title="1.1 Butterfly"></a>1.1 <a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></h3><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/03.png"></p><p>简洁好看，尤其是首屏的视觉效果，足够吸引眼球。这也是我刚开始重建的第一选择。</p><p>但是这个主题，说得严重一点，「金玉其外，败絮其中。」</p><p>我相信，任何用过 Butterfly 的人，一定会被 <code>_config.butterfly.yml</code> 中混乱的配置给搞得心烦意乱，举个栗子：</p><p>配置中有一段是关于网站默认的展示模式，可以选择明亮/暗黑：</p><figure class="highlight yaml"><figcaption><span>code</span><a href="https://github.com/jerryc127/hexo-theme-butterfly/blob/dev/_config.yml">_config.yml</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Default display mode (網站默認的顯示模式)</span></span><br><span class="line"><span class="comment"># light (default) / dark</span></span><br><span class="line"><span class="attr">display_mode:</span> <span class="string">light</span></span><br></pre></td></tr></table></figure><p>然而在后面又出现了一段是关于暗黑模式，可以选择是否开启：</p><figure class="highlight yaml"><figcaption><span>code</span><a href="https://github.com/jerryc127/hexo-theme-butterfly/blob/dev/_config.yml">_config.yml</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># dark mode</span></span><br><span class="line"><span class="attr">darkmode:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Toggle Button to switch dark/light mode</span></span><br><span class="line">    <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Switch dark/light mode automatically (自動切換 dark mode和 light mode)</span></span><br><span class="line">    <span class="comment"># autoChangeMode: 1  Following System Settings, if the system doesn&#x27;t support dark mode, it will switch dark mode between 6 pm to 6 am</span></span><br><span class="line">    <span class="comment"># autoChangeMode: 2  Switch dark mode between 6 pm to 6 am</span></span><br><span class="line">    <span class="comment"># autoChangeMode: false</span></span><br><span class="line">    <span class="attr">autoChangeMode:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这让我不禁想问：如果我在前面选了默认明亮模式，后面又选了开启暗黑模式，那主题到底是展现哪一种？只有试过之后才能知道，无疑增加了理解成本。</p><p>类似的问题还有很多，就不赘述了。总之这个配置文件折磨了我很久，最终不得不放弃。</p><div class="note warning"><p>不管怎样，我还是很尊重主题作者的，提供免费开源的主题给大家用，本身就非常值得敬佩。但还是那句话，「若批评不自由，则赞美无意义。」</p><p><del>而且感觉主题作者是个暴躁老哥，惹不太起。</del></p></div><h2 id="2-NexT-改造"><a href="#2-NexT-改造" class="headerlink" title="2 NexT 改造"></a>2 NexT 改造</h2><p>当然，我换过不止 Butterfly 一个主题，然而其他主题即便没有混乱的配置文件，也存在大量优化不到位的细节，所以兜兜转转又回到了 NexT 的怀抱。</p><h3 id="2-1-基本配置"><a href="#2-1-基本配置" class="headerlink" title="2.1 基本配置"></a>2.1 基本配置</h3><p><code>_config.yml</code> 和 <code>_config.next.yml</code> 中的配置基本都体现在 <a href="https://github.com/ProgCZ/progcz.github.io/commit/f3cdd681835389803f187024e06124960f48d251">commit f3cdd68</a> 中，不再赘述。</p><h3 id="2-2-特殊改造"><a href="#2-2-特殊改造" class="headerlink" title="2.2 特殊改造"></a>2.2 特殊改造</h3><p>特殊改造基本都体现在 <a href="https://github.com/ProgCZ/progcz.github.io/commit/3d56b383f78c1b260edb668ff7ed8e0d6f5232fd">commit 3d56b38</a> 中，没有污染博客源码，只是通过自定义的 js 和 css 来实现。</p><ol><li><p>替换站点标题中不规范的部分</p><p> 如果足够细心的话，你就会发现，在每个分类页面中，标题中的冒号都是英文冒号，不符合中文排版规范：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/04.png"></p><p> 替换后：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/05.png"></p></li><li><p>替换归档页面中不规范的部分</p><p> 归档页面中，表达冗余，且英文叹号也不符合中文排版规范：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/06.png"></p><p> 替换后：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/07.png"></p></li><li><p>替换文章信息中不规范的部分</p><p> 这个单纯是我看中文逗号不顺眼，不能表达分类之间的层级关系：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/08.png"></p><p> 替换后：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/09.png"></p></li><li><p>替换页脚中不规范的部分</p><p> 这个也单纯是我看 copyright 字符不顺眼，有点矮：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/10.png"></p><p> 替换后：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/11.png"></p></li><li><p>动画速度调整至 0.3s</p> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.animated</span> &#123;</span><br><span class="line">    <span class="attribute">animation-duration</span>: <span class="number">0.3s</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>侧边栏字体从 <code>font-size-smaller</code> 调大至 <code>font-size-small</code></p> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu-item</span> &#123;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: $font-size-small;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.links-of-author</span> &#123;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: $font-size-small;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.site-state-item-name</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: $font-size-small;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-后记"><a href="#3-后记" class="headerlink" title="3 后记"></a>3 后记</h2><p>折腾告一段落，静下心来好好写些文章吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上次发文还是三月初，中间停更了这么久，主要原因在于，之前我对主题源码进行了侵入式的改造，难以升级享受最新的版本特性，于是我就想要重建这个博客站点，兼顾可升级和可改造。&lt;/p&gt;
&lt;p&gt;那我就想，既然要重建，何不换个主题试一下？果然，试试就逝世。&lt;/p&gt;</summary>
    
    
    
    <category term="A01 - 生活随笔" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="折腾" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="Blog" scheme="https://progcz.com/tags/Blog/"/>
    
    <category term="Hexo" scheme="https://progcz.com/tags/Hexo/"/>
    
    <category term="NexT" scheme="https://progcz.com/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Problem 3 - Longest Substring Without Repeating Characters</title>
    <link href="https://progcz.com/posts/leetcode-problem-longest-substring-without-repeating-characters/"/>
    <id>https://progcz.com/posts/leetcode-problem-longest-substring-without-repeating-characters/</id>
    <published>2021-02-26T01:08:46.000Z</published>
    <updated>2021-03-03T00:07:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a></p><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定字符串，输出最长不重复子串的长度。</p><span id="more"></span><h2 id="解法一：滑动窗口"><a href="#解法一：滑动窗口" class="headerlink" title="解法一：滑动窗口"></a>解法一：滑动窗口</h2><p>借助 <code>hash_map</code>，建立起<strong>子串中</strong>字符和出现次数的映射，如果 <code>hash_map</code> 中所有字符的出现次数均不大于 <code>1</code>，那么就说明当前子串为不重复子串。</p><p>滑动窗口的左右边界分别为 <code>beg</code> 和 <code>end</code>（均初始化为 <code>0</code>），</p><ol><li><p>在遍历 <code>hash_map</code> 后判断当前子串为不重复子串的情况下，<code>end</code> 不断右移，同时将 <code>hash_map</code> 中对应字符的出现次数 <code>+1</code>。</p></li><li><p>上述 <code>end</code> 的右移停止，说明 <code>end</code> 到达字符串末尾或者当前子串为重复子串，则记录不重复子串的最大长度。</p></li><li><p>在遍历 <code>hash_map</code> 后判断当前子串为重复子串的情况下，<code>beg</code> 不断右移，同时将 <code>hash_map</code> 中对应字符的出现次数 <code>-1</code>。</p></li><li><p>上述 <code>beg</code> 的右移停止，说明 <code>beg</code> 到达 <code>end</code> 或者当前子串不为重复子串，则重复整个流程。</p></li></ol><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(n)</code>（不太确定）</p></li><li><p>时间：<code>O(n)</code></p></li></ul><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; um;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> beg = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; <span class="built_in">helper</span>(um)) &#123;</span><br><span class="line">                um[s[end++]-<span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> len = (end == n &amp;&amp; <span class="built_in">helper</span>(um)) ?</span><br><span class="line">                (end - beg) : (end - beg - <span class="number">1</span>);</span><br><span class="line">            res = <span class="built_in">max</span>(res, len);</span><br><span class="line">            <span class="keyword">while</span> (beg &lt;= end &amp;&amp; !<span class="built_in">helper</span>(um)) &#123;</span><br><span class="line">                um[s[beg++]-<span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="keyword">const</span> unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; um)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = um.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (iter != um.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;second &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++iter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：记旧账"><a href="#解法二：记旧账" class="headerlink" title="解法二：记旧账"></a>解法二：记旧账</h2><p>对于当前字符来说，往前一个一个地推字符，如果某个字符出现了两次，那么该字符前一次出现的下标，一定是最长不重复子串起点的下标减一。</p><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间复杂度：<code>O(1)</code></p></li><li><p>时间复杂度：<code>O(n)</code></p></li></ul><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><blockquote><p>参考：<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1730/Shortest-O(n)-DP-solution-with-explanations">https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1730/Shortest-O(n)-DP-solution-with-explanations</a></p></blockquote><div class="note info"><p>因为 <code>char</code> 类型是 8 位，枚举值共有 256 种，所以可以使用 <code>array&lt;int, 256&gt;</code> 代替 <code>unordered_map&lt;char, int&gt;</code> 来实现字符和下标之间的映射。</p></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        array&lt;<span class="keyword">int</span>, 256&gt; arr; arr.<span class="built_in">fill</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, loc = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 等号右边的 `loc`，就是解法中提到的「前一次出现的下标」</span></span><br><span class="line">            <span class="comment">// 等号右边的 `arr[s[i]]`，就是当前字符的「前一次出现的下标」</span></span><br><span class="line">            <span class="comment">// 两者取最大，更新 `loc`，同时 `loc` 也就是：</span></span><br><span class="line">            <span class="comment">// 对于当前字符来说的，最长不重复子串起点的下标减一</span></span><br><span class="line">            loc = <span class="built_in">max</span>(loc, arr[s[i]]);</span><br><span class="line">            <span class="comment">// 计算：对于当前字符来说的，最长不重复子串的长度</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, i-loc);</span><br><span class="line">            <span class="comment">// 更新 `arr[s[i]]`</span></span><br><span class="line">            arr[s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-substring-without-repeating-characters/&quot;&gt;https://leetcode.com/problems/longest-substring-without-repeating-characters/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h3&gt;&lt;p&gt;给定字符串，输出最长不重复子串的长度。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="LeetCode Problems" scheme="https://progcz.com/categories/A03-LeetCode/LeetCode-Problems/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="String" scheme="https://progcz.com/tags/String/"/>
    
    <category term="Hash Table" scheme="https://progcz.com/tags/Hash-Table/"/>
    
    <category term="Two Pointers" scheme="https://progcz.com/tags/Two-Pointers/"/>
    
    <category term="Sliding Window" scheme="https://progcz.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Problem 2 - Add Two Numbers</title>
    <link href="https://progcz.com/posts/leetcode-problem-add-two-numbers/"/>
    <id>https://progcz.com/posts/leetcode-problem-add-two-numbers/</id>
    <published>2021-02-24T15:54:42.000Z</published>
    <updated>2021-02-26T00:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/add-two-numbers/">https://leetcode.com/problems/add-two-numbers/</a></p><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>将两个数字的每一位，逆序地拆成两个链表 <code>l1</code> 和 <code>l2</code>，计算这两个数字的和，结果以同样顺序的链表表示。</p><span id="more"></span><h2 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h2><p>递归遍历两个输入链表，对应节点相加，<code>%10</code> 的值存入输出链表的对应节点，<code>/10</code> 的值存入输出链表的下一节点。</p><p>边界条件：两个输入链表的对应节点都为空指针。</p><div class="note info"><p>在边界条件下，需要根据下一节点的值是否为 0 而决定是否抛弃该下一节点。为了实现这一点，同时保持代码的 <code>neat</code> 性，传入递归函数的输出链表的对应节点，需要自带下一节点，这就是 C++ 实现中 <code>new ListNode(0, new ListNode(0))</code> 的由来。</p></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(n)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* root = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">helper</span>(l1, l2, root);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(ListNode* l1, ListNode* l2, ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1 &amp;&amp; !l2) &#123;</span><br><span class="line">            node-&gt;next = node-&gt;next-&gt;val ? node-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        <span class="keyword">int</span> sum = node-&gt;val +</span><br><span class="line">            (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>);</span><br><span class="line">        node-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">        node-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum/<span class="number">10</span>);</span><br><span class="line">        l1 = l1 ? l1-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        l2 = l2 ? l2-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(l1, l2, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：循环"><a href="#解法二：循环" class="headerlink" title="解法二：循环"></a>解法二：循环</h2><p>思路基本上与<a href="#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9A%E9%80%92%E5%BD%92">解法一</a>保持一致，只是将递归形式改为循环形式，同时写法上更加 neat。</p><blockquote><p>参考：<a href="https://leetcode.com/problems/add-two-numbers/discuss/997/c++-Sharing-my-11-line-c++-solution-can-someone-make-it-even-more-concise">https://leetcode.com/problems/add-two-numbers/discuss/997/c++-Sharing-my-11-line-c++-solution-can-someone-make-it-even-more-concise</a></p></blockquote><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(n)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode root(0), *node = &amp;root;</span><br><span class="line">        <span class="keyword">int</span> extra = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || extra) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = extra + </span><br><span class="line">                (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>);</span><br><span class="line">            extra = sum/<span class="number">10</span>;</span><br><span class="line">            node-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            l1 = l1 ? l1-&gt;next : l1;</span><br><span class="line">            l2 = l2 ? l2-&gt;next : l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/add-two-numbers/&quot;&gt;https://leetcode.com/problems/add-two-numbers/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h3&gt;&lt;p&gt;将两个数字的每一位，逆序地拆成两个链表 &lt;code&gt;l1&lt;/code&gt; 和 &lt;code&gt;l2&lt;/code&gt;，计算这两个数字的和，结果以同样顺序的链表表示。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="LeetCode Problems" scheme="https://progcz.com/categories/A03-LeetCode/LeetCode-Problems/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Linked List" scheme="https://progcz.com/tags/Linked-List/"/>
    
    <category term="Math" scheme="https://progcz.com/tags/Math/"/>
    
    <category term="Recursion" scheme="https://progcz.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Problem 1 - Two Sum</title>
    <link href="https://progcz.com/posts/leetcode-problem-two-sum/"/>
    <id>https://progcz.com/posts/leetcode-problem-two-sum/</id>
    <published>2021-02-17T15:48:43.000Z</published>
    <updated>2021-02-19T15:49:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/two-sum/">https://leetcode.com/problems/two-sum/</a></p><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定数组 <code>nums</code> 和数字 <code>target</code>，要求在 <code>nums</code> 中找到两个数字，和为 <code>target</code>，返回这两个数字的下标。</p><p>保证有且只有一个解，而且同一个数字不能用两次。</p><span id="more"></span><h2 id="解法一：两层循环，暴力破解"><a href="#解法一：两层循环，暴力破解" class="headerlink" title="解法一：两层循环，暴力破解"></a>解法一：两层循环，暴力破解</h2><p>两层循环，遍历所有可能的数字组合，找到则返回下标。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(1)</code></p></li><li><p>时间：<code>O(n^2)</code></p></li></ul><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：借助-hash-map，用空间换时间"><a href="#解法二：借助-hash-map，用空间换时间" class="headerlink" title="解法二：借助 hash_map，用空间换时间"></a>解法二：借助 <code>hash_map</code>，用空间换时间</h2><p>既可以使用两次循环：</p><ul><li><p>第一次循环完成「记录」：借助 <code>hash_map</code>，建立数字 <code>target-nums[i]</code> 和下标 <code>i</code> 之间的映射。</p></li><li><p>第二次循环进行「查询」：如果数字 <code>nums[i]</code> 存在于 <code>hash_map</code> 中，而且不是同一数字（下标不同），说明可以「配对」，则返回该数字下标和 <code>hash_map</code> 中记录的另一数字下标。</p></li></ul><p>也可以使用单次循环：</p><ul><li>单次循环合并「记录」和「查询」：如果数字 <code>nums[i]</code> 存在于 <code>hash_map</code> 中，说明可以「配对」，则返回该数字下标和 <code>hash_map</code> 中记录的另一数字下标，否则建立数字 <code>target-nums[i]</code> 和下标 <code>i</code> 之间的映射。</li></ul><blockquote><p>单次循环参考：<a href="https://leetcode.com/problems/two-sum/discuss/13/Accepted-C++-O(n)-Solution/263">https://leetcode.com/problems/two-sum/discuss/13/Accepted-C++-O(n)-Solution/263</a></p></blockquote><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(n)</code>（不太确定）</p></li><li><p>时间：<code>O(n)</code></p><ul><li><code>hash_map</code> 插入、查询、删除的操作，时间复杂度均为 <code>O(1)</code>。</li></ul></li></ul><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><p>两次循环：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; um = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            um[target-nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (um.<span class="built_in">find</span>(nums[i]) != um.<span class="built_in">end</span>() &amp;&amp;</span><br><span class="line">                um[nums[i]] != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;um[nums[i]], i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>单次循环：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; um;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (um.<span class="built_in">find</span>(nums[i]) != um.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;um[nums[i]], i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            um[target-nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/two-sum/&quot;&gt;https://leetcode.com/problems/two-sum/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h3&gt;&lt;p&gt;给定数组 &lt;code&gt;nums&lt;/code&gt; 和数字 &lt;code&gt;target&lt;/code&gt;，要求在 &lt;code&gt;nums&lt;/code&gt; 中找到两个数字，和为 &lt;code&gt;target&lt;/code&gt;，返回这两个数字的下标。&lt;/p&gt;
&lt;p&gt;保证有且只有一个解，而且同一个数字不能用两次。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="LeetCode Problems" scheme="https://progcz.com/categories/A03-LeetCode/LeetCode-Problems/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Array" scheme="https://progcz.com/tags/Array/"/>
    
    <category term="Hash Table" scheme="https://progcz.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>充满仪式感的「全年总结」和不太可能坚持下去的「新年计划」</title>
    <link href="https://progcz.com/posts/summary-for-past-year-and-plan-for-new-year/"/>
    <id>https://progcz.com/posts/summary-for-past-year-and-plan-for-new-year/</id>
    <published>2021-01-02T12:34:35.000Z</published>
    <updated>2021-01-02T12:34:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>即使新建好了文档，我依然不知道到底该写些什么，但是「写」这个念头就像只怎么也赶不走的乌鸦，一直在我的头顶盘旋。</p><p>也许确实是因为仪式感吧，<strong>每到了辞旧迎新的时候，总该有些「落在纸面」的文字，先跟过去的一年和解，再把自己交代给未来的一年。</strong></p><p>也罢，就让我这个记忆力和行动力都逐渐退化的人，来一场「全年总结」和「新年计划」吧！</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/01.jpg" style="zoom:100%"/><span id="more"></span><h2 id="1-全年总结"><a href="#1-全年总结" class="headerlink" title="1 全年总结"></a>1 全年总结</h2><h3 id="1-1-失去的五个月"><a href="#1-1-失去的五个月" class="headerlink" title="1.1 失去的五个月"></a>1.1 失去的五个月</h3><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/02.jpg" style="zoom:100%"/><p>但凡回顾 2020，疫情是怎么都绕不开的话题。</p><p>不论性别，不论国籍，不论贫穷或富有，不论疾病或健康，只要你还是这颗蓝色星球上的原住民，或多或少都会受到疫情的影响，唯一的区别就在于这个「或多或少」。</p><p>非常幸运，也非常惭愧，我是「或少」中的一员。</p><p>不管是磕磕绊绊但还是顺利完成了的学位答辩，还是在家只吃不动而逐渐狂妄的体重涨幅，在这场全人类都无法幸免的灾难面前，看上去都是小事。</p><p>因此，我始终对在疫情中离开人世的生命感到惋惜，他们一定也在 2020 年伊始时，怀揣着对新年的希望，如今归于尘土；我也始终对在疫情中奋战在一线的医护人员保持敬意，他们以血肉之躯，构筑起保护我们的钢铁长城。</p><div class="note warning"><p>写得越来越像高考作文了。</p><p>Whatever, it’s just the way how i was raised and educated.</p></div><p>不是超级英雄，<strong>只能保护好自己，照顾好家人，足够了。</strong></p><h3 id="1-2-十九年寒窗"><a href="#1-2-十九年寒窗" class="headerlink" title="1.2 十九年寒窗"></a>1.2 十九年寒窗</h3><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/03.jpg" style="zoom:100%"/><p>毕业算是改变人生的事情当中，意外指数最低的事情了吧。</p><p>在这种意义下，与其说是改变人生，<strong>不如说是人生早就被安排成了列车的时刻表，毕业这件事情就在单线轨道的某个站点上等着，没有丝毫悬念。</strong></p><p>虽然，我今年所面临的毕业，与以往的毕业不尽相同：</p><ul><li><p>以往的毕业，从学校到学校，换了环境而已，依然是衣食无忧的学生，终极目标不过是分数、绩点和排名。</p></li><li><p>今年的毕业，从学校到公司，真正意义上的经济独立，终极目标切换成房子、车子和存款。</p></li></ul><p>当然，还是很感谢曾经作为学生的自己，至少为我打好了阶级跃迁的基础，在人生这一新的阶段能多抢跑几秒钟。</p><h3 id="1-3-职场与人生"><a href="#1-3-职场与人生" class="headerlink" title="1.3 职场与人生"></a>1.3 职场与人生</h3><p>互联网大厂的程序员工作，一言以蔽之：节奏快，工作忙，身体累。</p><p>比起初入职场的感想，我更想探讨的是，在人生意义这个问题上的心态转变。</p><p>这是个老生常谈的哲学命题，我明白。但我还是想说说自己的理解。</p><p>过去的二十几年，从我记事开始，我就一直在为别人而活。</p><p>说起来非常简单的生活：作为学生，考试考个好成绩；作为儿女，听长辈的话。这样，父母就会很开心，长辈就会称赞我（不管是不是虚情假意），同学也会尊重我（即便是以对待书呆子的态度）。</p><p>我好像从来没想过，自己想要什么。</p><p>或者说，是周围的人告诉我的「我想要的」：努力学习，努力赚钱，有套自己的房子，有个幸福的家庭。</p><p>直到我开始问我自己：然后呢？这一切之后呢？从生到死，人这一生到底是为了什么呢？</p><p>过去的一年里，我反复地思考人生的意义，在上下班通勤的路上，在漫长而枯燥的旅途中，在每个放纵自己而熬到很困的深夜里。</p><p>而每次我都只能得到同一个答案：<strong>人生的意义是为了开心，为了愉悦的体验，为了舒适的生活。</strong></p><p>又是个老生常谈的答案，我明白。但这次，我是真的相信它了。</p><h2 id="2-新年计划"><a href="#2-新年计划" class="headerlink" title="2 新年计划"></a>2 新年计划</h2><h3 id="2-1-工作"><a href="#2-1-工作" class="headerlink" title="2.1 工作"></a>2.1 工作</h3><p>无他，努力工作，赚钱买房。</p><div class="note warning"><p>但是要牢记的是，身体是革命的本钱！任何事情的达成都不能以牺牲身体健康为前提。</p></div><h3 id="2-2-读书"><a href="#2-2-读书" class="headerlink" title="2.2 读书"></a>2.2 读书</h3><p>在将 kindle 上未读的书目消灭至只有个位数之前，不再囤书了。</p><p>至于数量，不想做硬性要求，只求在有大块时间和舒适状态的时候，能想起来读书，而不是刷手机/看视频。</p><h3 id="2-3-按摩-健身"><a href="#2-3-按摩-健身" class="headerlink" title="2.3 按摩/健身"></a>2.3 按摩/健身</h3><p>每周二按摩，每周四健身。</p><h3 id="2-4-旅游"><a href="#2-4-旅游" class="headerlink" title="2.4 旅游"></a>2.4 旅游</h3><p>希望每年能有一次旅游，实际上 2021 的额度已经分给厦门了，毕竟厦大百年校庆，是时候回去看看了。</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/04.jpg" style="zoom:100%"/><hr><h2 id="3-番外"><a href="#3-番外" class="headerlink" title="3 番外"></a>3 番外</h2><p>新年第一天，去撸了猫猫狗狗，希望能把这份开心延续一整年吧。</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/05.jpg" style="zoom:100%"/>]]></content>
    
    
    <summary type="html">&lt;p&gt;即使新建好了文档，我依然不知道到底该写些什么，但是「写」这个念头就像只怎么也赶不走的乌鸦，一直在我的头顶盘旋。&lt;/p&gt;
&lt;p&gt;也许确实是因为仪式感吧，&lt;strong&gt;每到了辞旧迎新的时候，总该有些「落在纸面」的文字，先跟过去的一年和解，再把自己交代给未来的一年。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也罢，就让我这个记忆力和行动力都逐渐退化的人，来一场「全年总结」和「新年计划」吧！&lt;/p&gt;
&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/01.jpg&quot; style=&quot;zoom:100%&quot;/&gt;</summary>
    
    
    
    <category term="A00 - 总结与计划" scheme="https://progcz.com/categories/A00-%E6%80%BB%E7%BB%93%E4%B8%8E%E8%AE%A1%E5%88%92/"/>
    
    
    <category term="Plan" scheme="https://progcz.com/tags/Plan/"/>
    
    <category term="Summary" scheme="https://progcz.com/tags/Summary/"/>
    
    <category term="Happiness" scheme="https://progcz.com/tags/Happiness/"/>
    
  </entry>
  
  <entry>
    <title>2020 August LeetCoding Challenge - Week 2</title>
    <link href="https://progcz.com/posts/2020-august-leetcoding-challenge-week-2/"/>
    <id>https://progcz.com/posts/2020-august-leetcoding-challenge-week-2/</id>
    <published>2020-08-08T15:36:56.000Z</published>
    <updated>2020-08-16T02:42:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 八月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-August-LeetCoding-Challenge/">2020 August LeetCoding Challenge</a> 查看更多。</p><span id="more"></span><h2 id="August-8th-Path-Sum-III"><a href="#August-8th-Path-Sum-III" class="headerlink" title="August 8th: Path Sum III"></a>August 8th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/550/week-2-august-8th-august-14th/3417/">Path Sum III</a></h2><p>You are given a binary tree in which each node contains an integer value.</p><p>Find the number of paths that sum to a given value.</p><p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p><p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     &#x2F;  \</span><br><span class="line">    5   -3</span><br><span class="line">   &#x2F; \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用函数 <code>func</code> 对树进行深度优先搜索，对以 <code>node</code> 为起点且满足题目要求的路径进行计数。</p><p><code>pathSum(root-&gt;left, sum)</code> 和 <code>pathSum(root-&gt;right, sum)</code> 则是分别给左右节点一次「重新开始」的机会。</p><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(root, sum) + <span class="built_in">pathSum</span>(root-&gt;left, sum) + <span class="built_in">pathSum</span>(root-&gt;right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(TreeNode *node,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = node-&gt;val==sum ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="built_in">func</span>(node-&gt;left, sum-node-&gt;val) + <span class="built_in">func</span>(node-&gt;right, sum-node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>终究还是没能在工作日坚持下来，这个系列终止吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 八月挑战专题每日随缘更新，点击类别 &lt;a href=&quot;/categories/2020-August-LeetCoding-Challenge/&quot;&gt;2020 August LeetCoding Challenge&lt;/a&gt; 查看更多。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="2020 LeetCoding Challenge" scheme="https://progcz.com/categories/A03-LeetCode/2020-LeetCoding-Challenge/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Data Structure and Algorithm" scheme="https://progcz.com/tags/Data-Structure-and-Algorithm/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Challenge" scheme="https://progcz.com/tags/Challenge/"/>
    
  </entry>
  
  <entry>
    <title>2020 August LeetCoding Challenge - Week 1</title>
    <link href="https://progcz.com/posts/2020-august-leetcoding-challenge-week-1/"/>
    <id>https://progcz.com/posts/2020-august-leetcoding-challenge-week-1/</id>
    <published>2020-08-01T07:37:02.000Z</published>
    <updated>2020-08-08T03:31:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 八月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-August-LeetCoding-Challenge/">2020 August LeetCoding Challenge</a> 查看更多。</p><span id="more"></span><h2 id="August-1st-Detect-Capital"><a href="#August-1st-Detect-Capital" class="headerlink" title="August 1st: Detect Capital"></a>August 1st: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3409/">Detect Capital</a></h2><p>Given a word, you need to judge whether the usage of capitals in it is right or not.</p><p>We define the usage of capitals in a word to be right when one of the following cases holds:</p><ul><li><p>All letters in this word are capitals, like “USA”.</p></li><li><p>All letters in this word are not capitals, like “leetcode”.</p></li><li><p>Only the first letter in this word is capital, like “Google”.</p></li></ul><p>Otherwise, we define that this word doesn’t use capitals in a right way.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;USA&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;FlaG&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> The input will be a non-empty word consisting of uppercase and lowercase latin letters.</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>不管字符串 <code>word</code> 的写法是否正确，我都可以列举出其三种正确的写法，放入集合 <code>s</code> 中，判断最初的 <code>word</code> 是否存在于 <code>s</code> 中即可。</p><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">detectCapitalUse</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;string&gt; s;</span><br><span class="line">        string word_cp = word;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : word_cp) &#123;</span><br><span class="line">            ch = <span class="built_in">tolower</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">insert</span>(word_cp);</span><br><span class="line">        word_cp[<span class="number">0</span>] = <span class="built_in">toupper</span>(word_cp[<span class="number">0</span>]);</span><br><span class="line">        s.<span class="built_in">insert</span>(word_cp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : word_cp) &#123;</span><br><span class="line">            ch = <span class="built_in">toupper</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">insert</span>(word_cp);</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">find</span>(word) != s.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-2nd-Design-HashSet"><a href="#August-2nd-Design-HashSet" class="headerlink" title="August 2nd: Design HashSet"></a>August 2nd: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3410/">Design HashSet</a></h2><p>Design a HashSet without using any built-in hash table libraries.</p><p>To be specific, your design should include these functions:</p><ul><li><p><code>add(value)</code>: Insert a value into the HashSet.</p></li><li><p><code>contains(value)</code>: Return whether the value exists in the HashSet or not.</p></li><li><p><code>remove(value)</code>: Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing.</p></li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyHashSet hashSet &#x3D; new MyHashSet();</span><br><span class="line">hashSet.add(1);</span><br><span class="line">hashSet.add(2);</span><br><span class="line">hashSet.contains(1);    &#x2F;&#x2F; returns true</span><br><span class="line">hashSet.contains(3);    &#x2F;&#x2F; returns false (not found)</span><br><span class="line">hashSet.add(2);</span><br><span class="line">hashSet.contains(2);    &#x2F;&#x2F; returns true</span><br><span class="line">hashSet.remove(2);</span><br><span class="line">hashSet.contains(2);    &#x2F;&#x2F; returns false (already removed)</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p>All values will be in the range of <code>[0, 1000000]</code>.</p></li><li><p>The number of operations will be in the range of <code>[1, 10000]</code>.</p></li><li><p>Please do not use the built-in HashSet library.</p></li></ul><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>采用哈希函数 + 单向链表，将 <code>key</code> 取模后在链表中添加、删除和查找。</p><p>P.S. 空间换时间，当然可以把 <code>mod</code> 直接赋值为 <code>1000001</code>。</p><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyHashSet</span>() : <span class="built_in">mod</span>(<span class="number">1000</span>) &#123;</span><br><span class="line">        v.<span class="built_in">resize</span>(mod);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        v[key%mod].<span class="built_in">push_front</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        v[key%mod].<span class="built_in">remove</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;val : v[key%mod]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mod;</span><br><span class="line">    vector&lt;forward_list&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyHashSet* obj = new MyHashSet();</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;remove(key);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;contains(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="August-3rd-Valid-Palindrome"><a href="#August-3rd-Valid-Palindrome" class="headerlink" title="August 3rd: Valid Palindrome"></a>August 3rd: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3411/">Valid Palindrome</a></h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p><strong>Note:</strong> For the purpose of this problem, we define empty string as valid palindrome.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;race a car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>s</code> consists only of printable ASCII characters.</li></ul><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用首尾指针 <code>beg</code> 和 <code>end</code> 进行比较，如果不是数字或字母，直接跳过。</p><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> beg = <span class="number">0</span>, end = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (beg &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(s[beg])) &#123;</span><br><span class="line">                ++beg;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(s[end])) &#123;</span><br><span class="line">                --end;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[beg]) != <span class="built_in">tolower</span>(s[end])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++beg;</span><br><span class="line">            --end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-4th-Power-of-Four"><a href="#August-4th-Power-of-Four" class="headerlink" title="August 4th: Power of Four"></a>August 4th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3412/">Power of Four</a></h2><p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 16</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>每次累乘 4，实际上都是将二进制形式左移 2 位，循环判断即可。</p><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-5th-Add-and-Search-Word-Data-structure-design"><a href="#August-5th-Add-and-Search-Word-Data-structure-design" class="headerlink" title="August 5th: Add and Search Word - Data structure design"></a>August 5th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3413/">Add and Search Word - Data structure design</a></h2><p>Design a data structure that supports the following two operations:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void addWord(word)</span><br><span class="line">bool search(word)</span><br></pre></td></tr></table></figure><p>search(word) can search a literal word or a regular expression string containing only letters <code>a-z</code> or <code>.</code>. A <code>.</code> means it can represent any one letter.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addWord(&quot;bad&quot;)</span><br><span class="line">addWord(&quot;dad&quot;)</span><br><span class="line">addWord(&quot;mad&quot;)</span><br><span class="line">search(&quot;pad&quot;) -&gt; false</span><br><span class="line">search(&quot;bad&quot;) -&gt; true</span><br><span class="line">search(&quot;.ad&quot;) -&gt; true</span><br><span class="line">search(&quot;b..&quot;) -&gt; true</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>You may assume that all words are consist of lowercase letters <code>a-z</code>.</p><h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用 <code>um</code> 建立从字符串长度至字符串数组的映射，从而在查询的时候降低时间复杂度。妙啊。</p><h4 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">WordDictionary</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds a word into the data structure. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        um[word.<span class="built_in">size</span>()].<span class="built_in">push_back</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character &#x27;.&#x27; to represent any one letter. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str : um[word.<span class="built_in">size</span>()]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">is_match</span>(str, word)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_match</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[i] == <span class="string">&#x27;.&#x27;</span> || word2[i] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (word1[i] != word2[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, vector&lt;string&gt;&gt; um;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary* obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addWord(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="August-6th-Find-All-Duplicates-in-an-Array"><a href="#August-6th-Find-All-Duplicates-in-an-Array" class="headerlink" title="August 6th: Find All Duplicates in an Array"></a>August 6th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3414/">Find All Duplicates in an Array</a></h2><p>Given an array of integers, <code>1 ≤ a[i] ≤ n</code> (<code>n</code> = size of array), some elements appear <strong>twice</strong> and others appear <strong>once</strong>.</p><p>Find all the elements that appear <strong>twice</strong> in this array.</p><p>Could you do it without extra space and in <code>O(n)</code> runtime?</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[2,3]</span><br></pre></td></tr></table></figure><h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>没啥好说的，直接看代码吧。</p><h4 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; um;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            ++um[num];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : um) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t.second == <span class="number">2</span>) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(t.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-7th-Vertical-Order-Traversal-of-a-Binary-Tree"><a href="#August-7th-Vertical-Order-Traversal-of-a-Binary-Tree" class="headerlink" title="August 7th: Vertical Order Traversal of a Binary Tree"></a>August 7th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3415/">Vertical Order Traversal of a Binary Tree</a></h2><p>Given a binary tree, return the vertical order traversal of its nodes values.</p><p>For each node at position <code>(X, Y)</code>, its left and right children respectively will be at positions <code>(X-1, Y-1)</code> and <code>(X+1, Y-1)</code>.</p><p>Running a vertical line from <code>X = -infinity</code> to <code>X = +infinity</code>, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing <code>Y</code> coordinates).</p><p>If two nodes have the same position, then the value of the node that is reported first is the value that is smaller.</p><p>Return an list of non-empty reports in order of <code>X</code> coordinate.  Every report will have a list of values of nodes.</p><p><strong>Example 1:</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/06.png" style="zoom:100%"/><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[9],[3,15],[20],[7]]</span><br><span class="line">Explanation:</span><br><span class="line">Without loss of generality, we can assume the root node is at position (0, 0):</span><br><span class="line">Then, the node with value 9 occurs at position (-1, -1);</span><br><span class="line">The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2);</span><br><span class="line">The node with value 20 occurs at position (1, -1);</span><br><span class="line">The node with value 7 occurs at position (2, -2).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/07.png" style="zoom:50%"/><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7]</span><br><span class="line">Output: [[4],[2],[1,5,6],[3],[7]]</span><br><span class="line">Explanation:</span><br><span class="line">The node with value 5 and the node with value 6 have the same position according to the given scheme.</span><br><span class="line">However, in the report &quot;[1,5,6]&quot;, the node value of 5 comes first since 5 is smaller than 6.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><p>The tree will have between <code>1</code> and <code>1000</code> nodes.</p></li><li><p>Each node’s value will be between <code>0</code> and <code>1000</code>.</p></li></ol><h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，核心在于这个声明：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;&gt; m;</span><br></pre></td></tr></table></figure><p><strong>第一个 <code>int</code> 代表节点的 <code>x</code> 坐标，第二个 <code>int</code> 代表节点的 <code>y</code> 坐标，<code>vector&lt;int&gt;</code> 存放节点的值；而且，<code>x</code> 坐标按照默认升序排列，<code>y</code> 坐标按照指定降序排列，适应题目要求。</strong></p><p>其次，使用函数 <code>func</code> 遍历树，存放至对应的 <code>vector&lt;int&gt;</code> 中。</p><p>最后，遍历 <code>m</code>，将 <code>x</code> 坐标相同的点合并到 <code>v</code> 中，组织为 <code>res</code> 即可。</p><h4 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">verticalTraversal</span>(TreeNode* root) &#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;&gt; m;</span><br><span class="line">        <span class="built_in">func</span>(root, <span class="number">0</span>, <span class="number">0</span>, m);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> imp : m) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> ivp : imp.second) &#123;</span><br><span class="line">                <span class="built_in">sort</span>(ivp.second.<span class="built_in">begin</span>(), ivp.second.<span class="built_in">end</span>());</span><br><span class="line">                v.<span class="built_in">insert</span>(v.<span class="built_in">end</span>(), ivp.second.<span class="built_in">begin</span>(), ivp.second.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(TreeNode *node, <span class="keyword">int</span> x, <span class="keyword">int</span> y,</span></span></span><br><span class="line"><span class="function"><span class="params">              map&lt;<span class="keyword">int</span>, map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;&gt; &amp;m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        m[x][y].<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="built_in">func</span>(node-&gt;left, x<span class="number">-1</span>, y<span class="number">-1</span>, m);</span><br><span class="line">        <span class="built_in">func</span>(node-&gt;right, x+<span class="number">1</span>, y<span class="number">-1</span>, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 八月挑战专题每日随缘更新，点击类别 &lt;a href=&quot;/categories/2020-August-LeetCoding-Challenge/&quot;&gt;2020 August LeetCoding Challenge&lt;/a&gt; 查看更多。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="2020 LeetCoding Challenge" scheme="https://progcz.com/categories/A03-LeetCode/2020-LeetCoding-Challenge/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Data Structure and Algorithm" scheme="https://progcz.com/tags/Data-Structure-and-Algorithm/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Challenge" scheme="https://progcz.com/tags/Challenge/"/>
    
  </entry>
  
  <entry>
    <title>我的工作桌面长啥样</title>
    <link href="https://progcz.com/posts/what-does-my-work-desktop-look-like/"/>
    <id>https://progcz.com/posts/what-does-my-work-desktop-look-like/</id>
    <published>2020-08-01T07:11:15.000Z</published>
    <updated>2021-05-31T00:57:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉，已经入职两个月了。</p><p>在这两个月里，我一直在适应工作节奏，所以没有时间更新博客（虽然也没什么人看）。</p><p>在这两个月里，我的工作桌面也在不断进化，不断适应我的使用习惯，到现在也算是个初级形态了，所以打算在这里梳理一下（其实就是想晒装备）。</p><p>先来张工作桌面的整体照片过过瘾：</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/00.png" style="zoom:100%"/><span id="more"></span><h2 id="1-「公司发的」MacBook-Pro-16"><a href="#1-「公司发的」MacBook-Pro-16" class="headerlink" title="1 「公司发的」MacBook Pro 16"></a>1 「公司发的」MacBook Pro 16</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/01.png" style="zoom:100%"/><p>整个桌面都是围绕着 MacBook Pro 16 来布置的，具体配置：</p><table><thead><tr><th>条目</th><th>明细</th></tr></thead><tbody><tr><td>处理器</td><td>2.6 GHz 6‑core Intel Core i7</td></tr><tr><td>图形卡-1</td><td>AMD Radeon Pro 5300M 4 GB</td></tr><tr><td>图形卡-2</td><td>Intel UHD Graphics 630 1536 MB</td></tr><tr><td>内存</td><td>16 GB 2667 MHz DDR4</td></tr><tr><td>储存空间</td><td>512 GB SSD</td></tr></tbody></table><p>我已经过了那个对配置敏感的年纪，拿到这个电脑之后也只会感叹「好漂亮」和「好流畅」了。</p><p>在日常开发中，MacBook Pro 的性能确实绰绰有余，毕竟编译之类的苦差事都是在远程开发机上完成的，本地只是开开 Chrome 和 VS Code 而已。</p><p>P.S. 散热架也是公司发的，感觉薅了太多羊毛。</p><h2 id="2-「公司发的」Dell-U2720Q-4K-显示器"><a href="#2-「公司发的」Dell-U2720Q-4K-显示器" class="headerlink" title="2 「公司发的」Dell U2720Q 4K 显示器"></a>2 「公司发的」Dell U2720Q 4K 显示器</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/02.png" style="zoom:100%"/><p>两台 4K 显示器的幸福，我以前无法想象，现在除了开会和回家以外，MacBook Pro 基本上都是合盖的状态，因为两个显示器已经够我看的了，多了怕鼠标都挪不过来。</p><p>另外一个让人感到幸福的细节，就是可以使用单根 Type-C 数据线合并「显示」、「充电」和「扩展」的功能，显示器的下行接口可以外接键盘和鼠标，极大地节约了 MacBook Pro 的接口数量。</p><p>但是我有两台显示器，为了达到显示的最佳效果，还是不可避免地占用了 MacBook Pro 的两个接口。</p><h2 id="3-「自己买的」DURGOD-TAURUS-K320-茶轴机械键盘"><a href="#3-「自己买的」DURGOD-TAURUS-K320-茶轴机械键盘" class="headerlink" title="3 「自己买的」DURGOD TAURUS K320 茶轴机械键盘"></a>3 「自己买的」DURGOD TAURUS K320 茶轴机械键盘</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/03.png" style="zoom:100%"/><p>当时买这款机械键盘，主要是看中了 PBT 键帽，长期使用不打油的体验也是非常幸福。</p><h2 id="4-「自己买的」Logitech-MX-Master-2S-无线蓝牙鼠标"><a href="#4-「自己买的」Logitech-MX-Master-2S-无线蓝牙鼠标" class="headerlink" title="4 「自己买的」Logitech MX Master 2S 无线蓝牙鼠标"></a>4 「自己买的」Logitech MX Master 2S 无线蓝牙鼠标</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/04.png" style="zoom:50%"/><p>不解释，办公神器。</p><h2 id="5-「自己买的」AirPods-2-无线蓝牙耳机"><a href="#5-「自己买的」AirPods-2-无线蓝牙耳机" class="headerlink" title="5 「自己买的」AirPods 2 无线蓝牙耳机"></a>5 「自己买的」AirPods 2 无线蓝牙耳机</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/05.png" style="zoom:25%"/><p>MacBook Pro 的耳机孔在右侧，使用的有线耳机总是和使用鼠标的手发生干涉，所以我就入手了 AirPods，在一众无线蓝牙耳机中算是最省心的选择了，连接、音质和通话质量都足够稳定，别无他求。</p><h2 id="6-写在最后"><a href="#6-写在最后" class="headerlink" title="6 写在最后"></a>6 写在最后</h2><p>之前在 V2EX 看到一句话，与君共勉：</p><blockquote><p>入职以后，公司给每位员工发了一台电脑，表面上看是每个人拥有了一台电脑，其实是给每台电脑配了一个人。</p></blockquote><hr><h2 id="7-更新（2020-11-26）"><a href="#7-更新（2020-11-26）" class="headerlink" title="7 更新（2020-11-26）"></a>7 更新（2020-11-26）</h2><p>惯例，先放张工作桌面 2.0 的整体照片：</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/11/00.jpg" style="zoom:100%"/><p>改动：</p><ul><li><p>常年合盖使用的 MBP 被我挪到了左侧，这样键盘就可以向前推进，得到伸展的手臂感觉舒适了许多。</p></li><li><p>两个显示器都用包装盒架起了一定的高度，仰在椅子上的时候视线更加舒服了。</p></li><li><p>AirPods 2 =&gt; AirPods Pro，网吧工位少不了降噪。</p></li></ul><h2 id="8-更新（2021-05-31）"><a href="#8-更新（2021-05-31）" class="headerlink" title="8 更新（2021-05-31）"></a>8 更新（2021-05-31）</h2><p>可能是最终形态的工作桌面 3.0：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/11.png"></p><p>改动：</p><ul><li><p>MBP 16 背着实在有点重，换成 MBP 13</p></li><li><p>双屏虽然爽，但是没啥用，所以归还其中一个显示器，只看正面的显示器</p></li><li><p>键盘从杜咖茶轴换成阿米洛红轴，键位与 Mac 自带键盘保持一致</p></li><li><p>常年用鼠标，右手手指关节十分痛苦，所以换成妙控板，左右手交替操作</p></li><li><p>手机换成 iPhone 12 mini，和 AirPods Pro 都可以无线充电，所以买了绿联的无线充电板，随用随充</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;不知不觉，已经入职两个月了。&lt;/p&gt;
&lt;p&gt;在这两个月里，我一直在适应工作节奏，所以没有时间更新博客（虽然也没什么人看）。&lt;/p&gt;
&lt;p&gt;在这两个月里，我的工作桌面也在不断进化，不断适应我的使用习惯，到现在也算是个初级形态了，所以打算在这里梳理一下（其实就是想晒装备）。&lt;/p&gt;
&lt;p&gt;先来张工作桌面的整体照片过过瘾：&lt;/p&gt;
&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/00.png&quot; style=&quot;zoom:100%&quot;/&gt;</summary>
    
    
    
    <category term="A01 - 生活随笔" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="折腾" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="Work" scheme="https://progcz.com/tags/Work/"/>
    
    <category term="Desktop" scheme="https://progcz.com/tags/Desktop/"/>
    
    <category term="MacBook Pro" scheme="https://progcz.com/tags/MacBook-Pro/"/>
    
  </entry>
  
  <entry>
    <title>记录一次在上海租房的经历</title>
    <link href="https://progcz.com/posts/record-for-rent-in-shanghai/"/>
    <id>https://progcz.com/posts/record-for-rent-in-shanghai/</id>
    <published>2020-06-13T07:08:48.000Z</published>
    <updated>2020-06-13T07:08:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>入职之前，我预留了一周的时间用来租房，本以为做好了充足的准备，但还是碰到了很多「租房新手」必踩的坑。果然，<strong>小马还是要自己过一遍河才能知道河水的深浅。</strong></p><p>所以，趁着自己的记忆还够新鲜，记录一下这次在上海租房的经历，为以后的自己留下亿点经验和教训。</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/06/00.png" style="zoom:100%"/><span id="more"></span><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1 需求"></a>1 需求</h2><p>在租房之前，需要<strong>梳理一遍自己的需求，哪些是必不可少的，哪些是可以妥协的。</strong></p><p>当然，下面列出的这些需求仅适用于我个人，读者需要自行甄别。</p><h3 id="1-1-必不可少的"><a href="#1-1-必不可少的" class="headerlink" title="1.1 必不可少的"></a>1.1 必不可少的</h3><div class="note warning"><p>对于「必不可少的」需求，一旦确定之后，即便中介再怎么花言巧语，也不能有半点动摇。</p></div><ul><li><p><strong>距离公司的步行时间不超过 15 分钟，</strong>能够有效提升幸福感。</p></li><li><p><strong>房子不在一楼或顶楼，</strong>避免一楼的过于潮湿和顶楼的过冷过热。</p></li><li><p><strong>房间的装修时间至少在一年以上，</strong>避免存在甲醛和苯等污染问题。</p><p>我刚开始租的就是新装修了一个月的房间，年少无知的我觉得只要通风就好了，结果在房间里面待了几个小时之后，嗓子就开始不舒服。所以，我只租了几天，就直接与房东违约，押金自然要不回来了，肉疼但还是保命要紧。</p></li><li><p><strong>独立卫生间，不必与他人分享马桶和浴室，</strong>不管从时间还是空间的角度，都能够有效提升幸福感。</p><p>预算充足的话，可以考虑<strong>「整租」独立的一居室</strong>；预算有限的话，可以考虑<strong>「合租」带独卫的卧室</strong>。</p></li><li><p><strong>家具和家电：床、空调、衣柜、洗衣机、热水器。</strong></p></li></ul><h3 id="1-2-可以妥协的"><a href="#1-2-可以妥协的" class="headerlink" title="1.2 可以妥协的"></a>1.2 可以妥协的</h3><ul><li><p><strong>可以晾衣服的地方。</strong></p><p>预算充足的话，可以考虑<strong>朝南阳台</strong>；预算有限的话，可以考虑<strong>朝南外窗（带外置晾衣架）</strong>。</p><p>当然，朝北也是可以的，毕竟洗衣机甩干后的衣服只要再风干就可以了。</p></li><li><p><strong>厨房。</strong></p></li><li><p><strong>家具和家电：冰箱、电视、沙发。</strong></p></li></ul><h3 id="1-3-其他"><a href="#1-3-其他" class="headerlink" title="1.3 其他"></a>1.3 其他</h3><h4 id="1-3-1-关于二房东"><a href="#1-3-1-关于二房东" class="headerlink" title="1.3.1 关于二房东"></a>1.3.1 关于二房东</h4><p>我之前看过的很多租房攻略都有提到：千万不要租二房东的房子。</p><p>但是，其实有相当一部分的房源都来自<strong>「职业」二房东</strong>，这种二房东并不是真正的租客，而是因为原房东手中有闲置的房子而又怕麻烦，于是将房子出租给二房东，由二房东来管理出租的事情。真正应该避开的是<strong>「非职业」二房东</strong>，这种二房东是真正的租客，但是因为某些原因而不得已将其转租，在这种情况下就很难保障自己的租房权益。</p><p>所以，可以要求<strong>查看二房东的原租房合同和原房东的房产证。</strong>查看租房合同是否长达数年，就可以大致判断是否为「职业」二房东。而且，查看租房合同的开始日期，也可以大致判断房间的装修时间。</p><h4 id="1-3-2-关于隔断"><a href="#1-3-2-关于隔断" class="headerlink" title="1.3.2 关于隔断"></a>1.3.2 关于隔断</h4><p>预算有限的话，一般只能考虑隔断的房间了。但是，隔断属于违规建筑，其最大的风险在于<strong>房间可能随时会被政府强拆。</strong></p><p>所以，可以要求<strong>在租房合同中注明：如果房间因为违规建筑而导致乙方无法居住，那么不算乙方违约，甲方需退还押金和剩余租金。</strong></p><div class="note info"><p>问：如何判断隔断？</p><p>答：实地看房时敲一下四周的墙。如果声音很闷，就是原装的墙，如果声音很响，就是隔断的墙。</p></div><h2 id="2-找房"><a href="#2-找房" class="headerlink" title="2 找房"></a>2 找房</h2><h3 id="2-1-短租"><a href="#2-1-短租" class="headerlink" title="2.1 短租"></a>2.1 短租</h3><p>我没有短租过，但是个人感觉短租的话直接选择<strong>自如或蛋壳</strong>即可，省心省力且价格也没有高很多。</p><p>但是，自如或蛋壳被人诟病最多的就是污染问题，所以需要实地看房，感受一下房间内的空气质量。</p><h3 id="2-2-长租"><a href="#2-2-长租" class="headerlink" title="2.2 长租"></a>2.2 长租</h3><p>长租的话还是建议找当地的<strong>大中介</strong>，比如链家、我爱我家等。</p><h2 id="3-看房"><a href="#3-看房" class="headerlink" title="3 看房"></a>3 看房</h2><p>这一步主要是看房间是否满足需求，同时检查一下房间内设施的基本情况，包括但不仅限于：</p><ul><li><p>检查是否新装修，是否存在污染问题。</p></li><li><p>检查防盗门、窗户是否完好。</p></li><li><p>检查家具、家电是否老化。</p></li><li><p>检查水管是否通畅、电路是否老化。</p></li><li><p>检查卫生情况。</p></li></ul><h2 id="4-签订合同"><a href="#4-签订合同" class="headerlink" title="4 签订合同"></a>4 签订合同</h2><p>大中介的合同一般没有什么问题，只是需要注意以下几点：</p><ul><li><p><strong>明确费用明细，</strong>包括但不仅限于：押金、房租、中介费、服务费、物业费、水电费、煤气费、宽带费、维修费等。</p></li><li><p><strong>明确房东和房客的违约条款。</strong></p></li><li><p><strong>拍照或录像记录房间内设施的基本情况，</strong>避免后续的维修纠纷。</p></li><li><p><strong>（独居女生尤其注意）与房东沟通是否可以换锁。</strong></p></li><li><p><strong>与房东当面签订合同，拍照留存房东的身份证、房产证，如果是二房东，拍照留存二房东的原租房合同和原房东的身份证、房产证。</strong></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;入职之前，我预留了一周的时间用来租房，本以为做好了充足的准备，但还是碰到了很多「租房新手」必踩的坑。果然，&lt;strong&gt;小马还是要自己过一遍河才能知道河水的深浅。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，趁着自己的记忆还够新鲜，记录一下这次在上海租房的经历，为以后的自己留下亿点经验和教训。&lt;/p&gt;
&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/06/00.png&quot; style=&quot;zoom:100%&quot;/&gt;</summary>
    
    
    
    <category term="A01 - 生活随笔" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="经历" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="Life" scheme="https://progcz.com/tags/Life/"/>
    
    <category term="Shanghai" scheme="https://progcz.com/tags/Shanghai/"/>
    
    <category term="Rent" scheme="https://progcz.com/tags/Rent/"/>
    
  </entry>
  
  <entry>
    <title>记录使用 IFTTT + Telegram 订阅 RSS 的推送模板</title>
    <link href="https://progcz.com/posts/record-use-ifttt-tg-sub-rss-push-template/"/>
    <id>https://progcz.com/posts/record-use-ifttt-tg-sub-rss-push-template/</id>
    <published>2020-05-24T10:30:11.000Z</published>
    <updated>2020-05-24T10:30:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于大部分使用 RSS 的人来说，RSS 最大的优势便是能够提供<strong>「聚合阅读」</strong>的功能，也就是在一个地方阅读多篇不同来源的文章，而且可以自主选择订阅源，拒绝推荐引擎的「投喂」。然而对于我来说，RSS 还有一个重要的作用在于能够提供<strong>「即时通知」</strong>的功能，也就是<strong>「一旦发生了什么，请立刻通知我」</strong>。</p><p>所以，为了实现<strong>「即时通知」</strong>的功能，<strong>可以使用 IFTTT 将 RSS 订阅内容推送至 Telegram 的对话、群组或公开频道，形成属于自己的「信息流」。</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/10.png" style="zoom:100%"/><span id="more"></span><h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0 写在前面"></a>0 写在前面</h2><p>本文不介绍具体教程，只记录其中使用的推送模板，留作以后参考。</p><p><strong>如果你想了解具体教程，推荐参考<a href="https://sword.studio/157.html">这篇文章</a>。</strong></p><p>另外，<strong>如果你也使用 <a href="https://docs.rsshub.app/">RSSHub</a>，推荐参考<a href="https://docs.rsshub.app/install/#bu-shu-dao-vercel-zeit-now">官方文档</a>将其部署至 <a href="https://vercel.com/">Vercel</a>，</strong>从而搭建属于自己的订阅引擎。</p><h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1 应用场景"></a>1 应用场景</h2><p>在 Telegram 中，我创建了两个公开频道，分别是：</p><ul><li><p><strong><a href="https://t.me/ProgCZChannel">ProgCZ’s Blog - Channel</a> 用于同步本博客更新的文章。</strong></p></li><li><p><strong><a href="https://t.me/ProgCZFlow">ProgCZ’s Flow</a> 用于建立专属于自己的信息流。</strong></p></li></ul><h2 id="2-推送模板"><a href="#2-推送模板" class="headerlink" title="2 推送模板"></a>2 推送模板</h2><p>在 IFTTT 中，需要设置推送模板，分为两种情况：</p><ul><li><p><strong>对于内容较多的订阅源（比如博客文章），只是推送其标题、链接和来源，</strong>模板如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标题：&lt;b&gt;&#123;&#123;EntryTitle&#125;&#125;&lt;&#x2F;b&gt;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">链接：&lt;b&gt;&#123;&#123;EntryUrl&#125;&#125;&lt;&#x2F;b&gt;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">来自：&lt;a href&#x3D;&quot;&#123;&#123;FeedUrl&#125;&#125;&quot;&gt;&#123;&#123;FeedTitle&#125;&#125;&lt;&#x2F;a&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure><p>同时，<strong>开启「网页预览」功能。</strong></p></li><li><p><strong>对于内容较少的订阅源（比如购物优惠），推送其标题、内容、链接和来源，</strong>模板如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标题：&lt;b&gt;&#123;&#123;EntryTitle&#125;&#125;&lt;&#x2F;b&gt;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&#123;&#123;EntryContent&#125;&#125;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">链接：&lt;b&gt;&#123;&#123;EntryUrl&#125;&#125;&lt;&#x2F;b&gt;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">来自：&lt;a href&#x3D;&quot;&#123;&#123;FeedUrl&#125;&#125;&quot;&gt;&#123;&#123;FeedTitle&#125;&#125;&lt;&#x2F;a&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure><p>同时，<strong>关闭「网页预览」功能。</strong></p></li></ul><h2 id="3-预览效果"><a href="#3-预览效果" class="headerlink" title="3 预览效果"></a>3 预览效果</h2><p>如果你想预览效果，可以在科学环境中访问 <a href="https://t.me/s/ProgCZChannel">ProgCZ’s Blog - Channel</a> 和 <a href="https://t.me/s/ProgCZFlow">ProgCZ’s Flow</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于大部分使用 RSS 的人来说，RSS 最大的优势便是能够提供&lt;strong&gt;「聚合阅读」&lt;/strong&gt;的功能，也就是在一个地方阅读多篇不同来源的文章，而且可以自主选择订阅源，拒绝推荐引擎的「投喂」。然而对于我来说，RSS 还有一个重要的作用在于能够提供&lt;strong&gt;「即时通知」&lt;/strong&gt;的功能，也就是&lt;strong&gt;「一旦发生了什么，请立刻通知我」&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以，为了实现&lt;strong&gt;「即时通知」&lt;/strong&gt;的功能，&lt;strong&gt;可以使用 IFTTT 将 RSS 订阅内容推送至 Telegram 的对话、群组或公开频道，形成属于自己的「信息流」。&lt;/strong&gt;&lt;/p&gt;
&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/10.png&quot; style=&quot;zoom:100%&quot;/&gt;</summary>
    
    
    
    <category term="A01 - 生活随笔" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="折腾" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="IFTTT" scheme="https://progcz.com/tags/IFTTT/"/>
    
    <category term="Telegram" scheme="https://progcz.com/tags/Telegram/"/>
    
    <category term="RSS" scheme="https://progcz.com/tags/RSS/"/>
    
  </entry>
  
  <entry>
    <title>使用 Cloudflare Workers 搭建 Google 和 GitHub 镜像网站</title>
    <link href="https://progcz.com/posts/use-cf-workers-build-google-and-github-mirrors/"/>
    <id>https://progcz.com/posts/use-cf-workers-build-google-and-github-mirrors/</id>
    <published>2020-05-23T13:32:58.000Z</published>
    <updated>2020-05-23T13:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于 Google 来说，虽然大部分时间都能够在科学环境中网上冲浪，但是<strong>难免有需要在普通环境中使用 Google 的情况，</strong>而对于 GitHub 来说，虽然目前可以无障碍访问，但是<strong>在普通环境中下载某些 Release（比如科学工具的客户端）的速度实在太慢。</strong></p><p>如果你也有和我一样的困扰，那么可以考虑<strong>使用 Cloudflare Workers 搭建属于自己的镜像网站，</strong>在普通环境中备用。</p><span id="more"></span><h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0 写在前面"></a>0 写在前面</h2><p>如果你只是在寻找临时的解决方案，而又不想费劲的话，那么可以直接使用我已经搭建好的镜像网站。</p><div class="note warning"><p>但是，请你务必遵守以下约定：</p><ol><li><p><strong>不滥用服务。</strong>因为每个 Cloudflare 账户每天只有 100,000 次请求的额度。</p></li><li><p><strong>不登录自己的任何账号。</strong>虽然我保证不拦截你的数据，但是防人之心不可无。</p></li><li><p><strong>不违反大陆的法律法规。</strong>虽然你需要科学，但是请保持理性。</p></li></ol></div><ul><li><p>Google 镜像网站：<a href="https://google.progcz.workers.dev/">https://google.progcz.workers.dev/</a></p></li><li><p>GitHub 镜像网站：<a href="https://github.progcz.workers.dev/">https://github.progcz.workers.dev/</a></p></li></ul><h2 id="1-注册并登录-Cloudflare-账号"><a href="#1-注册并登录-Cloudflare-账号" class="headerlink" title="1 注册并登录 Cloudflare 账号"></a>1 注册并登录 Cloudflare 账号</h2><p>这没啥好说的，前往 <a href="https://www.cloudflare.com/">Cloudflare 官网</a>自行注册并登录，然后<strong>点击「Workers」。</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/06.png" style="zoom:100%"/><h2 id="2-创建新的-Worker-应用"><a href="#2-创建新的-Worker-应用" class="headerlink" title="2 创建新的 Worker 应用"></a>2 创建新的 Worker 应用</h2><p>进入 Workers 页面之后，新用户需要设置用户名（比如 <code>progcz</code>），然后<strong>点击「创建 Worker」。</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/07.png" style="zoom:100%"/><h2 id="3-部署-Worker-应用"><a href="#3-部署-Worker-应用" class="headerlink" title="3 部署 Worker 应用"></a>3 部署 Worker 应用</h2><p><strong>自行修改应用名（比如 <code>test</code>），将 <a href="https://github.com/ProgCZ/code-cloud-a/blob/master/2020/05/cf-workers-mirrors/index.js">index.js</a> 中的代码拷贝至脚本中，点击「保存并部署」，</strong>然后就可以通过 <a href="https://test.progcz.workers.dev/">https://test.progcz.workers.dev/</a>（注意替换应用名 <code>test</code> 和用户名 <code>progcz</code>）访问 Google 的镜像网站了。</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/08.png" style="zoom:100%"/><h2 id="4-自定义-index-js-脚本"><a href="#4-自定义-index-js-脚本" class="headerlink" title="4 自定义 index.js 脚本"></a>4 自定义 index.js 脚本</h2><div class="note info"><p>上文的 <a href="https://github.com/ProgCZ/code-cloud-a/blob/master/2020/05/cf-workers-mirrors/index.js">index.js</a> 其实来自于 <a href="https://github.com/Berkeley-Reject/Workers-Proxy">Berkeley-Reject/Workers-Proxy</a> 仓库，但是代码中设置了对于国内访问的屏蔽，所以为了避免误用，我就在自行修改之后保存了一份。</p></div><p>可以通过修改以下部分来搭建不同的镜像网站：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Website you intended to retrieve for users.</span></span><br><span class="line"><span class="keyword">const</span> upstream = <span class="string">&#x27;www.google.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Custom pathname for the upstream website.</span></span><br><span class="line"><span class="keyword">const</span> upstream_path = <span class="string">&#x27;/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Website you intended to retrieve for users using mobile devices.</span></span><br><span class="line"><span class="keyword">const</span> upstream_mobile = <span class="string">&#x27;www.google.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Countries and regions where you wish to suspend your service.</span></span><br><span class="line"><span class="keyword">const</span> blocked_region = [<span class="string">&#x27;KP&#x27;</span>, <span class="string">&#x27;SY&#x27;</span>, <span class="string">&#x27;PK&#x27;</span>, <span class="string">&#x27;CU&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// IP addresses which you wish to block from using your service.</span></span><br><span class="line"><span class="keyword">const</span> blocked_ip_address = [<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Whether to use HTTPS protocol for upstream address.</span></span><br><span class="line"><span class="keyword">const</span> https = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Whether to disable cache.</span></span><br><span class="line"><span class="keyword">const</span> disable_cache = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace texts.</span></span><br><span class="line"><span class="keyword">const</span> replace_dict = &#123;</span><br><span class="line">    <span class="string">&#x27;$upstream&#x27;</span>: <span class="string">&#x27;$custom_domain&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;//google.com&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p>需要注意的是，上述代码只是 <a href="https://github.com/ProgCZ/code-cloud-a/blob/master/2020/05/cf-workers-mirrors/index.js">index.js</a> 的一小部分。</p></div><p>比如，对于 GitHub 来说，我们只需要<strong>将 <code>upstream</code>、<code>upstream_mobile</code> 和 <code>replace_dict</code> 中的 <code>google.com</code> 修改为 <code>github.com</code> 即可。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于 Google 来说，虽然大部分时间都能够在科学环境中网上冲浪，但是&lt;strong&gt;难免有需要在普通环境中使用 Google 的情况，&lt;/strong&gt;而对于 GitHub 来说，虽然目前可以无障碍访问，但是&lt;strong&gt;在普通环境中下载某些 Release（比如科学工具的客户端）的速度实在太慢。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你也有和我一样的困扰，那么可以考虑&lt;strong&gt;使用 Cloudflare Workers 搭建属于自己的镜像网站，&lt;/strong&gt;在普通环境中备用。&lt;/p&gt;</summary>
    
    
    
    <category term="A01 - 生活随笔" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="折腾" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="GitHub" scheme="https://progcz.com/tags/GitHub/"/>
    
    <category term="Cloudflare" scheme="https://progcz.com/tags/Cloudflare/"/>
    
    <category term="Google" scheme="https://progcz.com/tags/Google/"/>
    
    <category term="Mirror" scheme="https://progcz.com/tags/Mirror/"/>
    
  </entry>
  
  <entry>
    <title>2020 May LeetCoding Challenge - Week 4</title>
    <link href="https://progcz.com/posts/2020-may-leetcoding-challenge-week-4/"/>
    <id>https://progcz.com/posts/2020-may-leetcoding-challenge-week-4/</id>
    <published>2020-05-22T11:55:57.000Z</published>
    <updated>2020-05-28T11:24:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 五月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-May-LeetCoding-Challenge/">2020 May LeetCoding Challenge</a> 查看更多。</p><span id="more"></span><h2 id="May-22nd-Sort-Characters-By-Frequency"><a href="#May-22nd-Sort-Characters-By-Frequency" class="headerlink" title="May 22nd: Sort Characters By Frequency"></a>May 22nd: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3337/">Sort Characters By Frequency</a></h2><p>Given a string, sort it in decreasing order based on the frequency of characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;tree&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;eert&quot;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">&#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.</span><br><span class="line">So &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Both &#39;c&#39; and &#39;a&#39; appear three times, so &quot;aaaccc&quot; is also a valid answer.</span><br><span class="line">Note that &quot;cacaca&quot; is incorrect, as the same characters must be together.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;Aabb&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;bbAa&quot;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">&quot;bbaA&quot; is also a valid answer, but &quot;Aabb&quot; is incorrect.</span><br><span class="line">Note that &#39;A&#39; and &#39;a&#39; are treated as two different characters.</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用 <code>vector&lt;pair&lt;int, char&gt;&gt; vec(256)</code> 保存字符串 <code>s</code> 中<strong>每个字符出现的次数</strong>及<strong>字符本身</strong>。从大到小进行排序之后，重新拼接成新的字符串 <code>res</code> 即可。</p><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">frequencySort</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;&gt; <span class="built_in">vec</span>(<span class="number">256</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[ch].first++ == <span class="number">0</span>) &#123;</span><br><span class="line">                vec[ch].second = ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">rbegin</span>(), vec.<span class="built_in">rend</span>());</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : vec) &#123;</span><br><span class="line">            res += <span class="built_in">string</span>(p.first, p.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-23rd-Interval-List-Intersections"><a href="#May-23rd-Interval-List-Intersections" class="headerlink" title="May 23rd: Interval List Intersections"></a>May 23rd: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3338/">Interval List Intersections</a></h2><p>Given two lists of <strong>closed</strong> intervals, each list of intervals is pairwise disjoint and in sorted order.</p><p>Return the intersection of these two interval lists.</p><p><em>(Formally, a closed interval <code>[a, b]</code> (with <code>a &lt;= b</code>) denotes the set of real numbers <code>x</code> with <code>a &lt;= x &lt;= b</code>. The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3].)</em></p><p><strong>Example 1:</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/05.png" style="zoom:80%"/><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A &#x3D; [[0,2],[5,10],[13,23],[24,25]], B &#x3D; [[1,5],[8,12],[15,24],[25,26]]</span><br><span class="line">Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]</span><br><span class="line">Reminder: The inputs and the desired output are lists of Interval objects, and not arrays or lists.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p><code>0 &lt;= A.length &lt; 1000</code></p></li><li><p><code>0 &lt;= B.length &lt; 1000</code></p></li><li><p><code>0 &lt;= A[i].start, A[i].end, B[i].start, B[i].end &lt; 10^9</code></p></li></ul><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>因为 <code>A</code> 和 <code>B</code> 的数据量都不大，所以可以嵌套遍历。在遍历过程中：</p><ul><li><p><strong>如果 <code>a</code> 的右界小于 <code>b</code> 的左界，说明两者不相交，而且因为 <code>B</code> 有序，所以 <code>b</code> 之后的区间也不可能与 <code>a</code> 相交，跳出小循环。</strong></p></li><li><p><strong>如果 <code>a</code> 的左界大于 <code>b</code> 的右界，说明两者不相交，进入下一次小循环。</strong></p></li></ul><p>如果两者相交，那么两者<strong>左界的最大值和右界的最小值之间就是相交的区间。</strong></p><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">intervalIntersection</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; B) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : A) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> b : B) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[<span class="number">1</span>] &lt; b[<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (a[<span class="number">0</span>] &gt; b[<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;<span class="built_in">max</span>(a[<span class="number">0</span>], b[<span class="number">0</span>]), <span class="built_in">min</span>(a[<span class="number">1</span>], b[<span class="number">1</span>])&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-24th-Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#May-24th-Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="May 24th: Construct Binary Search Tree from Preorder Traversal"></a>May 24th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3339/">Construct Binary Search Tree from Preorder Traversal</a></h2><p>Return the root node of a binary <strong>search</strong> tree that matches the given <code>preorder</code> traversal.</p><p><em>(Recall that a binary search tree is a binary tree where for every node, any descendant of <code>node.left</code> has a value <code>&lt; node.val</code>, and any descendant of <code>node.right</code> has a value <code>&gt; node.val</code>. Also recall that a preorder traversal displays the value of the <code>node</code> first, then traverses <code>node.left</code>, then traverses <code>node.right</code>.)</em></p><p>It’s guaranteed that for the given test cases there is always possible to find a binary search tree with the given requirements.</p><p><strong>Example 1:</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/09.png" style="zoom:80%"/><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [8,5,1,7,10,12]</span><br><span class="line">Output: [8,5,10,1,7,null,12]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><p><code>1 &lt;= preorder.length &lt;= 100</code></p></li><li><p><code>1 &lt;= preorder[i] &lt;= 10^8</code></p></li><li><p>The values of <code>preorder</code> are distinct.</p></li></ul><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p><strong>利用 <code>func</code> 函数将 <code>preorder</code> 的 <code>[beg, end]</code> 区间分割为根节点、左子树和右子树。</strong>具体地：</p><ul><li><p>对于根节点，因为 <code>preorder</code> 是前序遍历，所以<strong>根节点必然是 <code>preorder[beg]</code>。</strong></p></li><li><p>对于左子树和右子树，在 <code>preorder</code> 的 <code>[beg+1, end]</code> 区间内遍历寻找第一个大于 <code>preorder[beg]</code> 的数字，其下标为 <code>idx</code>，那么<strong>左子树必然是 <code>preorder[beg+1, idx-1]</code>，右子树必然是 <code>preorder[idx, end]</code>。</strong></p></li></ul><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstFromPreorder</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">func</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;preorder, <span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beg &gt; end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = beg + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt;= end &amp;&amp; preorder[idx] &lt; preorder[beg]) ++idx;</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[beg]);</span><br><span class="line">        node-&gt;left = <span class="built_in">func</span>(preorder, beg+<span class="number">1</span>, idx<span class="number">-1</span>);</span><br><span class="line">        node-&gt;right = <span class="built_in">func</span>(preorder, idx, end);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-25th-Uncrossed-Lines"><a href="#May-25th-Uncrossed-Lines" class="headerlink" title="May 25th: Uncrossed Lines"></a>May 25th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3340/">Uncrossed Lines</a></h2><p>We write the integers of <code>A</code> and <code>B</code> (in the order they are given) on two separate horizontal lines.</p><p>Now, we may draw connecting lines: a straight line connecting two numbers <code>A[i]</code> and <code>B[j]</code> such that:</p><ul><li><p><code>A[i] == B[j]</code>;</p></li><li><p>The line we draw does not intersect any other connecting (non-horizontal) line.</p></li></ul><p>Note that a connecting lines cannot intersect even at the endpoints: each number can only belong to one connecting line.</p><p>Return the maximum number of connecting lines we can draw in this way.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A &#x3D; [1,4,2], B &#x3D; [1,2,4]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We can draw 2 uncrossed lines as in the diagram.</span><br><span class="line">We cannot draw 3 uncrossed lines, because the line from A[1]&#x3D;4 to B[2]&#x3D;4 will intersect the line from A[2]&#x3D;2 to B[1]&#x3D;2.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A &#x3D; [2,5,1,2,5], B &#x3D; [10,5,2,1,5,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A &#x3D; [1,3,7,1,7,5], B &#x3D; [1,9,2,5,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p><code>1 &lt;= A.length &lt;= 500</code></p></li><li><p><code>1 &lt;= B.length &lt;= 500</code></p></li><li><p><code>1 &lt;= A[i], B[i] &lt;= 2000</code></p></li></ul><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://leetcode.com/problems/uncrossed-lines/discuss/650947/C%2B%2B-DP-with-explanation">C++ DP with explanation</a></p><p>P.S. 嗨，看着动态规划的代码感觉还挺好理解的，自己写就写不出来。</p><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.<span class="built_in">size</span>(), n = B.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i] == B[j]) dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span> + dp[i][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="built_in">max</span>(dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-26th-Contiguous-Array"><a href="#May-26th-Contiguous-Array" class="headerlink" title="May 26th: Contiguous Array"></a>May 26th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3341/">Contiguous Array</a></h2><p>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,1,0]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> The length of the given binary array will not exceed 50,000.</p><h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://www.cnblogs.com/grandyang/p/6529857.html">[LeetCode] 525. Contiguous Array 相连的数组 - 刷尽天下</a></p><p>遍历 <code>nums</code> 中的数字 <code>num</code>，如果为 <code>1</code> 则累加 <code>1</code> 至 <code>sum</code>，如果为 <code>0</code> 则累加 <code>-1</code> 至 <code>sum</code>。</p><p>使用 <code>map&lt;int, int&gt; m</code> 记录首次出现某个 <code>sum</code> 的下标，如果之后再次出现该 <code>sum</code>，说明两者之间的子数组满足题目要求，寻找其长度的最大值即可。</p><h4 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(), sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sum += nums[i] ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(sum)) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, i-m[sum]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                m[sum] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-27th-Possible-Bipartition"><a href="#May-27th-Possible-Bipartition" class="headerlink" title="May 27th: Possible Bipartition"></a>May 27th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3342/">Possible Bipartition</a></h2><p>Given a set of <code>N</code> people (numbered <code>1, 2, ..., N</code>), we would like to split everyone into two groups of <strong>any</strong> size.</p><p>Each person may dislike some other people, and they should not go into the same group.</p><p>Formally, if <code>dislikes[i] = [a, b]</code>, it means it is not allowed to put the people numbered <code>a</code> and <code>b</code> into the same group.</p><p>Return <code>true</code> if and only if it is possible to split everyone into two groups in this way.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 4, dislikes &#x3D; [[1,2],[1,3],[2,4]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: group1 [1,4], group2 [2,3]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 3, dislikes &#x3D; [[1,2],[1,3],[2,3]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 5, dislikes &#x3D; [[1,2],[2,3],[3,4],[4,5],[1,5]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p><code>1 &lt;= N &lt;= 2000</code></p></li><li><p><code>0 &lt;= dislikes.length &lt;= 10000</code></p></li><li><p><code>1 &lt;= dislikes[i][j] &lt;= N</code></p></li><li><p><code>dislikes[i][0] &lt; dislikes[i][1]</code></p></li><li><p>There does not exist <code>i != j</code> for which <code>dislikes[i] == dislikes[j]</code>.</p></li></ul><h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://www.cnblogs.com/grandyang/p/10317141.html">[LeetCode] 886. Possible Bipartition 可能的二分图 - 刷尽天下</a></p><p>放弃治疗，直接看大佬的解法吧。</p><h4 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">possibleBipartition</span><span class="params">(<span class="keyword">int</span> N, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; dislikes)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">g</span>(N+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(N+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> dislike : dislikes) &#123;</span><br><span class="line">            g[dislike[<span class="number">0</span>]][dislike[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">            g[dislike[<span class="number">1</span>]][dislike[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">colors</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (colors[i] == <span class="number">0</span> &amp;&amp; !<span class="built_in">func</span>(g, i, <span class="number">1</span>, colors)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; g, <span class="keyword">int</span> cur, <span class="keyword">int</span> color, vector&lt;<span class="keyword">int</span>&gt;&amp; colors)</span> </span>&#123;</span><br><span class="line">        colors[cur] = color;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[cur][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (colors[i] == color) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (colors[i] == <span class="number">0</span> &amp;&amp; !<span class="built_in">func</span>(g, i, -color, colors)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-28th-Counting-Bits"><a href="#May-28th-Counting-Bits" class="headerlink" title="May 28th: Counting Bits"></a>May 28th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3343/">Counting Bits</a></h2><p>Given a non negative integer number <strong>num</strong>. For every numbers <strong>i</strong> in the range <strong>0 ≤ i ≤ num</strong> calculate the number of 1’s in their binary representation and return them as an array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: [0,1,1]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure><h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>充分利用之前的结果：计算 <code>i</code> 中 <code>1</code> 的个数，那么只需要知道 <code>i&gt;&gt;1</code> 中 <code>1</code> 的个数（即 <code>res[i&gt;&gt;1]</code>）和 <code>i</code> 的最后一位是否为 <code>1</code>（即 <code>i&amp;0x1</code>），相加即可。</p><h4 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(res[i&gt;&gt;<span class="number">1</span>]+(i&amp;<span class="number">0x1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 五月挑战专题每日随缘更新，点击类别 &lt;a href=&quot;/categories/2020-May-LeetCoding-Challenge/&quot;&gt;2020 May LeetCoding Challenge&lt;/a&gt; 查看更多。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="2020 LeetCoding Challenge" scheme="https://progcz.com/categories/A03-LeetCode/2020-LeetCoding-Challenge/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Data Structure and Algorithm" scheme="https://progcz.com/tags/Data-Structure-and-Algorithm/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Challenge" scheme="https://progcz.com/tags/Challenge/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Weekly Contest 189 (1450 - 1453)</title>
    <link href="https://progcz.com/posts/leetcode-weekly-contest-189-1450-1453/"/>
    <id>https://progcz.com/posts/leetcode-weekly-contest-189-1450-1453/</id>
    <published>2020-05-17T06:53:16.000Z</published>
    <updated>2020-05-17T06:53:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 周赛专题每周随缘更新，点击类别 <a href="/categories/LeetCode-Weekly-Contest/">LeetCode Weekly Contest</a> 查看更多。</p><p>本次比赛通过 <code>3</code> 题，时间为 <code>0:48:25</code>，排名为 <code>2708/13036</code>。</p><span id="more"></span><h2 id="1450-Number-of-Students-Doing-Homework-at-a-Given-Time-Easy"><a href="#1450-Number-of-Students-Doing-Homework-at-a-Given-Time-Easy" class="headerlink" title="1450. Number of Students Doing Homework at a Given Time #Easy"></a><a href="https://leetcode.com/contest/weekly-contest-189/problems/number-of-students-doing-homework-at-a-given-time/">1450. Number of Students Doing Homework at a Given Time</a> #Easy</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>侮辱智商，不解释了。</p><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">busyStudent</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; startTime, vector&lt;<span class="keyword">int</span>&gt;&amp; endTime, <span class="keyword">int</span> queryTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = startTime.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (startTime[i] &lt;= queryTime &amp;&amp; endTime[i] &gt;= queryTime) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1451-Rearrange-Words-in-a-Sentence-Medium"><a href="#1451-Rearrange-Words-in-a-Sentence-Medium" class="headerlink" title="1451. Rearrange Words in a Sentence #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-189/problems/rearrange-words-in-a-sentence">1451. Rearrange Words in a Sentence</a> #Medium</h2><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用 <code>vector&lt;pair&lt;vector&lt;int&gt;, string&gt;&gt; vec</code> 存放分割后的子字符串，<strong>其中 <code>vector&lt;int&gt;</code> 包含两个数字，第一个为字符串的长度，第二个为字符串的序号，</strong>从而在之后的 <code>sort</code> 中按照字符串的长度排序，如果长度相等，则按照字符串的原顺序排序。</p><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">arrangeWords</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        text[<span class="number">0</span>] -= <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        text.<span class="built_in">push_back</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, cur = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        vector&lt;pair&lt;vector&lt;<span class="keyword">int</span>&gt;, string&gt;&gt; vec;</span><br><span class="line">        <span class="keyword">while</span> ((cur = text.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>, pre)) != string::npos) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;cur-pre, cnt++&#125;,</span><br><span class="line">                                    text.<span class="built_in">substr</span>(pre, cur-pre)));</span><br><span class="line">            pre = cur+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : vec) res += p.second + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">        res[<span class="number">0</span>] += <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1452-People-Whose-List-of-Favorite-Companies-Is-Not-a-Subset-of-Another-List-Medium"><a href="#1452-People-Whose-List-of-Favorite-Companies-Is-Not-a-Subset-of-Another-List-Medium" class="headerlink" title="1452. People Whose List of Favorite Companies Is Not a Subset of Another List #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-189/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/">1452. People Whose List of Favorite Companies Is Not a Subset of Another List</a> #Medium</h2><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，<strong>将每组公司从 <code>vector&lt;string&gt;</code> 重新组织为 <code>set&lt;string&gt;</code>，</strong>从而方便后续查找。</p><p>其次，嵌套遍历，<strong>其中 <code>b1</code> 用于标记 <code>vec[i]</code> 是否包含于其他任何组，<code>b2</code> 用于标记 <code>vec[i]</code> 是否包含于 <code>vec[j]</code>。</strong></p><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">peopleIndexes</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; favoriteCompanies)</span> </span>&#123;</span><br><span class="line">        vector&lt;set&lt;string&gt;&gt; vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> vs : favoriteCompanies) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(set&lt;string&gt;(vs.<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">bool</span> b1 = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vec[i].<span class="built_in">size</span>() &gt;= vec[j].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">bool</span> b2 = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> s : vec[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (vec[j].<span class="built_in">find</span>(s) == vec[j].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        b2 = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (b2) b1 = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!b1) res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1453-Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard-Hard"><a href="#1453-Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard-Hard" class="headerlink" title="1453. Maximum Number of Darts Inside of a Circular Dartboard #Hard"></a><a href="https://leetcode.com/contest/weekly-contest-189/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/">1453. Maximum Number of Darts Inside of a Circular Dartboard</a> #Hard</h2><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/discuss/636416/c%2B%2B-O(n2logn)-angular-sweep-(with-picture)">[c++] O(n^2logn), angular sweep (with picture)</a></p><p>又是放弃治疗系列，直接看大佬的解法吧。</p><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numPoints</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">double</span>&gt;&gt; <span class="built_in">dist</span>(n, vector&lt;<span class="keyword">double</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                dist[i][j] = dist[j][i] = <span class="built_in">sqrt</span>((points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) * (points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) +</span><br><span class="line">                                               (points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]) * (points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            vector&lt;pair&lt;<span class="keyword">double</span>, <span class="keyword">bool</span>&gt;&gt; angles;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != i &amp;&amp; dist[i][j] &lt;= <span class="number">2</span> * r) &#123;</span><br><span class="line">                    <span class="keyword">double</span> A = <span class="built_in">atan2</span>(points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>], points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">double</span> B = <span class="built_in">acos</span>(dist[i][j] / (<span class="number">2.0</span> * r));</span><br><span class="line">                    <span class="keyword">double</span> alpha = A - B;</span><br><span class="line">                    <span class="keyword">double</span> beta = A + B;</span><br><span class="line">                    angles.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(alpha, <span class="literal">false</span>));</span><br><span class="line">                    angles.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(beta, <span class="literal">true</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(angles.<span class="built_in">begin</span>(), angles.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = angles.<span class="built_in">begin</span>(); it != angles.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((*it).second == <span class="literal">false</span>) ++cnt;</span><br><span class="line">                <span class="keyword">else</span> --cnt;</span><br><span class="line">                res = <span class="built_in">max</span>(res, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 周赛专题每周随缘更新，点击类别 &lt;a href=&quot;/categories/LeetCode-Weekly-Contest/&quot;&gt;LeetCode Weekly Contest&lt;/a&gt; 查看更多。&lt;/p&gt;
&lt;p&gt;本次比赛通过 &lt;code&gt;3&lt;/code&gt; 题，时间为 &lt;code&gt;0:48:25&lt;/code&gt;，排名为 &lt;code&gt;2708/13036&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="LeetCode Weekly Contest" scheme="https://progcz.com/categories/A03-LeetCode/LeetCode-Weekly-Contest/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Data Structure and Algorithm" scheme="https://progcz.com/tags/Data-Structure-and-Algorithm/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 May LeetCoding Challenge - Week 3</title>
    <link href="https://progcz.com/posts/2020-may-leetcoding-challenge-week-3/"/>
    <id>https://progcz.com/posts/2020-may-leetcoding-challenge-week-3/</id>
    <published>2020-05-15T08:23:22.000Z</published>
    <updated>2020-05-21T08:24:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 五月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-May-LeetCoding-Challenge/">2020 May LeetCoding Challenge</a> 查看更多。</p><span id="more"></span><h2 id="May-15th-Maximum-Sum-Circular-Subarray"><a href="#May-15th-Maximum-Sum-Circular-Subarray" class="headerlink" title="May 15th: Maximum Sum Circular Subarray"></a>May 15th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/536/week-3-may-15th-may-21st/3330/">Maximum Sum Circular Subarray</a></h2><p>Given a <strong>circular array C</strong> of integers represented by <code>A</code>, find the maximum possible sum of a non-empty subarray of <strong>C</strong>.</p><p>Here, a <em>circular array</em> means the end of the array connects to the beginning of the array. (Formally, <code>C[i] = A[i]</code> when <code>0 &lt;= i &lt; A.length</code>, and <code>C[i+A.length] = C[i]</code> when <code>i &gt;= 0</code>.)</p><p>Also, a subarray may only include each element of the fixed buffer <code>A</code> at most once. (Formally, for a subarray <code>C[i], C[i+1], ..., C[j]</code>, there does not exist <code>i &lt;= k1, k2 &lt;= j</code> with <code>k1 % A.length = k2 % A.length</code>.)</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,-2,3,-2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarray [3] has maximum sum 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [5,-3,5]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: Subarray [5,5] has maximum sum 5 + 5 &#x3D; 10</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,-1,2,-1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 &#x3D; 4</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,-2,2,-3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-2,-3,-1]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: Subarray [-1] has maximum sum -1</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p><code>-30000 &lt;= A[i] &lt;= 30000</code></p></li><li><p><code>1 &lt;= A.length &lt;= 30000</code></p></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://www.cnblogs.com/grandyang/p/11716314.html">[LeetCode] 918. Maximum Sum Circular Subarray 环形子数组的最大和 - 刷尽天下</a></p><p>考虑到环形数组，子数组的和实际上包含两种情况：</p><ul><li><p><strong>一种是正常的，即 <code>A</code> 的某一子数组。</strong></p><p>对于这种情况，可以这样处理：在遍历过程中，**<code>curMx = max(curMx+num, num);</code> 语句表示 <code>curMx</code> 要么延续之前的子数组，要么放弃之前的子数组，<strong>即是否重新组织子数组，然后</strong>使用 <code>mx = max(mx, curMx);</code> 语句寻找子数组和的最大值。**</p></li><li><p><strong>另一种是两段的，即 <code>A</code> 的开头一段和结束一段组合而成的某一子数组。</strong></p><p>对于这种情况，可以这样处理：仿照第一种情况的方法，<strong>寻找子数组和的最小值 <code>mn</code>，使用 <code>A</code> 的总和 <code>sum</code> 减去 <code>mn</code> 就可以得到子数组和的最大值。</strong></p></li></ul><p>最后，上述两种情况取较大值即可。</p><p>另外，如果 <code>sum</code> 与 <code>mn</code> 相等，说明 <code>A</code> 中全为负数，结果应该是 <code>A</code> 中最大的负数，此时直接返回 <code>mx</code> 即可。</p><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, mn = INT_MAX, mx = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> curMn = <span class="number">0</span>, curMx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : A) &#123;</span><br><span class="line">            curMn = <span class="built_in">min</span>(curMn+num, num);</span><br><span class="line">            mn = <span class="built_in">min</span>(mn, curMn);</span><br><span class="line">            curMx = <span class="built_in">max</span>(curMx+num, num);</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, curMx);</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sum == mn) ? mx : <span class="built_in">max</span>(mx, sum-mn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-16th-Odd-Even-Linked-List"><a href="#May-16th-Odd-Even-Linked-List" class="headerlink" title="May 16th: Odd Even Linked List"></a>May 16th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/536/week-3-may-15th-may-21st/3331/">Odd Even Linked List</a></h2><p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p><p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL</span><br><span class="line">Output: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p>The relative order inside both the even and odd groups should remain as it was in the input.</p></li><li><p>The first node is considered odd, the second node even and so on …</p></li></ul><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://www.cnblogs.com/grandyang/p/5138936.html">[LeetCode] Odd Even Linked List 奇偶链表 - 刷尽天下</a></p><p>其实比着代码画个图就能明白了。</p><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *pre = head, *cur = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;next) &#123;</span><br><span class="line">            ListNode *tmp = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            pre-&gt;next-&gt;next = tmp;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-17th-Find-All-Anagrams-in-a-String"><a href="#May-17th-Find-All-Anagrams-in-a-String" class="headerlink" title="May 17th: Find All Anagrams in a String"></a>May 17th: <a href="https://leetcode.com/explore/featured/card/may-leetcoding-challenge/536/week-3-may-15th-may-21st/3332/">Find All Anagrams in a String</a></h2><p>Given a string <strong>s</strong> and a <strong>non-empty</strong> string <strong>p</strong>, find all the start indices of <strong>p</strong>‘s anagrams in <strong>s</strong>.</p><p>Strings consists of lowercase English letters only and the length of both strings <strong>s</strong> and <strong>p</strong> will not be larger than 20,100.</p><p>The order of output does not matter.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index &#x3D; 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.</span><br><span class="line">The substring with start index &#x3D; 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s: &quot;abab&quot; p: &quot;ab&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[0, 1, 2]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index &#x3D; 0 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class="line">The substring with start index &#x3D; 1 is &quot;ba&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class="line">The substring with start index &#x3D; 2 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br></pre></td></tr></table></figure><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p><strong>使用 <code>array&lt;int, 256&gt;</code> 的 <code>arr1</code> 和 <code>arr2</code> 分别记录 <code>s</code> 的滑动窗口中和 <code>p</code> 中字符出现的次数，</strong>通过比较 <code>arr1</code> 和 <code>arr2</code> 是否相等，就可以知道滑动窗口中的字符串是否为 <code>p</code> 的变型。</p><p>P.S. 一开始还使用 <code>multiset&lt;char&gt;</code> 做记录，然后就超时了。</p><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = s.<span class="built_in">size</span>(), n2 = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n1 &lt; n2) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        array&lt;<span class="keyword">int</span>, 256&gt; arr1&#123;&#125;, arr2&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n2; ++i) &#123;</span><br><span class="line">            ++arr1[s[i]];</span><br><span class="line">            ++arr2[p[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr1 == arr2) res.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n2; i &lt; n1; ++i) &#123;</span><br><span class="line">            ++arr1[s[i]];</span><br><span class="line">            --arr1[s[i-n2]];</span><br><span class="line">            <span class="keyword">if</span> (arr1 == arr2) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i-n2+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-18th-Permutation-in-String"><a href="#May-18th-Permutation-in-String" class="headerlink" title="May 18th: Permutation in String"></a>May 18th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/536/week-3-may-15th-may-21st/3333/">Permutation in String</a></h2><p>Given two strings <strong>s1</strong> and <strong>s2</strong>, write a function to return true if <strong>s2</strong> contains the permutation of <strong>s1</strong>. In other words, one of the first string’s permutations is the <strong>substring</strong> of the second string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidbaooo&quot;</span><br><span class="line">Output: True</span><br><span class="line">Explanation: s2 contains one permutation of s1 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1&#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidboaoo&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p>The input strings only contain lower case letters.</p></li><li><p>The length of both given strings is in range [1, 10,000].</p></li></ul><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>梅开二度，这不就是昨天的题嘛，不解释了。</p><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = s1.<span class="built_in">size</span>(), n2 = s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n1 &gt; n2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        array&lt;<span class="keyword">int</span>, 256&gt; arr1&#123;&#125;, arr2&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; ++i) &#123;</span><br><span class="line">            ++arr1[s1[i]];</span><br><span class="line">            ++arr2[s2[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr1 == arr2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n1; i &lt; n2; ++i) &#123;</span><br><span class="line">            ++arr2[s2[i]];</span><br><span class="line">            --arr2[s2[i-n1]];</span><br><span class="line">            <span class="keyword">if</span> (arr1 == arr2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-19th-Online-Stock-Span"><a href="#May-19th-Online-Stock-Span" class="headerlink" title="May 19th: Online Stock Span"></a>May 19th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/536/week-3-may-15th-may-21st/3334/">Online Stock Span</a></h2><p>Write a class <code>StockSpanner</code> which collects daily price quotes for some stock, and returns the <em>span</em> of that stock’s price for the current day.</p><p>The span of the stock’s price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today’s price.</p><p>For example, if the price of a stock over the next 7 days were <code>[100, 80, 60, 70, 60, 75, 85]</code>, then the stock spans would be <code>[1, 1, 1, 2, 1, 4, 6]</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;StockSpanner&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[],[100],[80],[60],[70],[60],[75],[85]]</span><br><span class="line">Output: [null,1,1,1,2,1,4,6]</span><br><span class="line">Explanation:</span><br><span class="line">First, S &#x3D; StockSpanner() is initialized. Then:</span><br><span class="line">S.next(100) is called and returns 1,</span><br><span class="line">S.next(80) is called and returns 1,</span><br><span class="line">S.next(60) is called and returns 1,</span><br><span class="line">S.next(70) is called and returns 2,</span><br><span class="line">S.next(60) is called and returns 1,</span><br><span class="line">S.next(75) is called and returns 4,</span><br><span class="line">S.next(85) is called and returns 6.</span><br><span class="line"></span><br><span class="line">Note that (for example) S.next(75) returned 4, because the last 4 prices</span><br><span class="line">(including today&#39;s price of 75) were less than or equal to today&#39;s price.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p>Calls to <code>StockSpanner.next(int price)</code> will have <code>1 &lt;= price &lt;= 10^5</code>.</p></li><li><p>There will be at most <code>10000</code> calls to <code>StockSpanner.next</code> per test case.</p></li><li><p>There will be at most <code>150000</code> calls to <code>StockSpanner.next</code> across all test cases.</p></li><li><p>The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages.</p></li></ul><h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://www.cnblogs.com/grandyang/p/11029306.html">[LeetCode] 901. Online Stock Span 股票价格跨度 - 刷尽天下</a></p><p>使用 <code>stack&lt;pair&lt;int, int&gt;&gt; st</code> 中的 <code>pair&lt;int, int&gt;</code> 存放当前股价和之前股价不比其高的连续天数。</p><p>每次调用 <code>next</code> 方法，循环遍历堆顶元素，如果其股价不比当前股价 <code>price</code> 高，则累加其连续天数至 <code>cnt</code>，直到其股价比当前股价 <code>price</code> 高。</p><p>结束遍历后，将当前股价 <code>price</code> 和之前股价不比其高的连续天数 <code>cnt</code> 添加至 <code>st</code> 的堆顶，返回 <code>cnt</code> 即可。</p><h4 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StockSpanner</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>().first &lt;= price) &#123;</span><br><span class="line">            cnt += st.<span class="built_in">top</span>().second; st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(&#123;price, cnt&#125;);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StockSpanner* obj = new StockSpanner();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next(price);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="May-20th-Kth-Smallest-Element-in-a-BST"><a href="#May-20th-Kth-Smallest-Element-in-a-BST" class="headerlink" title="May 20th: Kth Smallest Element in a BST"></a>May 20th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/536/week-3-may-15th-may-21st/3335/">Kth Smallest Element in a BST</a></h2><p>Given a binary search tree, write a function <code>kthSmallest</code> to find the <strong>k</strong>th smallest element in it.</p><p><strong>Note:</strong></p><p>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><div class="note info"><p>众所周知，对二叉搜索树 BST 进行<strong>中序遍历</strong>，其结果即为从小到大排序的序列。</p></div><p>对二叉搜索树 BST 进行中序遍历的过程中，累减 <code>k</code> 直至 <code>k</code> 变为 <code>0</code>，返回节点的值即可。</p><h4 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(root, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(TreeNode *node, <span class="keyword">int</span> &amp;k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="built_in">func</span>(node-&gt;left, k);</span><br><span class="line">            <span class="keyword">if</span> (t != INT_MIN) <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="built_in">func</span>(node-&gt;right, k);</span><br><span class="line">            <span class="keyword">if</span> (t != INT_MIN) <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-21st-Count-Square-Submatrices-with-All-Ones"><a href="#May-21st-Count-Square-Submatrices-with-All-Ones" class="headerlink" title="May 21st: Count Square Submatrices with All Ones"></a>May 21st: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/536/week-3-may-15th-may-21st/3336/">Count Square Submatrices with All Ones</a></h2><p>Given a <code>m * n</code> matrix of ones and zeros, return how many <strong>square</strong> submatrices have all ones.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [0,1,1,1],</span><br><span class="line">  [1,1,1,1],</span><br><span class="line">  [0,1,1,1]</span><br><span class="line">]</span><br><span class="line">Output: 15</span><br><span class="line">Explanation:</span><br><span class="line">There are 10 squares of side 1.</span><br><span class="line">There are 4 squares of side 2.</span><br><span class="line">There is  1 square of side 3.</span><br><span class="line">Total number of squares &#x3D; 10 + 4 + 1 &#x3D; 15.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [1,1,0],</span><br><span class="line">  [1,1,0]</span><br><span class="line">]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation:</span><br><span class="line">There are 6 squares of side 1.</span><br><span class="line">There is 1 square of side 2.</span><br><span class="line">Total number of squares &#x3D; 6 + 1 &#x3D; 7.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><p><code>1 &lt;= matrix.length &lt;= 300</code></p></li><li><p><code>1 &lt;= matrix[0].length &lt;= 300</code></p></li><li><p><code>0 &lt;= matrix[i][j] &lt;= 1</code></p></li></ul><h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>P.S. 印象中碰到过这道题，那次没做出来，看了别人的解法之后，这次就记着了。</p><p>使用 <code>vec</code> 记录<strong>以当前位置 <code>[i][j]</code> 为右下角的全 <code>1</code> 矩阵的最大尺寸</strong>，也就是<strong>以当前位置 <code>[i][j]</code> 为右下角的全 <code>1</code> 矩阵的个数</strong>。</p><p>如果当前位置在 <code>matrix</code> 中的值 <code>matrix[i-1][j-1]</code> 为 <code>1</code>，那么可以<strong>通过左上 <code>vec[i-1][j-1]</code>、左侧 <code>vec[i][j-1]</code> 和上方 <code>vec[i-1][j]</code> 中的最小值加 <code>1</code> 得到 <code>vec[i][j]</code>。</strong></p><div class="note info"><p>需要注意的是，为了在动态规划算法中使用统一的递推公式，一般将矩阵扩增一行和一列，所以 <code>vec[i][j]</code> 对应的是 <code>matrix[i-1][j-1]</code>。</p></div><p>最后，在遍历过程中，使用 <code>res</code> 累加 <code>vec[i][j]</code> 即可。</p><h4 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">vec</span>(m+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                    vec[i][j] = <span class="built_in">min</span>(vec[i<span class="number">-1</span>][j<span class="number">-1</span>],</span><br><span class="line">                                    <span class="built_in">min</span>(vec[i][j<span class="number">-1</span>], vec[i<span class="number">-1</span>][j])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res += vec[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 五月挑战专题每日随缘更新，点击类别 &lt;a href=&quot;/categories/2020-May-LeetCoding-Challenge/&quot;&gt;2020 May LeetCoding Challenge&lt;/a&gt; 查看更多。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="2020 LeetCoding Challenge" scheme="https://progcz.com/categories/A03-LeetCode/2020-LeetCoding-Challenge/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Data Structure and Algorithm" scheme="https://progcz.com/tags/Data-Structure-and-Algorithm/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Challenge" scheme="https://progcz.com/tags/Challenge/"/>
    
  </entry>
  
  <entry>
    <title>记录一次「卖」微信公众号的经历</title>
    <link href="https://progcz.com/posts/record-for-sell-wechat-official-account/"/>
    <id>https://progcz.com/posts/record-for-sell-wechat-official-account/</id>
    <published>2020-05-14T08:44:03.000Z</published>
    <updated>2020-05-14T08:44:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>因为腾讯在两年前关闭了新注册微信公众号的「留言」功能，所以新注册微信公众号必须通过一些特殊方法才能拥有「留言」功能，「账号迁移」便是其中之一。</strong></p><p>刚好，我有一个闲置已久的微信公众号，于是联系到经办人将自己的微信公众号「卖」了出去。<strong>两个工作日</strong>的时间就把整个流程走完了，大部分手续都是经办人的事情，需要我来配合的地方并不多。</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/03.png" style="zoom:100%"/><span id="more"></span><h2 id="0-事情起因"><a href="#0-事情起因" class="headerlink" title="0 事情起因"></a>0 事情起因</h2><p>几天前，在逛 V2EX 的时候，看到一个<a href="https://www.v2ex.com/t/668420">帖子</a>，里面讲到：</p><blockquote><p>做公众号，特别是近期注册的都想要留言功能。但是 2018 年 3 月 12 日之后注册的微信公众号默认没有留言功能。</p><p>新号想要留言功能，基本上就一条路花几千找人做迁移有留言功能的老号才行。</p></blockquote><p>巧合的是，在此之前的几天，我想起自己有个闲置已久的微信公众号，当时觉得没什么用了，于是申请了账号注销，七天后再次确认即可彻底注销。看到这个帖子之后，我立马终止了注销流程，开始琢磨怎么把它卖掉。</p><h2 id="1-迁移过程"><a href="#1-迁移过程" class="headerlink" title="1 迁移过程"></a>1 迁移过程</h2><p>简单搜索之后，我了解到腾讯关闭了新注册微信公众号的「留言」功能，想要开通的话需要一些特殊方法，具体可以参考<a href="https://zhuanlan.zhihu.com/p/63996356">微信公众号留言开通最全攻略</a>。</p><p>同时，我联系到一个专业的经办人，可以帮忙「卖」掉带有「留言」功能的微信公众号。</p><div class="note info"><p>接下来，从我的角度来描述一下大概的流程：</p><ol><li><p>第一天，经办人登录我的微信公众号，确认微信公众号的基本信息及违规记录。</p></li><li><p>随后，经办人要求我提供身份证正反面的照片，照片需要带有「公众号迁移」字样的水印。<strong>提供照片之后，经办人付给了我一半的费用。</strong></p></li><li><p>三个小时后，经办人要求我进行电子公证，此处需要进行人脸识别。</p></li><li><p>第二天，经办人再次登录我的微信公众号。</p></li><li><p>随后，经办人要求我扫码对「账号迁移」进行确认，此时微信需要对迁移申请进行审核。</p></li><li><p>四个小时后，微信对迁移申请的审核通过，经办人要求再次对「账号迁移」进行确认。<strong>最终确认之后，经办人付给了我另外一半的费用。</strong></p></li></ol></div><p>以上就是我需要做的事情，总体来说不算麻烦，何乐而不为。</p><h2 id="2-推广"><a href="#2-推广" class="headerlink" title="2 推广"></a>2 推广</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/04.png" style="zoom:100%"/><p><strong>如果你也有一个在 2018 年 03 月 12 日之前注册而又闲置的微信公众号，可以通过「下方的评论区」或「<a href="/about/">关于</a>页面的其他联系方式」联系到我，</strong>我可以把这个比较靠谱的经办人推荐给你。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;因为腾讯在两年前关闭了新注册微信公众号的「留言」功能，所以新注册微信公众号必须通过一些特殊方法才能拥有「留言」功能，「账号迁移」便是其中之一。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;刚好，我有一个闲置已久的微信公众号，于是联系到经办人将自己的微信公众号「卖」了出去。&lt;strong&gt;两个工作日&lt;/strong&gt;的时间就把整个流程走完了，大部分手续都是经办人的事情，需要我来配合的地方并不多。&lt;/p&gt;
&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/03.png&quot; style=&quot;zoom:100%&quot;/&gt;</summary>
    
    
    
    <category term="A01 - 生活随笔" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="经历" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="WeChat" scheme="https://progcz.com/tags/WeChat/"/>
    
    <category term="Life" scheme="https://progcz.com/tags/Life/"/>
    
    <category term="Promotion" scheme="https://progcz.com/tags/Promotion/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Weekly Contest 188 (1441 - 1444)</title>
    <link href="https://progcz.com/posts/leetcode-weekly-contest-188-1441-1444/"/>
    <id>https://progcz.com/posts/leetcode-weekly-contest-188-1441-1444/</id>
    <published>2020-05-10T07:14:53.000Z</published>
    <updated>2020-05-10T07:14:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 周赛专题每周随缘更新，点击类别 <a href="/categories/LeetCode-Weekly-Contest/">LeetCode Weekly Contest</a> 查看更多。</p><p>本次比赛通过 <code>3</code> 题，时间为 <code>1:14:56</code>，排名为 <code>2375/12715</code>。</p><span id="more"></span><h2 id="1441-Build-an-Array-With-Stack-Operations-Easy"><a href="#1441-Build-an-Array-With-Stack-Operations-Easy" class="headerlink" title="1441. Build an Array With Stack Operations #Easy"></a><a href="https://leetcode.com/contest/weekly-contest-188/problems/build-an-array-with-stack-operations/">1441. Build an Array With Stack Operations</a> #Easy</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，遍历 <code>target</code>，在 <code>res</code> 中添加 <code>&quot;Push&quot;</code>。</p><p>其次，累加 <code>num</code>，如果遍历到的数字与 <code>num</code> 不同，那么在 <code>res</code> 中添加 <code>&quot;Pop&quot;</code>，同时将遍历下标 <code>i</code> 停在当前位置。</p><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">buildArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="string">&quot;Push&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (num != target[i]) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&quot;Pop&quot;</span>);</span><br><span class="line">                --i;</span><br><span class="line">            &#125;</span><br><span class="line">            ++num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR-Medium"><a href="#1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR-Medium" class="headerlink" title="1442. Count Triplets That Can Form Two Arrays of Equal XOR #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-188/problems/count-triplets-that-can-form-two-arrays-of-equal-xor">1442. Count Triplets That Can Form Two Arrays of Equal XOR</a> #Medium</h2><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><div class="note info"><p>需要明白的是，异或运算具备一个重要性质：如果　<code>a ^ b ^ c ^ d = e</code>，那么　<code>c ^ d = e ^ (a ^ b)</code>。</p></div><p>首先，使用 <code>vec</code> 存放每个数字与之前所有数字异或运算的结果。</p><p>其次，根据异或运算的性质，计算 <code>[i, j-1]</code> 之间数字异或运算的结果，只需计算 <code>vec[j-1] ^ vec[i-1]</code>。</p><p>同理，计算 <code>[j, k]</code> 之间数字异或运算的结果，只需计算 <code>vec[k] ^ vec[j-1]</code>。</p><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(vec.<span class="built_in">back</span>() ^ arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; vec.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; vec.<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((vec[j<span class="number">-1</span>] ^ vec[i<span class="number">-1</span>]) == (vec[k] ^ vec[j<span class="number">-1</span>])) &#123;</span><br><span class="line">                        ++res;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree-Medium"><a href="#1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree-Medium" class="headerlink" title="1443. Minimum Time to Collect All Apples in a Tree #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-188/problems/minimum-time-to-collect-all-apples-in-a-tree/">1443. Minimum Time to Collect All Apples in a Tree</a> #Medium</h2><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，使用 <code>map&lt;int, vector&lt;int&gt;&gt; m</code> 记录每个节点的所有子节点。</p><p>其次，使用深度优先搜索算法遍历所有的节点，返回到达某个节点及其之后节点所需要的时间步。其边界条件是遍历到叶子节点，如果叶子节点包含苹果，因为往返这个节点需要 <code>2</code> 个时间步，所以返回 <code>2</code>，否则返回 <code>0</code>。</p><p>然后，对于遍历到的节点，需要遍历其所有子节点，同时使用 <code>sum</code> 累加子节点返回的值，如果该节点不为根节点，而且其子节点之和不为 <code>0</code>（表明其子树包含苹果）或者节点本身包含苹果，那么必然需要往返该节点，<code>sum</code> 累加 <code>2</code>。</p><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTime</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="keyword">bool</span>&gt;&amp; hasApple)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> vi : edges) m[vi[<span class="number">0</span>]].<span class="built_in">push_back</span>(vi[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(<span class="number">0</span>, m, hasApple);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> idx, map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;m, vector&lt;<span class="keyword">bool</span>&gt; &amp;hasApple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m.<span class="built_in">count</span>(idx)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasApple[idx]) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : m[idx]) sum += <span class="built_in">func</span>(i, m, hasApple);</span><br><span class="line">        <span class="keyword">if</span> (idx != <span class="number">0</span> &amp;&amp; (sum != <span class="number">0</span> || hasApple[idx])) sum += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1444-Number-of-Ways-of-Cutting-a-Pizza-Hard"><a href="#1444-Number-of-Ways-of-Cutting-a-Pizza-Hard" class="headerlink" title="1444. Number of Ways of Cutting a Pizza #Hard"></a><a href="https://leetcode.com/contest/weekly-contest-188/problems/number-of-ways-of-cutting-a-pizza/">1444. Number of Ways of Cutting a Pizza</a> #Hard</h2><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza/discuss/623732/JavaC%2B%2B-DP-%2B-PrefixSum-in-Matrix-Clean-code">[Java/C++] DP + PrefixSum in Matrix - Clean code</a></p><p>放弃治疗系列，直接看大佬的解法吧。</p><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ways</span><span class="params">(vector&lt;string&gt;&amp; pizza, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = pizza.<span class="built_in">size</span>(), n = pizza[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(k, <span class="built_in">vector</span>(m, <span class="built_in">vector</span>(n, <span class="number">-1</span>)));</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">preSum</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = m - <span class="number">1</span>; r &gt;= <span class="number">0</span>; --r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = n - <span class="number">1</span>; c &gt;= <span class="number">0</span>; --c) &#123;</span><br><span class="line">                preSum[r][c] = preSum[r][c+<span class="number">1</span>] + preSum[r+<span class="number">1</span>][c] - preSum[r+<span class="number">1</span>][c+<span class="number">1</span>];</span><br><span class="line">                preSum[r][c] += (pizza[r][c] == <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(m, n, k<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, dp, preSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> r, <span class="keyword">int</span> c,</span></span></span><br><span class="line"><span class="function"><span class="params">            vector&lt;vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt; &amp;dp, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;preSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preSum[r][c] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp[k][r][c] != <span class="number">-1</span>) <span class="keyword">return</span> dp[k][r][c];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nr = r + <span class="number">1</span>; nr &lt; m; ++nr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (preSum[r][c] - preSum[nr][c] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans = (ans + <span class="built_in">dfs</span>(m, n, k<span class="number">-1</span>, nr, c, dp, preSum)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nc = c + <span class="number">1</span>; nc &lt; n; ++nc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (preSum[r][c] - preSum[r][nc] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans = (ans + <span class="built_in">dfs</span>(m, n, k<span class="number">-1</span>, r, nc, dp, preSum)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][r][c] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 周赛专题每周随缘更新，点击类别 &lt;a href=&quot;/categories/LeetCode-Weekly-Contest/&quot;&gt;LeetCode Weekly Contest&lt;/a&gt; 查看更多。&lt;/p&gt;
&lt;p&gt;本次比赛通过 &lt;code&gt;3&lt;/code&gt; 题，时间为 &lt;code&gt;1:14:56&lt;/code&gt;，排名为 &lt;code&gt;2375/12715&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="LeetCode Weekly Contest" scheme="https://progcz.com/categories/A03-LeetCode/LeetCode-Weekly-Contest/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Data Structure and Algorithm" scheme="https://progcz.com/tags/Data-Structure-and-Algorithm/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 May LeetCoding Challenge - Week 2</title>
    <link href="https://progcz.com/posts/2020-may-leetcoding-challenge-week-2/"/>
    <id>https://progcz.com/posts/2020-may-leetcoding-challenge-week-2/</id>
    <published>2020-05-08T08:07:28.000Z</published>
    <updated>2020-05-14T09:26:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 五月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-May-LeetCoding-Challenge/">2020 May LeetCoding Challenge</a> 查看更多。</p><span id="more"></span><h2 id="May-8th-Check-If-It-Is-a-Straight-Line"><a href="#May-8th-Check-If-It-Is-a-Straight-Line" class="headerlink" title="May 8th: Check If It Is a Straight Line"></a>May 8th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/535/week-2-may-8th-may-14th/3323/">Check If It Is a Straight Line</a></h2><p>You are given an array <code>coordinates</code>, <code>coordinates[i] = [x, y]</code>, where <code>[x, y]</code> represents the coordinate of a point. Check if these points make a straight line in the XY plane.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: coordinates &#x3D; [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: coordinates &#x3D; [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><p><code>2 &lt;= coordinates.length &lt;= 1000</code></p></li><li><p><code>coordinates[i].length == 2</code></p></li><li><p><code>-10^4 &lt;= coordinates[i][0], coordinates[i][1] &lt;= 10^4</code></p></li><li><p><code>coordinates</code> contains no duplicate point.</p></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>遍历所有点，每两点 <code>[x1, y1]</code> 和 <code>[x2, y2]</code> 之间计算斜率 <code>k</code>，判断其是否在遍历过程中保持不变。</p><p>实际上就是首先计算开头两点的斜率，然后判断后面的斜率是否与其相等。</p><div class="note warning"><p>需要注意的是，如果 <code>x1</code> 和 <code>x2</code> 相等，则无法通过除法计算斜率 <code>k</code>，此时将 <code>k</code> 赋值为 <code>DBL_MAX</code>，用来表示无穷大的斜率。</p></div><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkStraightLine</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = coordinates.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">double</span> k = DBL_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">double</span> x1 = coordinates[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">double</span> y1 = coordinates[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">double</span> x2 = coordinates[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">double</span> y2 = coordinates[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (k == DBL_MIN) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x1 == x2) k = DBL_MAX;</span><br><span class="line">                <span class="keyword">else</span> k = (y2 - y1) / (x2 - x1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((x1 == x2 &amp;&amp; k != DBL_MAX) ||</span><br><span class="line">                (x1 != x2 &amp;&amp; (y2 - y1) / (x2 - x1) != k)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-9th-Valid-Perfect-Square"><a href="#May-9th-Valid-Perfect-Square" class="headerlink" title="May 9th: Valid Perfect Square"></a>May 9th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/535/week-2-may-8th-may-14th/3324/">Valid Perfect Square</a></h2><p>Given a positive integer <code>num</code>, write a function which returns True if <code>num</code> is a perfect square else False.</p><p><strong>Note:</strong> Do not use any built-in library function such as <code>sqrt</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 16</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 14</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>侮辱智商，不解释了。</p><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (t * t &lt; num) ++t;</span><br><span class="line">        <span class="keyword">return</span> t * t == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-10th-Find-the-Town-Judge"><a href="#May-10th-Find-the-Town-Judge" class="headerlink" title="May 10th: Find the Town Judge"></a>May 10th: <a href="https://leetcode.com/explore/featured/card/may-leetcoding-challenge/535/week-2-may-8th-may-14th/3325/">Find the Town Judge</a></h2><p>In a town, there are <code>N</code> people labelled from <code>1</code> to <code>N</code>. There is a rumor that one of these people is secretly the town judge.</p><p>If the town judge exists, then:</p><ol><li><p>The town judge trusts nobody.</p></li><li><p>Everybody (except for the town judge) trusts the town judge.</p></li><li><p>There is exactly one person that satisfies properties 1 and 2.</p></li></ol><p>You are given <code>trust</code>, an array of pairs <code>trust[i] = [a, b]</code> representing that the person labelled <code>a</code> trusts the person labelled <code>b</code>.</p><p>If the town judge exists and can be identified, return the label of the town judge. Otherwise, return <code>-1</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 2, trust &#x3D; [[1,2]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 3, trust &#x3D; [[1,3],[2,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 3, trust &#x3D; [[1,3],[2,3],[3,1]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 3, trust &#x3D; [[1,2],[2,3]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 4, trust &#x3D; [[1,3],[1,4],[2,3],[2,4],[4,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p><code>1 &lt;= N &lt;= 1000</code></p></li><li><p><code>trust.length &lt;= 10000</code></p></li><li><p><code>trust[i]</code> are all different</p></li><li><p><code>trust[i][0] != trust[i][1]</code></p></li><li><p><code>1 &lt;= trust[i][0], trust[i][1] &lt;= N</code></p></li></ul><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，使用 <code>map&lt;int, set&lt;int&gt;&gt; m</code> 存放某个人的受信任列表，即信任某个人的所有人。</p><p>其次，遍历 <code>m</code>，<strong>如果信任这个人 <code>p.first</code> 的所有人 <code>p.second</code> 共有 <code>N-1</code> 个，那么说明 <code>p.first</code> 受其他所有人的信任。</strong></p><p>然后，对于这个人 <code>p.first</code>，遍历其他人 <code>p.second</code>，<strong>如果 <code>p.first</code> 不存在于任何人的受信任列表 <code>m[t]</code> 中，那么说明 <code>p.first</code> 不信任其他所有人。</strong></p><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findJudge</span><span class="params">(<span class="keyword">int</span> N, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; trust)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, set&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> vi : trust) m[vi[<span class="number">1</span>]].<span class="built_in">insert</span>(vi[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second.<span class="built_in">size</span>() == N<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">bool</span> b = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> t : p.second) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (m[t].<span class="built_in">count</span>(p.first)) &#123;</span><br><span class="line">                        b = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (b) <span class="keyword">return</span> p.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-11th-Flood-Fill"><a href="#May-11th-Flood-Fill" class="headerlink" title="May 11th: Flood Fill"></a>May 11th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/535/week-2-may-8th-may-14th/3326/">Flood Fill</a></h2><p>An <code>image</code> is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).</p><p>Given a coordinate <code>(sr, sc)</code> representing the starting pixel (row and column) of the flood fill, and a pixel value <code>newColor</code>, “flood fill” the image.</p><p>To perform a “flood fill”, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.</p><p>At the end, return the modified image.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">image &#x3D; [[1,1,1],[1,1,0],[1,0,1]]</span><br><span class="line">sr &#x3D; 1, sc &#x3D; 1, newColor &#x3D; 2</span><br><span class="line">Output: [[2,2,2],[2,2,0],[2,0,1]]</span><br><span class="line">Explanation: </span><br><span class="line">From the center of the image (with position (sr, sc) &#x3D; (1, 1)), all pixels connected</span><br><span class="line">by a path of the same color as the starting pixel are colored with the new color.</span><br><span class="line">Note the bottom corner is not colored 2, because it is not 4-directionally connected</span><br><span class="line">to the starting pixel.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p>The length of <code>image</code> and <code>image[0]</code> will be in the range <code>[1, 50]</code>.</p></li><li><p>The given starting pixel will satisfy <code>0 &lt;= sr &lt; image.length</code> and <code>0 &lt;= sc &lt; image[0].length</code>.</p></li><li><p>The value of each color in <code>image[i][j]</code> and <code>newColor</code> will be an integer in <code>[0, 65535]</code>.</p></li></ul><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>典型的深度优先搜索算法就可以解决。</p><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">floodFill</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = image.<span class="built_in">size</span>(), n = image[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">func</span>(image, visited, sr, sc, image[sr][sc], newColor);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;image, vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; &amp;visited,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> startColor, <span class="keyword">int</span> newColor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = image.<span class="built_in">size</span>(), n = image[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n ||</span><br><span class="line">            visited[x][y] || image[x][y] != startColor) <span class="keyword">return</span>;</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        image[x][y] = newColor;</span><br><span class="line">        <span class="built_in">func</span>(image, visited, x<span class="number">-1</span>, y, startColor, newColor);</span><br><span class="line">        <span class="built_in">func</span>(image, visited, x+<span class="number">1</span>, y, startColor, newColor);</span><br><span class="line">        <span class="built_in">func</span>(image, visited, x, y<span class="number">-1</span>, startColor, newColor);</span><br><span class="line">        <span class="built_in">func</span>(image, visited, x, y+<span class="number">1</span>, startColor, newColor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-12th-Single-Element-in-a-Sorted-Array"><a href="#May-12th-Single-Element-in-a-Sorted-Array" class="headerlink" title="May 12th: Single Element in a Sorted Array"></a>May 12th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/535/week-2-may-8th-may-14th/3327/">Single Element in a Sorted Array</a></h2><p>You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Find this single element that appears only once.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,1,2,3,3,4,4,8,8]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,3,7,7,10,11,11]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> Your solution should run in O(log n) time and O(1) space.</p><h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><div class="note info"><p>需要明白的是，异或运算具备两个重要性质：</p><ul><li><p>对于数字 <code>num</code> 来说，<code>num ^ num == 0</code>。</p></li><li><p>对于数字 <code>num</code> 来说，<code>num ^ 0 == num</code>。</p></li></ul></div><p>对于出现两次的数字来说，遍历过程中的异或运算必然使其自身抵消，最终剩下出现一次的数字作为计算结果。</p><h4 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) res ^= num;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-13th-Remove-K-Digits"><a href="#May-13th-Remove-K-Digits" class="headerlink" title="May 13th: Remove K Digits"></a>May 13th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/535/week-2-may-8th-may-14th/3328/">Remove K Digits</a></h2><p>Given a non-negative integer <code>num</code> represented as a string, remove <code>k</code> digits from the number so that the new number is the smallest possible.</p><p><strong>Note:</strong></p><ul><li><p>The length of <code>num</code> is less than 10002 and will be ≥ <code>k</code>.</p></li><li><p>The given <code>num</code> does not contain any leading zero.</p></li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num &#x3D; &quot;1432219&quot;, k &#x3D; 3</span><br><span class="line">Output: &quot;1219&quot;</span><br><span class="line">Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num &#x3D; &quot;10200&quot;, k &#x3D; 1</span><br><span class="line">Output: &quot;200&quot;</span><br><span class="line">Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num &#x3D; &quot;10&quot;, k &#x3D; 2</span><br><span class="line">Output: &quot;0&quot;</span><br><span class="line">Explanation: Remove all the digits from the number and it is left with nothing which is 0.</span><br></pre></td></tr></table></figure><h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://www.cnblogs.com/grandyang/p/5883736.html">[LeetCode] 402. Remove K Digits 去掉 K 位数字 - 刷尽天下</a></p><p>将 <code>num</code> 中的字符逐个添加到 <code>res</code> 中，为了保证高位上的数字尽可能地小，在添加过程中需要去除 <code>res</code> 中比当前字符大的字符，从而保证 <code>res</code> 是非递减的。</p><h4 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeKdigits</span><span class="params">(string num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> n = num.<span class="built_in">size</span>(), keep = n - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : num) &#123;</span><br><span class="line">            <span class="keyword">while</span> (k &amp;&amp; res.<span class="built_in">size</span>() &amp;&amp; res.<span class="built_in">back</span>() &gt; c) &#123;</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">resize</span>(keep);</span><br><span class="line">        <span class="keyword">while</span> (!res.<span class="built_in">empty</span>() &amp;&amp; res[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            res.<span class="built_in">erase</span>(res.<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">empty</span>() ? <span class="string">&quot;0&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-14th-Implement-Trie-Prefix-Tree"><a href="#May-14th-Implement-Trie-Prefix-Tree" class="headerlink" title="May 14th: Implement Trie (Prefix Tree)"></a>May 14th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/535/week-2-may-8th-may-14th/3329/">Implement Trie (Prefix Tree)</a></h2><p>Implement a trie with <code>insert</code>, <code>search</code>, and <code>startsWith</code> methods.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; returns true</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; returns false</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; returns true</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; returns true</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p>You may assume that all inputs are consist of lowercase letters <code>a-z</code>.</p></li><li><p>All inputs are guaranteed to be non-empty strings.</p></li></ul><h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>对于 <code>insert</code> 和 <code>search</code> 方法，可以使用 <code>set&lt;string&gt; s</code> 的 <code>insert</code> 和 <code>count</code> 方法实现。</p><p>对于 <code>startsWith</code> 方法，因为 <code>set</code> 自动对元素（此处为字符串）进行排序，所以可以遍历找到<strong>第一个大于等于 <code>prefix</code> 的字符串</strong>，如果该字符串是以 <code>prefix</code> 开头的，那么返回 <code>true</code>，否则返回 <code>false</code>。</p><h4 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    set&lt;string&gt; s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">Trie</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        s.<span class="built_in">insert</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">count</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = s.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (iter != s.<span class="built_in">end</span>() &amp;&amp; *iter &lt; prefix) ++iter;</span><br><span class="line">        <span class="keyword">return</span> iter != s.<span class="built_in">end</span>() &amp;&amp; prefix == iter-&gt;<span class="built_in">substr</span>(<span class="number">0</span>, prefix.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 五月挑战专题每日随缘更新，点击类别 &lt;a href=&quot;/categories/2020-May-LeetCoding-Challenge/&quot;&gt;2020 May LeetCoding Challenge&lt;/a&gt; 查看更多。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="2020 LeetCoding Challenge" scheme="https://progcz.com/categories/A03-LeetCode/2020-LeetCoding-Challenge/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Data Structure and Algorithm" scheme="https://progcz.com/tags/Data-Structure-and-Algorithm/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Challenge" scheme="https://progcz.com/tags/Challenge/"/>
    
  </entry>
  
</feed>
