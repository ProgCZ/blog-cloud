<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ProgCZ&#39;s Blog</title>
  
  
  <link href="https://progcz.com/atom.xml" rel="self"/>
  
  <link href="https://progcz.com/"/>
  <updated>2021-12-07T09:13:13.000Z</updated>
  <id>https://progcz.com/</id>
  
  <author>
    <name>ProgCZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微软（苏州）面试经历：从入门到入职</title>
    <link href="https://progcz.com/posts/1638593506/"/>
    <id>https://progcz.com/posts/1638593506/</id>
    <published>2021-12-04T04:55:51.000Z</published>
    <updated>2021-12-07T09:13:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>年末，微软面试终于告一段落，目前已经签定 Offer Letter，处于背调阶段，不出意外的话，月底就会入职。</p><p>在准备面试的过程中，一众大佬的面经给了我很多启发，如今到了薪火相传的时候，希望我的面经对你也能有所帮助。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/12/07/01.png"></p><span id="more"></span><div class="note success"><p><strong>微软内推，可以发送邮件至 <a href="mailto:progcz@yeah.net">progcz@yeah.net</a>，记得附上简历、心仪的岗位及链接（可以<a href="https://careers.microsoft.com/us/en/search-results">官网</a>搜索）和简单的自我介绍哦。</strong></p></div><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><p>面经，向来是典型的「小马过河」问题。不同的人有着不同的教育和工作经历，装备等级在一定程度上影响着打怪难度，所以<strong>你我的背景越相近，面经才越具备参考价值。</strong></p><h3 id="1-1-教育经历"><a href="#1-1-教育经历" class="headerlink" title="1.1 教育经历"></a>1.1 教育经历</h3><p>2017 年本科毕业于厦门大学测控技术与仪器专业，2020 年硕士毕业于中国科学技术大学控制工程专业。所以，我并非计算机科班出身，更多是靠选修和自学来接触的编程。</p><h3 id="1-2-工作经历"><a href="#1-2-工作经历" class="headerlink" title="1.2 工作经历"></a>1.2 工作经历</h3><p>2020 年入职字节跳动（上海），担任推荐算法工程师。至于为什么离开字节，我想这应该是下一篇文章的主题了，写在正式离开字节之后。</p><h3 id="1-3-面试岗位"><a href="#1-3-面试岗位" class="headerlink" title="1.3 面试岗位"></a>1.3 面试岗位</h3><p>微软（苏州），Windows 365 软件开发工程师。</p><blockquote><p>JD 参考：<a href="https://careers.microsoft.com/us/en/job/1168023/Windows-365-Software-Engineer">https://careers.microsoft.com/us/en/job/1168023/Windows-365-Software-Engineer</a></p></blockquote><h2 id="2-简历"><a href="#2-简历" class="headerlink" title="2 简历"></a>2 简历</h2><p>如下所示，我并没有套用模板，只是参考了下简历一般需要哪些信息，然后用 Word 最基础的功能，做了一份够简的简历出来。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/12/07/02.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/12/07/03.png"></div></div></div><p>几点可能有用的建议：</p><ul><li><p>准备中、英两版简历，做在同一个 Word 文件中，导入同一个 PDF 文件中。</p></li><li><p>保持简洁，重要的信息，尤其是与所面岗位相契合的信息，应该大书特书，占最大的版面。</p></li></ul><h2 id="3-人生问题"><a href="#3-人生问题" class="headerlink" title="3 人生问题"></a>3 人生问题</h2><p><strong>开个文档，针对面试中常见的人生问题，把答案提前准备一遍，每个答案都尽量保持在 5 - 10 分钟。</strong></p><p>准备的过程，其实也是与自己对话的过程，因此这样做并不是为了弄虚作假，而是为了在被问到的时候，能够从容应对，逻辑清晰地表达内心想法。</p><p>比如：</p><ul><li><p>为什么想离开上一家公司？为什么想加入我们这家公司？</p></li><li><p>简单介绍一下简历上的某个项目？你在其中承担哪一部分的工作？遇到最大的挑战是什么？</p></li><li><p>未来的职业规划是什么？想成为一个什么样的工程师？</p></li><li><p>简单介绍一下自己的优缺点？</p></li><li><p>有什么想问我的吗？</p></li></ul><h2 id="4-算法题目"><a href="#4-算法题目" class="headerlink" title="4 算法题目"></a>4 算法题目</h2><p>优先刷下 LeetCode 的 <a href="https://leetcode.com/problemset/all/?listId=wpwgkgt&page=1">Top Interview Questions</a>，难度在 Medium 及以下即可。</p><p>几点可能有用的建议：</p><ul><li><p>每道题目限定 20 分钟，没做出来直接去看 Discuss 里 Most Votes 的答案（如果英文吃力，可以参考 <a href="https://www.cnblogs.com/grandyang/p/4606334.html">LeetCode All in One</a> 项目），看完之后自己手写一遍。</p></li><li><p>不要满足于仅一种解法，要问这么几个问题：</p><ul><li><p>现在这个解法，时间复杂度、空间复杂度是多少？</p></li><li><p>还有没有解法，可以降低时间复杂度，或者降低空间复杂度，或者写法上更简洁？</p></li></ul></li><li><p>会讲思路，在写代码前能把解法口头描述出来。</p></li><li><p>会写测试代码和测试用例，在运行前能考虑到尽量多的 corner case，在运行后能根据 error case 分析代码中的 bug。</p>  <details class="note info"><summary><p>面试过程中，推荐使用 LeetCode 的 <a href="https://leetcode.com/playground/">Playground</a> 编写代码，相比 <a href="https://codeshare.io/">Codeshare</a>，Playground 可以在线编译并运行，测试起来非常方便<strong>（微软的面试官都非常注重测试）</strong>。</p></summary><p>比如，我在<a href="/posts/1633654398/">常见排序算法的 C++ 实现、复杂度和稳定性分析</a>中给出的 <a href="https://leetcode.com/playground/gZfypPAn">Playground</a>：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/12/07/04.png"></p></details></li></ul><h2 id="5-面试"><a href="#5-面试" class="headerlink" title="5 面试"></a>5 面试</h2><p>简单记录一下我的面试过程，以供参考。</p><h3 id="5-1-第一轮面试"><a href="#5-1-第一轮面试" class="headerlink" title="5.1 第一轮面试"></a>5.1 第一轮面试</h3><p>常规，聊工作项目，做算法题目。</p><ul><li><p>算法题目：给定一个由 <code>0</code> 和 <code>1</code> 组成的矩阵，从左上角出发，只能向右或向下移动，<code>0</code> 表示可以通行，<code>1</code> 表示不可通行，求解到达右下角的不同路径的数量。原题参考：<a href="https://leetcode.com/problems/unique-paths-ii/">LeetCode 63. Unique Paths II</a></p><p>  解法：动态规划，维护一个同样尺寸的矩阵，矩阵中的每个值代表从左上角到这一格的不同路径的数量，那么容易得到，每个值都是其左侧格（如有）的值与其上方格（如有）的值之和，而该矩阵左上角的值确定为 <code>1</code>，则从左上角开始遍历更新，最终返回右下角的值即可。</p>  <div class="note success"><p>上述解法写完之后，我主动与面试官进一步讲了，如何将空间复杂度从 <code>O(n^2)</code> 优化至 <code>O(n)</code>：不需要维护整个矩阵，只需要维护遍历位置的当前行即可。我相信这应该是个加分项。</p></div></li></ul><h3 id="5-2-第二轮面试（连续三场）"><a href="#5-2-第二轮面试（连续三场）" class="headerlink" title="5.2 第二轮面试（连续三场）"></a>5.2 第二轮面试（连续三场）</h3><p>连续三场面试真的很累，一定注意精力管理。</p><h4 id="第一场"><a href="#第一场" class="headerlink" title="第一场"></a>第一场</h4><p>科大师兄，聊学校，聊毕业论文（这个让我有点意外，我以为社招只会聊工作项目），做算法题目。</p><ul><li><p>算法题目：给定一个 <code>long long</code> 类型的数字，以 <code>long long</code> 类型返回其 reverse 后的数字。相似题目参考：<a href="https://leetcode.com/problems/reverse-integer/">LeetCode 7. Reverse Integer</a></p><p>  解法：题目并不难，主要考察如何处理 corner case，比如负数、结果值溢出、中间值溢出等情况。</p></li></ul><h4 id="第二场"><a href="#第二场" class="headerlink" title="第二场"></a>第二场</h4><p>常规，聊工作项目，做算法题目。</p><ul><li><p>算法题目一：给定一个尺寸为 n 的数组，其值均在 [1, n+1] 之间，有且只有一个数字不在这个数组中，找出这个数字。</p><p>  解法：题目并不难，实际上简单的数学运算就可以，但是面试官还是问了有没有其他解法，最后写了一个使用两轮异或运算的解法。</p></li><li><p>算法题目二：给定一个数组和一个目标值，在数组中找到三数之和，使其最接近目标值。原题参考：<a href="https://leetcode.com/problems/3sum-closest">LeetCode 16. 3Sum Closest</a></p><p>  解法：面试过程中只给了暴力解法，面试结束后才想起来，使用头尾双指针的解法，可以把时间复杂度优化到 <code>O(n^2)</code>。</p></li></ul><h4 id="第三场"><a href="#第三场" class="headerlink" title="第三场"></a>第三场</h4><p>科大师兄，聊工作项目，问 C++ 题目，做算法题目。</p><ul><li><p>C++ 题目：C++ 11 相比于 C++ 98，有什么新特性？智能指针 <code>unique_ptr</code> 是怎么实现资源独占的？</p><p>  答案：第一个问题老生常谈，可以参考<a href="/posts/1634567000/#%E7%9B%B8%E6%AF%94%E4%BA%8E-C-98%EF%BC%8CC-11-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F">面试中常见的 C++ 问题汇总</a>；第二个问题，面试过程中猜错了，正确答案是 <code>unique_ptr</code> 使用 <code>= delete</code> 禁用了拷贝构造函数。</p></li><li><p>算法题目：对于带有随机指针的链表，进行深拷贝。原题参考：<a href="https://leetcode.com/problems/copy-list-with-random-pointer/">LeetCode 138. Copy List with Random Pointer</a></p><p>  解法：第一轮遍历，先不考虑随机指针的拷贝，遍历原链表，构造新链表，在遍历过程中，将新链表节点的随机指针指向原链表节点，同时维护从原链表节点到新链表节点的映射；第二轮遍历，遍历新链表，从新链表节点的随机指针找到原链表节点，再从原链表节点的随机指针找到原链表随机节点，再从映射找到新链表随机节点，赋值给新链表的随机指针即可。</p>  <div class="note info"><p>解法的难度是一方面，测试的难度才是真正考察的点。</p><p>在面试过程中，为了方便测试，我实现了 <code>MyListNode* vec2list(vector&lt;pair&lt;int, int&gt;&gt;&amp; vec);</code> 将测试用例从数组形式构造为链表形式，实现了 <code>bool valid(MyListNode* root_1, MyListNode* root_2);</code> 用来判断两个链表是否互为深拷贝的关系。</p><p>尤其是 <code>valid</code> 这个函数，千算万算还是百密一疏，面试官最后指出了其中可能存在的漏洞。</p></div></li></ul><h3 id="5-3-第三轮面试"><a href="#5-3-第三轮面试" class="headerlink" title="5.3 第三轮面试"></a>5.3 第三轮面试</h3><p>最后一面是跟老板（竟然也是科大师兄）面，邮件里的 PRINCIPAL GROUP SW ENG MGR 格外显眼。</p><p>其实能到最后一面，说明候选人在技术方面没什么太大问题，<strong>老板考察更多的是，候选人是否具备成为优秀工程师的基本素养。</strong></p><ul><li><p>人生问题：</p><ol><li><p>为什么想离开字节，为什么想加入微软？</p></li><li><p>希望成为一个什么样的工程师？</p></li><li><p>在字节有什么样的成长？</p></li><li><p>对 Windows 365 产品有什么样的理解？</p></li></ol></li><li><p>算法题目：实现 sqrt 运算，计算算术平方根，结果向下取整。原题参考：<a href="https://leetcode.com/problems/sqrtx/">LeetCode 69. Sqrt(x)</a></p><p>  解法：二分法。</p></li></ul><h2 id="6-致谢"><a href="#6-致谢" class="headerlink" title="6 致谢"></a>6 致谢</h2><ul><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwODE4Nzg2NQ==&mid=2650548534&idx=1&sn=7b8b5f417e3e9423f6584bdc69328abc&chksm=8f0e7180b879f8964f57da433275455d456930a891594ebf9fd213c40c1e08def7e929e4a95a&scene=21#wechat_redirect">微软面经分享：如何更好地做好面试准备</a></p></li><li><p><a href="https://www.paincker.com/microsoft-interview">微软面试经历和相关思考总结</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;年末，微软面试终于告一段落，目前已经签定 Offer Letter，处于背调阶段，不出意外的话，月底就会入职。&lt;/p&gt;
&lt;p&gt;在准备面试的过程中，一众大佬的面经给了我很多启发，如今到了薪火相传的时候，希望我的面经对你也能有所帮助。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/12/07/01.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A1 - 生活" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB/"/>
    
    <category term="B1 - 经历" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB/B1-%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="面试" scheme="https://progcz.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="微软" scheme="https://progcz.com/tags/%E5%BE%AE%E8%BD%AF/"/>
    
    <category term="苏州" scheme="https://progcz.com/tags/%E8%8B%8F%E5%B7%9E/"/>
    
    <category term="社招" scheme="https://progcz.com/tags/%E7%A4%BE%E6%8B%9B/"/>
    
    <category term="内推" scheme="https://progcz.com/tags/%E5%86%85%E6%8E%A8/"/>
    
  </entry>
  
  <entry>
    <title>面试中常见的二叉树题目汇总</title>
    <link href="https://progcz.com/posts/1635906832/"/>
    <id>https://progcz.com/posts/1635906832/</id>
    <published>2021-11-03T02:34:37.000Z</published>
    <updated>2021-11-03T08:22:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>重点解决 LeetCode 中 List 为 Top Interview Questions 且 Tag 为 Binary Tree 的题目。</p><span id="more"></span><h2 id="1-二叉树的遍历（常规形式）"><a href="#1-二叉树的遍历（常规形式）" class="headerlink" title="1 二叉树的遍历（常规形式）"></a>1 二叉树的遍历（常规形式）</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出二叉树的前序（Pre-Order）、中序（In-Order）、后序（Post-Order）遍历的递归、循环实现。</p><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><p>递归版本：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode *root, vector&lt;<span class="keyword">int</span>&gt; &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// Pre-Order</span></span><br><span class="line">    path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;left, path);</span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;right, path);</span><br><span class="line">    <span class="comment">// In-Order</span></span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;left, path);</span><br><span class="line">    path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;right, path);</span><br><span class="line">    <span class="comment">// Post-Order</span></span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;left, path);</span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;right, path);</span><br><span class="line">    path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环版本：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; path = &#123;&#125;;</span><br><span class="line">        stack&lt;pair&lt;TreeNode*, <span class="keyword">bool</span>&gt;&gt; s;</span><br><span class="line">        s.<span class="built_in">push</span>(&#123;root, <span class="literal">false</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> p = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* node = p.first;</span><br><span class="line">            <span class="keyword">bool</span> visited = p.second;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (visited) &#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Pre-Order</span></span><br><span class="line">                s.<span class="built_in">push</span>(&#123;node-&gt;right, <span class="literal">false</span>&#125;);</span><br><span class="line">                s.<span class="built_in">push</span>(&#123;node-&gt;left, <span class="literal">false</span>&#125;);</span><br><span class="line">                s.<span class="built_in">push</span>(&#123;node, <span class="literal">true</span>&#125;);</span><br><span class="line">                <span class="comment">// In-Order</span></span><br><span class="line">                s.<span class="built_in">push</span>(&#123;node-&gt;right, <span class="literal">false</span>&#125;);</span><br><span class="line">                s.<span class="built_in">push</span>(&#123;node, <span class="literal">true</span>&#125;);</span><br><span class="line">                s.<span class="built_in">push</span>(&#123;node-&gt;left, <span class="literal">false</span>&#125;);</span><br><span class="line">                <span class="comment">// Post-Order</span></span><br><span class="line">                s.<span class="built_in">push</span>(&#123;node, <span class="literal">true</span>&#125;);</span><br><span class="line">                s.<span class="built_in">push</span>(&#123;node-&gt;right, <span class="literal">false</span>&#125;);</span><br><span class="line">                s.<span class="built_in">push</span>(&#123;node-&gt;left, <span class="literal">false</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-二叉树的层级遍历"><a href="#2-二叉树的层级遍历" class="headerlink" title="2 二叉树的层级遍历"></a>2 二叉树的层级遍历</h2><p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">LeetCode 102. Binary Tree Level Order Traversal</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出二叉树的层级（Level）遍历的循环实现，同一层的元素放在同一个数组里，不同层的元素放在不同的数组里。</p><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res = &#123;&#125;;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">        queue&lt;TreeNode*&gt; tq;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">continue</span>;</span><br><span class="line">            level.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            tq.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            tq.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!level.<span class="built_in">empty</span>()) res.<span class="built_in">push_back</span>(level);</span><br><span class="line">        q = tq;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-二叉树的之字形遍历"><a href="#3-二叉树的之字形遍历" class="headerlink" title="3 二叉树的之字形遍历"></a>3 二叉树的之字形遍历</h2><p><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">LeetCode 103. Binary Tree Zigzag Level Order Traversal</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出二叉树的之字形（Zigzag）遍历的循环实现，同一层的元素放在同一个数组里，不同层的元素放在不同的数组里。</p><h3 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res = &#123;&#125;;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">        stack&lt;TreeNode*&gt; ts;</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">continue</span>;</span><br><span class="line">            level.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                ts.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                ts.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ts.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                ts.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!level.<span class="built_in">empty</span>()) res.<span class="built_in">push_back</span>(level);</span><br><span class="line">        s = ts;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-根据前序遍历和中序遍历构造二叉树"><a href="#4-根据前序遍历和中序遍历构造二叉树" class="headerlink" title="4 根据前序遍历和中序遍历构造二叉树"></a>4 根据前序遍历和中序遍历构造二叉树</h2><p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>以数组形式给定二叉树的前序遍历和中序遍历，构造出该二叉树的数据结构。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据前序遍历的定义，<code>preorder</code> 的第 <code>0</code> 个元素 <code>preorder[0]</code>，必然是整个二叉树的根节点，构造该节点。</p><p>根据中序遍历的定义，<code>preorder[0]</code> 在 <code>inorder</code> 中的位置，其左侧所有元素会构成根节点的左子树，其右侧所有元素会构成根节点的右子树。</p><p>接着 <code>preorder</code> 的第 <code>1</code> 个元素 <code>preorder[1]</code>，必然是左子树的根节点，构造该节点，其在 <code>inorder</code> 中的位置，左侧构成左子树的左子树，右侧构成左子树的右子树。</p><p>不断重复上述过程，便可不断构造子树。</p><h3 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = inorder.<span class="built_in">size</span>(), pre_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            inorder_val2idx[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(preorder, inorder, pre_idx, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span>&amp; pre_idx, <span class="keyword">int</span> in_beg, <span class="keyword">int</span> in_end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in_beg &gt; in_end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[pre_idx]);</span><br><span class="line">        <span class="keyword">int</span> in_idx = inorder_val2idx[preorder[pre_idx]];</span><br><span class="line">        ++pre_idx;</span><br><span class="line">        root-&gt;left = <span class="built_in">build</span>(preorder, inorder, pre_idx, in_beg, in_idx<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">build</span>(preorder, inorder, pre_idx, in_idx+<span class="number">1</span>, in_end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; inorder_val2idx = &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-根据中序遍历和后序遍历构造二叉树"><a href="#5-根据中序遍历和后序遍历构造二叉树" class="headerlink" title="5 根据中序遍历和后序遍历构造二叉树"></a>5 根据中序遍历和后序遍历构造二叉树</h2><p><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">LeetCode 106. Construct Binary Tree from Inorder and Postorder Traversal</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>以数组形式给定二叉树的前序遍历和中序遍历，构造出该二叉树的数据结构。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>与前一题的思路一致，不再赘述。</p><h3 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = inorder.<span class="built_in">size</span>(), post_idx = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            inorder_val2idx[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(inorder, postorder, <span class="number">0</span>, n<span class="number">-1</span>, post_idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> in_beg, <span class="keyword">int</span> in_end, <span class="keyword">int</span>&amp; post_idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in_beg &gt; in_end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(postorder[post_idx]);</span><br><span class="line">        <span class="keyword">int</span> in_idx = inorder_val2idx[postorder[post_idx]];</span><br><span class="line">        --post_idx;</span><br><span class="line">        root-&gt;right = <span class="built_in">build</span>(inorder, postorder, in_idx+<span class="number">1</span>, in_end, post_idx);</span><br><span class="line">        root-&gt;left = <span class="built_in">build</span>(inorder, postorder, in_beg, in_idx<span class="number">-1</span>, post_idx);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; inorder_val2idx = &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-找出二叉树中两个节点的最小公共父节点"><a href="#6-找出二叉树中两个节点的最小公共父节点" class="headerlink" title="6 找出二叉树中两个节点的最小公共父节点"></a>6 找出二叉树中两个节点的最小公共父节点</h2><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">LeetCode 236. Lowest Common Ancestor of a Binary Tree</a></p><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>给定二叉树，找出其中两个节点的最小公共父节点。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>对二叉树进行遍历，过程中不断判断，当前节点及左右子树是否包含 <code>p</code> 和 <code>q</code>，如果同时满足，则记录该节点，记录一次之后不再记录，保证记录的为最小公共子节点。</p><h3 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        TreeNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> ret = <span class="built_in">travel</span>(root, p, q, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    pair&lt;bool, bool&gt; travel(TreeNode* node, TreeNode* p, TreeNode* q, TreeNode* &amp;res) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node || res) <span class="keyword">return</span> &#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> left_ret = <span class="built_in">travel</span>(node-&gt;left, p, q, res);</span><br><span class="line">        <span class="keyword">auto</span> right_ret = <span class="built_in">travel</span>(node-&gt;right, p, q, res);</span><br><span class="line">        <span class="keyword">bool</span> p_hit = (node == p) || left_ret.first || right_ret.first;</span><br><span class="line">        <span class="keyword">bool</span> q_hit = (node == q) || left_ret.second || right_ret.second;</span><br><span class="line">        <span class="keyword">if</span> (p_hit &amp;&amp; q_hit &amp;&amp; !res) &#123;</span><br><span class="line">            res = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;p_hit, q_hit&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-验证是否为二叉搜索树"><a href="#7-验证是否为二叉搜索树" class="headerlink" title="7 验证是否为二叉搜索树"></a>7 验证是否为二叉搜索树</h2><p><a href="https://leetcode.com/problems/validate-binary-search-tree/">LeetCode 98. Validate Binary Search Tree</a></p><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>给定二叉树，判断是否为二叉搜索树。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>根据二叉搜索树的定义，对于任意一个节点：</p><ul><li><p>其值大于左子树中任一节点的值，可以等价为其值大于左子树中所有节点的最大值</p></li><li><p>其值小于右子树中任一节点的值，可以等价为其值小于右子树中所有节点的最小值</p></li><li><p>其左子树和右子树也均为二叉搜索树</p></li></ul><h3 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="built_in">is_valid</span>(root);</span><br><span class="line">        <span class="keyword">return</span> p.first;</span><br><span class="line">    &#125;</span><br><span class="line">    pair&lt;<span class="keyword">bool</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">is_valid</span>(TreeNode* node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="literal">true</span>, &#123;node-&gt;val, node-&gt;val&#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> node_min = node-&gt;val, node_max = node-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="built_in">is_valid</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">bool</span> valid = p.first;</span><br><span class="line">            <span class="keyword">auto</span> [left_min, left_max] = p.second;</span><br><span class="line">            <span class="keyword">if</span> (valid &amp;&amp; left_max &lt; node-&gt;val) &#123;</span><br><span class="line">                node_min = left_min;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="literal">false</span>, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="built_in">is_valid</span>(node-&gt;right);</span><br><span class="line">            <span class="keyword">bool</span> valid = p.first;</span><br><span class="line">            <span class="keyword">auto</span> [right_min, right_max] = p.second;</span><br><span class="line">            <span class="keyword">if</span> (valid &amp;&amp; right_min &gt; node-&gt;val) &#123;</span><br><span class="line">                node_max = right_max;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="literal">false</span>, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="literal">true</span>, &#123;node_min, node_max&#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note info"><p>上述实现的难点在于辅助函数 <code>is_valid</code> 返回类型的设计，<code>pair&lt;bool, pair&lt;int, int&gt;&gt;</code> 的含义对应：以 <code>node</code> 为根节点的树是否为二叉搜索树、以 <code>node</code> 为根节点的树的最小值和最大值。</p></div><h2 id="8-根据有序数组构造二叉搜索树"><a href="#8-根据有序数组构造二叉搜索树" class="headerlink" title="8 根据有序数组构造二叉搜索树"></a>8 根据有序数组构造二叉搜索树</h2><p><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">LeetCode 108. Convert Sorted Array to Binary Search Tree</a></p><h3 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h3><p>给定有序数组，由此构造一个平衡的二叉搜索树，平衡是指任一节点的左右子树的深度之差总不超过 1。</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>不断二分，将中位数构造为根节点，其左侧递归构造左子树，其右侧递归构造右子树。</p><h3 id="C-实现-7"><a href="#C-实现-7" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(nums, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beg &gt; end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        node-&gt;left = <span class="built_in">build</span>(nums, beg, mid<span class="number">-1</span>);</span><br><span class="line">        node-&gt;right = <span class="built_in">build</span>(nums, mid+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="9-找出二叉搜索树中第-K-小的元素"><a href="#9-找出二叉搜索树中第-K-小的元素" class="headerlink" title="9 找出二叉搜索树中第 K 小的元素"></a>9 找出二叉搜索树中第 K 小的元素</h2><p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">LeetCode 230. Kth Smallest Element in a BST</a></p><h3 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h3><p>给定二叉搜索树，找出其中第 K 小的元素（从 1 开始计数）。</p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>对二叉搜索树进行中序遍历，从而实现从小到大进行遍历，过程中计数，到 K 则记录节点的值。</p><h3 id="C-实现-8"><a href="#C-实现-8" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> order = <span class="number">1</span>, val = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">travel</span>(root, k, order, val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(TreeNode* node, <span class="keyword">int</span> k, <span class="keyword">int</span>&amp; order, <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">travel</span>(node-&gt;left, k, order, val);</span><br><span class="line">        <span class="keyword">if</span> (order++ == k) val = node-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (order &gt; k) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">travel</span>(node-&gt;right, k, order, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;重点解决 LeetCode 中 List 为 Top Interview Questions 且 Tag 为 Binary Tree 的题目。&lt;/p&gt;</summary>
    
    
    
    <category term="A3 - 技术" scheme="https://progcz.com/categories/A3-%E6%8A%80%E6%9C%AF/"/>
    
    <category term="B1 - 数据结构与算法" scheme="https://progcz.com/categories/A3-%E6%8A%80%E6%9C%AF/B1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="数据结构与算法" scheme="https://progcz.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="面试" scheme="https://progcz.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Binary Tree" scheme="https://progcz.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>面试中常见的链表题目汇总</title>
    <link href="https://progcz.com/posts/1634602816/"/>
    <id>https://progcz.com/posts/1634602816/</id>
    <published>2021-10-19T00:21:15.000Z</published>
    <updated>2021-10-26T01:39:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>重点解决 LeetCode 中 List 为 Top Interview Questions 且 Tag 为 Linked List 的题目。</p><span id="more"></span><h2 id="0-如何写测试代码"><a href="#0-如何写测试代码" class="headerlink" title="0 如何写测试代码"></a>0 如何写测试代码</h2><p>以下是以 <a href="https://leetcode.com/problems/add-two-numbers/">LeetCode 2</a> 为例的，在 LeetCode Playground 完成的 C++ 实现及测试代码：</p><p><a href="https://leetcode.com/playground/WmFSQPkU">https://leetcode.com/playground/WmFSQPkU</a></p><p>其中，测试代码主要包含以下几个部分：</p><ul><li><p>定义单向链表节点：</p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    MyListNode* next;</span><br><span class="line">    <span class="built_in">MyListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">MyListNode</span>(<span class="keyword">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">MyListNode</span>(<span class="keyword">int</span> val, MyListNode* next) : <span class="built_in">val</span>(val), <span class="built_in">next</span>  (next) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>打印链表：</p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_list</span><span class="params">(MyListNode* node)</span> </span>&#123;</span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        oss &lt;&lt; node-&gt;val &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断两个链表是否相等：</p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_equal_list</span><span class="params">(MyListNode* l1, MyListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!l1 &amp;&amp; !l2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!l1 || !l2 || l1-&gt;val != l2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">is_equal_list</span>(l1-&gt;next, l2-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将数组转换为链表：</p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MyListNode* <span class="title">vec2list</span><span class="params">(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (end &gt;= n || beg &gt; end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    MyListNode* node = <span class="keyword">new</span> <span class="built_in">MyListNode</span>(</span><br><span class="line">        vec[beg], <span class="built_in">vec2list</span>(vec, beg+<span class="number">1</span>, end)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这样，我们就可以通过给定数组来测试链表了：</p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; args_1 = &#123;</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">8</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; args_2 = &#123;</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; rets = &#123;</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在主函数中测试：</p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = rets.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        MyListNode* arg_1 = <span class="built_in">vec2list</span>(args_1[i], <span class="number">0</span>, args_1[i].<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// print_list(arg_1);</span></span><br><span class="line">        MyListNode* arg_2 = <span class="built_in">vec2list</span>(args_2[i], <span class="number">0</span>, args_2[i].<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// print_list(arg_2);</span></span><br><span class="line">        MyListNode* ret = <span class="built_in">vec2list</span>(rets[i], <span class="number">0</span>, rets[i].<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// print_list(ret);</span></span><br><span class="line">        <span class="built_in">assert</span>(</span><br><span class="line">            <span class="built_in">is_equal_list</span>(<span class="built_in">add_two_numbers</span>(arg_1, arg_2), ret)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-反转链表"><a href="#1-反转链表" class="headerlink" title="1 反转链表"></a>1 反转链表</h2><p><a href="https://leetcode.com/problems/reverse-linked-list">LeetCode 206. Reverse Linked List</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个链表，将其反转。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>以相邻三个元素 <code>pre</code>、<code>cur</code> 和 <code>nxt</code> 的处理过程为一个周期，在此周期内：</p><ol><li><p>首先将 <code>cur-&gt;next</code> 记录到 <code>nxt</code> 中</p></li><li><p>然后将 <code>cur-&gt;next</code> 置为 <code>pre</code>，完成 <code>cur</code> 位置上的反转</p></li><li><p>最后将 <code>pre</code> 移动至 <code>cur</code> 的位置，将 <code>cur</code> 移动至 <code>nxt</code> 的位置</p></li></ol><p>可以参考这个动图：<a href="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/10/26/01.gif">How to Reverse Linked List</a></p><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>, *cur = head, *nxt = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            nxt = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-排序链表"><a href="#2-排序链表" class="headerlink" title="2 排序链表"></a>2 排序链表</h2><p><a href="https://leetcode.com/problems/sort-list">LeetCode 148. Sort List</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定一个链表，将其升序排序。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用归并排序或快速排序，基本思想与<a href="/posts/1633654398/">数组的排序算法</a>保持一致，只是由于链表的特殊结构，在实现上要做特殊处理。</p><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><p>归并排序：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* slow = head, *fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">sortList</span>(head), <span class="built_in">sortList</span>(fast));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* root = <span class="keyword">new</span> <span class="built_in">ListNode</span>(), *cur = root;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>快速排序：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">quick_sort</span>(head, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(ListNode* left, ListNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right || left-&gt;next == right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = <span class="built_in">partition</span>(left, right);</span><br><span class="line">        <span class="built_in">quick_sort</span>(left, mid);</span><br><span class="line">        <span class="built_in">quick_sort</span>(mid-&gt;next, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* left, ListNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = left-&gt;val;</span><br><span class="line">        ListNode* pre = left, *cur = left-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (cur != right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val &lt; pivot) &#123;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">                <span class="built_in">swap_pointer</span>(pre, cur);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap_pointer</span>(left, pre);</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap_pointer</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = l1-&gt;val;</span><br><span class="line">        l1-&gt;val = l2-&gt;val;</span><br><span class="line">        l2-&gt;val = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;重点解决 LeetCode 中 List 为 Top Interview Questions 且 Tag 为 Linked List 的题目。&lt;/p&gt;</summary>
    
    
    
    <category term="A3 - 技术" scheme="https://progcz.com/categories/A3-%E6%8A%80%E6%9C%AF/"/>
    
    <category term="B1 - 数据结构与算法" scheme="https://progcz.com/categories/A3-%E6%8A%80%E6%9C%AF/B1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="数据结构与算法" scheme="https://progcz.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="Linked List" scheme="https://progcz.com/tags/Linked-List/"/>
    
    <category term="面试" scheme="https://progcz.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试中常见的 C++ 问题汇总</title>
    <link href="https://progcz.com/posts/1634567000/"/>
    <id>https://progcz.com/posts/1634567000/</id>
    <published>2021-10-18T15:07:20.000Z</published>
    <updated>2021-11-03T01:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>以前秋招，整理过一版 C++ 问题汇总，这次社招，重新梳理一遍。</p><span id="more"></span><h2 id="1-语法基础"><a href="#1-语法基础" class="headerlink" title="1 语法基础"></a>1 语法基础</h2><h3 id="C-和-C-有什么区别？"><a href="#C-和-C-有什么区别？" class="headerlink" title="C++ 和 C 有什么区别？"></a>C++ 和 C 有什么区别？</h3><ul><li><p>C++ 是面向对象的语言，而 C 是面向过程的语言</p></li><li><p>C++ 引入类的概念，而 C 中没有</p></li><li><p>C++ 引入引用的概念，而 C 中没有</p></li><li><p>C++ 引入函数重载的特性，而 C 中没有</p></li><li><p>C++ 引入 <code>new/delete</code> 运算符，取代 C 中的 <code>malloc/free</code> 库函数</p></li></ul><h3 id="相比于-C-98，C-11-有哪些新特性？"><a href="#相比于-C-98，C-11-有哪些新特性？" class="headerlink" title="相比于 C++98，C++11 有哪些新特性？"></a>相比于 C++98，C++11 有哪些新特性？</h3><ul><li><p>引入 Lambda 表达式用于创建匿名函数</p></li><li><p>引入自动类型推导 <code>auto</code> 和 <code>decltype</code></p></li><li><p>引入 <code>= default</code> 生成默认构造函数，<code>= delete</code> 禁止使用拷贝构造函数</p></li><li><p>引入 <code>nullptr</code> 关键字，用于解决 <code>NULL</code> 的二义性问题</p></li><li><p>引入范围 <code>for</code> 循环</p></li><li><p>引入列表初始化</p></li><li><p>引入 <code>shared_ptr</code>、<code>unique_ptr</code> 等智能指针</p></li><li><p>引入右值引用，将引用绑定到右值，如临时对象或字面量</p></li><li><p>引入线程库</p></li></ul><h3 id="struct-和-class-有什么区别？"><a href="#struct-和-class-有什么区别？" class="headerlink" title="struct 和 class 有什么区别？"></a><code>struct</code> 和 <code>class</code> 有什么区别？</h3><ul><li><p>成员的默认访问权限：<code>struct</code> 的成员默认为 <code>public</code> 权限，<code>class</code> 的成员默认为 <code>private</code> 权限</p></li><li><p>默认继承权限：<code>struct</code> 的继承按照 <code>public</code> 处理，<code>class</code> 的继承按照 <code>private</code> 处理</p></li></ul><h3 id="对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？"><a href="#对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？" class="headerlink" title="对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？"></a>对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？</h3><p>应该使用 <code>inline</code> 内联函数，即编译器将 <code>inline</code> 内联函数内的代码替换到函数被调用的地方。</p><p>优点：</p><ul><li><p>在内联函数被调用的地方进行代码展开，省去函数调用的时间，从而提高程序运行效率</p></li><li><p>相比于宏函数，内联函数在代码展开时，编译器会进行语法安全检查或数据类型转换，使用更加安全</p></li></ul><p>缺点：</p><ul><li><p>代码膨胀，产生更多的开销</p></li><li><p>如果内联函数内代码块的执行时间比调用时间长得多，那么效率的提升并没有那么大</p></li><li><p>如果修改内联函数，那么所有调用该函数的代码文件都需要重新编译</p></li><li><p>内联声明只是建议，是否内联由编译器决定，所以实际并不可控</p></li></ul><h3 id="define-和-inline-有什么区别？"><a href="#define-和-inline-有什么区别？" class="headerlink" title="#define 和 inline 有什么区别？"></a><code>#define</code> 和 <code>inline</code> 有什么区别？</h3><ul><li><p><code>#define</code> 宏函数在预处理阶段展开，而 <code>inline</code> 内联函数在编译阶段展开</p></li><li><p><code>#define</code> 宏函数不检查参数类型，而 <code>inline</code> 内联函数检查参数类型，使用更加安全</p></li></ul><h3 id="const-关键字有什么作用？"><a href="#const-关键字有什么作用？" class="headerlink" title="const 关键字有什么作用？"></a><code>const</code> 关键字有什么作用？</h3><ul><li><p>修饰变量时，表示该变量的值在其生命周期内只读，不能被改变</p></li><li><p>修饰指针：<code>int * const</code></p></li><li><p>修饰指针所指向的对象：<code>const int *</code></p></li><li><p>修饰引用所绑定的对象：<code>const int &amp;</code></p></li><li><p>修饰函数的引用形参时，可以保护实参不被函数修改</p></li><li><p>修饰非静态成员变量时，不能在类定义处初始化，必须通过构造函数初始化列表进行初始化</p></li><li><p>修饰静态成员变量时，不能在类内部初始化，一般在类外部进行初始化</p></li><li><p>修饰成员函数时，表示该函数不应修改非静态成员，但并不可靠，因为指针所指对象可能会被修改</p></li></ul><h3 id="define-和-const-有什么区别？"><a href="#define-和-const-有什么区别？" class="headerlink" title="#define 和 const 有什么区别？"></a><code>#define</code> 和 <code>const</code> 有什么区别？</h3><ul><li><p>编译器处理方式不同：<code>#define</code> 宏是在预处理阶段展开，不能对宏定义进行调试，而 <code>const</code> 常量是在编译阶段使用</p></li><li><p>类型和安全检查不同：<code>#define</code> 宏没有类型，不做任何类型检查，仅仅是代码展开，可能产生边际效应等错误，而 <code>const</code> 常量有具体类型，在编译阶段会执行类型检查</p></li><li><p>存储方式不同：<code>#define</code> 宏仅仅是代码展开，在多个地方进行字符串替换，不会分配内存，存储于程序的代码段中，而 <code>const</code> 常量会分配内存，但只维持一份拷贝，存储于程序的数据段中</p></li><li><p>定义域不同：<code>#define</code> 宏不受定义域限制，而 <code>const</code> 常量只在定义域内有效</p></li></ul><h3 id="explicit-关键字有什么作用？"><a href="#explicit-关键字有什么作用？" class="headerlink" title="explicit 关键字有什么作用？"></a><code>explicit</code> 关键字有什么作用？</h3><p>可以用单个实参来调用的构造函数都定义了从形参类型到实参类型的隐式转换，这种转换往往都是非预期的，所以使用 <code>explicit</code> 关键字对构造函数进行修饰，从而避免由构造函数定义的隐式转换。</p><h3 id="extern关键字有什么作用？"><a href="#extern关键字有什么作用？" class="headerlink" title="extern关键字有什么作用？"></a><code>extern</code>关键字有什么作用？</h3><ul><li><p>当 <code>extern</code> 修饰变量或函数时，表示变量或函数的定义在其他文件中，提示编译器在其他模块中寻找其定义</p></li><li><p>当 <code>extern C</code> 时，提示编译器在编译函数时按照 C 的规则去翻译相应的函数名，如果按照 C++ 的规则，函数名会被翻译得变得面目全非，因为 C++ 支持函数的重载。</p></li></ul><h3 id="static关键字有什么作用？"><a href="#static关键字有什么作用？" class="headerlink" title="static关键字有什么作用？"></a><code>static</code>关键字有什么作用？</h3><ul><li><p>修饰局部变量时，使得该变量在静态存储区分配内存；只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化；其生命周期与程序相同，但其作用域为局部作用域，并不能一直被访问</p></li><li><p>修饰全局变量时，使得该变量在静态存储区分配内存；在声明该变量的整个文件中都是可见的，而在文件外是不可见的</p></li><li><p>修饰函数时，在声明该函数的整个文件中都是可见的，而在文件外是不可见的，从而可以在多人协作时避免同名的函数冲突</p></li><li><p>修饰成员变量时，所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加 <code>static</code></p></li><li><p>修饰成员函数时，该函数不接受 <code>this</code> 指针，只能访问类的静态成员；不需要实例化对象即可访问</p></li></ul><h3 id="sizeof-和-strlen-之间有什么区别？"><a href="#sizeof-和-strlen-之间有什么区别？" class="headerlink" title="sizeof 和 strlen 之间有什么区别？"></a><code>sizeof</code> 和 <code>strlen</code> 之间有什么区别？</h3><ul><li><p><code>sizeof</code> 属于运算符，不是库函数，其结果在编译时期计算得到，因此不能用来得到动态分配的内存大小，而 <code>strlen</code> 属于库函数，其结果在运行期间计算得到</p></li><li><p><code>sizeof</code> 参数可以是任何数据或数据类型，而 <code>strlen</code> 的参数只能是字符指针，且该指针指向结尾为 <code>\0</code> 的字符串</p></li></ul><h3 id="assert-有什么用处？"><a href="#assert-有什么用处？" class="headerlink" title="assert 有什么用处？"></a><code>assert</code> 有什么用处？</h3><p><code>assert</code> 是一种仅在 debug 版本中使用的宏函数，用于检查不该发生的情况，可以看作是一种在任何系统状态下都可以安全使用的无害测试手段；可以通过 <code>#define NDEBUG</code> 来关闭 <code>assert</code>，放在 <code>&lt;cassert&gt;</code> 头文件之前。</p><h3 id="变量的声明和定义有什么区别？"><a href="#变量的声明和定义有什么区别？" class="headerlink" title="变量的声明和定义有什么区别？"></a>变量的声明和定义有什么区别？</h3><ul><li><p>声明仅仅是把变量类型等信息提供给编译器，并不为其分配内存空间，而定义需要为变量分配内存空间</p></li><li><p>变量可以在多处声明，如外部变量 <code>extern</code>，但只能在一处定义</p></li></ul><h3 id="指针和引用有什么区别？"><a href="#指针和引用有什么区别？" class="headerlink" title="指针和引用有什么区别？"></a>指针和引用有什么区别？</h3><ul><li><p>指针是一种对象，用来存放某个对象的地址，占用内存空间，而引用是一种别名，不占用内存空间</p></li><li><p>指针可以声明为空，之后进行初始化，普通指针可以随时更换所指对象，而引用必须在声明的时候初始化，而且初始化后不可改变</p></li><li><p>指针包含指向常量的指针和常量指针，而引用不包含常量引用，但包含对常量的引用</p></li></ul><h3 id="右值引用有什么作用？"><a href="#右值引用有什么作用？" class="headerlink" title="右值引用有什么作用？"></a>右值引用有什么作用？</h3><p>右值引用的主要目的是为了实现转移语义和完美转发，消除两个对象交互时不必要的对象拷贝，也能够更加简洁明确地定义泛型函数。</p><h3 id="类型转换分为哪几种？各自有什么样的特点？"><a href="#类型转换分为哪几种？各自有什么样的特点？" class="headerlink" title="类型转换分为哪几种？各自有什么样的特点？"></a>类型转换分为哪几种？各自有什么样的特点？</h3><ul><li><p><code>static_cast</code>：用于基本数据类型之间的转换、子类向父类的安全转换、<code>void*</code> 和其他类型指针之间的转换</p></li><li><p><code>const_cast</code>：用于去除 <code>const</code> 或 <code>volatile</code> 属性</p></li><li><p><code>dynamic_cast</code>：用于子类和父类之间的安全转换，可以实现向上向下转换，因为编译器默认向上转换总是安全的，而向下转换时，<code>dynamic_cast</code> 具有类型检查的功能；<code>dynamic_cast</code> 转换失败时，对于指针会返回目标类型的 <code>nullptr</code>，对于引用会返回 <code>bad_cast</code> 异常</p></li><li><p><code>reinterpret_cast</code>：用于不同类型指针之间、不同类型引用之间、指针和能容纳指针的整数类型之间的转换</p></li></ul><h2 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2 内存管理"></a>2 内存管理</h2><h3 id="常用的数据类型各占用多大的内存空间？"><a href="#常用的数据类型各占用多大的内存空间？" class="headerlink" title="常用的数据类型各占用多大的内存空间？"></a>常用的数据类型各占用多大的内存空间？</h3><table><thead><tr><th>数据类型</th><th>32位编译器</th><th>64位编译器</th></tr></thead><tbody><tr><td><strong>bool</strong></td><td><strong>1</strong></td><td>1</td></tr><tr><td><strong>char</strong></td><td><strong>1</strong></td><td>1</td></tr><tr><td><strong>short (int)</strong></td><td><strong>2</strong></td><td>2</td></tr><tr><td><strong>int</strong></td><td><strong>4</strong></td><td>4</td></tr><tr><td><strong>unsigned (int)</strong></td><td><strong>4</strong></td><td>4</td></tr><tr><td><strong>long</strong></td><td><strong>4</strong></td><td><strong>8</strong></td></tr><tr><td><strong>long long</strong></td><td><strong>8</strong></td><td>8</td></tr><tr><td><strong>float</strong></td><td><strong>4</strong></td><td>4</td></tr><tr><td><strong>double</strong></td><td><strong>8</strong></td><td>8</td></tr><tr><td><strong>pointer</strong></td><td><strong>4</strong></td><td><strong>8</strong></td></tr></tbody></table><h3 id="new-delete-和-malloc-free-之间有什么关系？"><a href="#new-delete-和-malloc-free-之间有什么关系？" class="headerlink" title="new/delete 和 malloc/free 之间有什么关系？"></a><code>new/delete</code> 和 <code>malloc/free</code> 之间有什么关系？</h3><ul><li><p>相同点：对于内部数据类型来说，没有构造与析构的过程，所以两者是等价的，都可以用于申请动态内存和释放内存</p></li><li><p>不同点：</p><ul><li><p><code>new/delete</code> 可以调用对象的构造函数和析构函数，属于运算符，在编译器权限之内，而 <code>malloc/free</code> 仅用于内存分配和释放，属于库函数，不在编译器权限之内</p></li><li><p><code>new</code> 是类型安全的，而 <code>malloc</code> 返回的数据类型是 <code>void *</code>，所以要显式地进行类型转换</p></li><li><p><code>new</code> 可以自动计算所需字节数，而 <code>malloc</code> 需要手动计算</p></li><li><p><code>new</code> 申请内存失败时抛出 <code>bad_malloc</code> 异常，而 <code>malloc</code> 返回空指针</p></li></ul></li></ul><h3 id="delete-与-delete-有什么区别？"><a href="#delete-与-delete-有什么区别？" class="headerlink" title="delete 与 delete [] 有什么区别？"></a><code>delete</code> 与 <code>delete []</code> 有什么区别？</h3><ul><li><p>对于简单类型来说：使用 <code>new</code> 分配后，不管是数组数组还是非数组形式，两种方式都可以释放内存</p></li><li><p>对于自定义类型来说：需要对于单个对象使用 <code>delete</code>，对于对象数组使用 <code>delete []</code>，逐个调用数组中对象的析构函数，从而释放所有内存；如果反过来使用，即对于单个对象使用 <code>delete []</code>，对于对象数组使用 <code>delete</code>，其行为是未定义的</p></li></ul><p>所以，最恰当的方式就是如果用了 <code>new</code>，就用 <code>delete</code>；如果用了 <code>new []</code>，就用 <code>delete []</code>。</p><h3 id="内存泄漏的场景有哪些？"><a href="#内存泄漏的场景有哪些？" class="headerlink" title="内存泄漏的场景有哪些？"></a>内存泄漏的场景有哪些？</h3><ul><li><p><code>malloc</code> 和 <code>free</code> 未成对出现，或 <code>new/new []</code> 和 <code>delete/delete []</code> 未成对出现</p><ul><li><p>在堆中创建对象分配内存，但未显式释放内存；比如，通过局部分配的内存，未在调用者函数体内释放：</p>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="built_in">getMemory</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在构造函数中动态分配内存，但未在析构函数中正确释放内存</p></li></ul></li><li><p>未定义拷贝构造函数或未重载赋值运算符，从而造成两次释放相同内存的做法；比如，类中包含指针成员变量，在未定义拷贝构造函数或未重载赋值运算符的情况下，编译器会调用默认的拷贝构造函数或赋值运算符，以逐个成员拷贝的方式来复制指针成员变量，使得两个对象包含指向同一内存空间的指针，那么在释放第一个对象时，析构函数释放该指针指向的内存空间，在释放第二个对象时，析构函数就会释放同一内存空间，这样的行为是错误的</p></li><li><p>没有将基类的析构函数定义为虚函数</p></li></ul><h3 id="内存的分配方式有几种？"><a href="#内存的分配方式有几种？" class="headerlink" title="内存的分配方式有几种？"></a>内存的分配方式有几种？</h3><ul><li><p>在栈上分配：在执行函数时，局部变量的内存都可以在栈上分配，函数结束时会自动释放；栈内存的分配运算内置于处理器的指令集中，效率很高，但分配的内存容量有限</p></li><li><p>从堆上分配：由 <code>new</code> 分配和 <code>delete</code> 释放的内存块，也称为动态内存分配，使用者自行申请和释放内存，使用灵活</p></li><li><p>从自由存储区分配：由 <code>malloc</code> 分配和 <code>free</code> 释放的内存块，与堆类似</p></li><li><p>从常量存储区分配：特殊的存储区，存放的是常量，不可修改</p></li><li><p>从全局/静态存储区分配：编译期间分配内存，整个程序运行期间都存在，如全局变量、静态变量等</p></li></ul><h3 id="堆和栈有什么区别？"><a href="#堆和栈有什么区别？" class="headerlink" title="堆和栈有什么区别？"></a>堆和栈有什么区别？</h3><ul><li><p>分配和管理方式不同：</p><ul><li><p>堆是动态分配的，其空间的分配和释放都由使用者控制</p></li><li><p>栈是由编译器自动管理的，其分配方式有两种：</p><ol><li><p>静态分配由编译器完成，比如局部变量的分配</p></li><li><p>动态分配由 <code>alloca()</code> 函数进行分配，但是会由编译器释放</p></li></ol></li></ul></li><li><p>产生碎片不同：</p><ul><li><p>对堆来说，频繁使用 <code>new/delete</code> 或者 <code>malloc/free</code> 会造成内存空间的不连续，产生大量碎片，是程序效率降低</p></li><li><p>对栈来说，不存在碎片问题，因为栈具有先进后出的特性</p></li></ul></li><li><p>生长方向不同：</p><ul><li><p>堆是向着内存地址增加的方向增长的，从内存的低地址向高地址方向增长</p></li><li><p>栈是向着内存地址减小的方向增长的，从内存的高地址向低地址方向增长</p></li></ul></li><li><p>申请大小限制不同：</p><ul><li><p>栈顶和栈底是预设好的，大小固定</p></li><li><p>堆是不连续的内存区域，其大小可以灵活调整</p></li></ul></li></ul><h3 id="静态内存分配和动态内存分配有什么区别？"><a href="#静态内存分配和动态内存分配有什么区别？" class="headerlink" title="静态内存分配和动态内存分配有什么区别？"></a>静态内存分配和动态内存分配有什么区别？</h3><ul><li><p>静态内存分配是在编译时期完成的，不占用 CPU 资源；动态内存分配是在运行时期完成的，分配和释放需要占用 CPU 资源</p></li><li><p>静态内存分配是在栈上分配的；动态内存分配是在堆上分配的</p></li><li><p>静态内存分配不需要指针或引用类型的支持；动态内存分配需要</p></li><li><p>静态内存分配是按计划分配的，在编译前确定内存块的大小；动态内存分配是按需要分配的</p></li><li><p>静态内存分配是把内存的控制权交给了编译器；动态内存分配是把内存的控制权给了使用者</p></li><li><p>静态内存分配的运行效率比动态内存分配高，动态内存分配不当可能造成内存泄漏</p></li></ul><h3 id="如何构造一个类，使得只能在堆上或只能在栈上分配内存？"><a href="#如何构造一个类，使得只能在堆上或只能在栈上分配内存？" class="headerlink" title="如何构造一个类，使得只能在堆上或只能在栈上分配内存？"></a>如何构造一个类，使得只能在堆上或只能在栈上分配内存？</h3><ul><li><p>只能在堆上分配内存：将析构函数声明为 <code>private</code></p></li><li><p>只能在栈上生成对象：将 <code>new</code> 和 <code>delete</code> 重载为 <code>private</code></p></li></ul><h3 id="浅拷贝和深拷贝有什么区别？"><a href="#浅拷贝和深拷贝有什么区别？" class="headerlink" title="浅拷贝和深拷贝有什么区别？"></a>浅拷贝和深拷贝有什么区别？</h3><ul><li><p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享一块内存</p></li><li><p>深拷贝会创造一个相同的对象，新对象与原对象不共享内存，修改新对象不会影响原对象</p></li></ul><h3 id="什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？"><a href="#什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？" class="headerlink" title="什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？"></a>什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？</h3><p>智能指针是一个 RAII 类模型，用于动态分配内存，其设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用 <code>delete</code> 删除指针所指向的内存空间。</p><p>智能指针的作用是，能够处理内存泄漏问题和空悬指针问题。</p><p>智能指针分为 <code>auto_ptr</code>、<code>unique_ptr</code>、<code>shared_ptr</code> 和 <code>weak_ptr</code> 四种，各自的特点：</p><ul><li><p>对于 <code>auto_ptr</code>，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象；但 <code>auto_ptr</code> 在 C++11 中被摒弃，其主要问题在于：</p><ul><li><p>对象所有权的转移，比如在函数传参过程中，对象所有权不会返还，从而存在潜在的内存崩溃问题</p></li><li><p>不能指向数组，也不能作为 STL 容器的成员</p></li></ul></li><li><p>对于 <code>unique_ptr</code>，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象，因为无法进行拷贝构造和拷贝赋值，但是可以进行移动构造和移动赋值</p></li><li><p>对于 <code>shared_ptr</code>，实现共享式拥有的概念，即多个智能指针可以指向相同的对象，该对象及相关资源会在其所指对象不再使用之后，自动释放与对象相关的资源</p></li><li><p>对于 <code>weak_ptr</code>，解决 <code>shared_ptr</code> 相互引用时，两个指针的引用计数永远不会下降为 0，从而导致死锁问题，因为 <code>weak_ptr</code> 是对对象的一种弱引用，可以绑定到 <code>shared_ptr</code>，但不会增加对象的引用计数</p></li></ul><h3 id="shared-ptr-是如何实现的？"><a href="#shared-ptr-是如何实现的？" class="headerlink" title="shared_ptr 是如何实现的？"></a><code>shared_ptr</code> 是如何实现的？</h3><ol><li><p>构造函数中计数初始化为 1</p></li><li><p>拷贝构造函数中计数值加 1</p></li><li><p>赋值运算符中，左边的对象引用计数减 1，右边的对象引用计数加 1</p></li><li><p>析构函数中引用计数减 1</p></li><li><p>在赋值运算符和析构函数中，如果减 1 后为 0，则调用 <code>delete</code> 释放对象</p></li></ol><h2 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3 面向对象"></a>3 面向对象</h2><h3 id="面向对象的三大特征是哪些？各自有什么样的特点？"><a href="#面向对象的三大特征是哪些？各自有什么样的特点？" class="headerlink" title="面向对象的三大特征是哪些？各自有什么样的特点？"></a>面向对象的三大特征是哪些？各自有什么样的特点？</h3><ul><li><p>封装：将客观事物封装成抽象的类，而类可以把自己的数据和方法暴露给可信的类或者对象，对不可信的类或对象则进行信息隐藏</p></li><li><p>继承：可以使用现有类的所有功能，并且无需重新编写原来的类即可对功能进行拓展</p></li><li><p>多态：一个类实例的相同方法在不同情形下有不同的表现形式，使不同内部结构的对象可以共享相同的外部接口</p></li></ul><h3 id="多态的实现有哪几种？"><a href="#多态的实现有哪几种？" class="headerlink" title="多态的实现有哪几种？"></a>多态的实现有哪几种？</h3><p>多态分为静态多态和动态多态：</p><ul><li><p>静态多态是通过重载和模板技术实现的，在编译期间确定</p></li><li><p>动态多态是通过虚函数和继承关系实现的，执行动态绑定，在运行期间确定</p></li></ul><h3 id="动态多态有什么作用？有哪些必要条件？"><a href="#动态多态有什么作用？有哪些必要条件？" class="headerlink" title="动态多态有什么作用？有哪些必要条件？"></a>动态多态有什么作用？有哪些必要条件？</h3><p>动态多态的作用：</p><ul><li><p>隐藏实现细节，使代码模块化，提高代码的可复用性</p></li><li><p>接口重用，使派生类的功能可以被基类的指针/引用所调用，即向后兼容，提高代码的可扩充性和可维护性</p></li></ul><p>动态多态的必要条件：</p><ul><li><p>需要有继承</p></li><li><p>需要有虚函数覆盖</p></li><li><p>需要有基类指针/引用指向子类对象</p></li></ul><h3 id="动态绑定是如何实现的？"><a href="#动态绑定是如何实现的？" class="headerlink" title="动态绑定是如何实现的？"></a>动态绑定是如何实现的？</h3><p>当编译器发现类中有虚函数时，会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在对象中增加一个指针 <code>vptr</code>，用于指向类的虚函数表。当派生类覆盖基类的虚函数时，会将虚函数表中对应的指针进行替换，从而调用派生类中覆盖后的虚函数，从而实现动态绑定。</p><h3 id="虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？"><a href="#虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？" class="headerlink" title="虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？"></a>虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？</h3><p>虚函数表是针对类的，类的所有对象共享这个类的虚函数表，每个对象内部都保存一个指向该类虚函数表的指针 <code>vptr</code>，每个对象的 <code>vptr</code> 的存放地址都不同，但都指向同一虚函数表。</p><h3 id="为什么基类的构造函数不能定义为虚函数？"><a href="#为什么基类的构造函数不能定义为虚函数？" class="headerlink" title="为什么基类的构造函数不能定义为虚函数？"></a>为什么基类的构造函数不能定义为虚函数？</h3><p>虚函数的调用依赖于虚函数表，而指向虚函数表的指针 <code>vptr</code> 需要在构造函数中进行初始化，所以无法调用定义为虚函数的构造函数。</p><h3 id="为什么基类的析构函数需要定义为虚函数？"><a href="#为什么基类的析构函数需要定义为虚函数？" class="headerlink" title="为什么基类的析构函数需要定义为虚函数？"></a>为什么基类的析构函数需要定义为虚函数？</h3><p>为了实现动态绑定，基类指针指向派生类对象，如果析构函数不是虚函数，那么在对象销毁时，就会调用基类的析构函数，只能销毁派生类对象中的部分数据，所以必须将析构函数定义为虚函数，从而在对象销毁时，调用派生类的析构函数，从而销毁派生类对象中的所有数据。</p><h3 id="构造函数和析构函数能抛出异常吗？"><a href="#构造函数和析构函数能抛出异常吗？" class="headerlink" title="构造函数和析构函数能抛出异常吗？"></a>构造函数和析构函数能抛出异常吗？</h3><ul><li><p>从语法的角度来说，构造函数可以抛出异常，但从逻辑和风险控制的角度来说，尽量不要抛出异常，否则可能导致内存泄漏</p></li><li><p>析构函数不可以抛出异常，如果析构函数抛出异常，则异常点之后的程序，比如释放内存等操作，就不会被执行，从而造成内存泄露的问题；而且当异常发生时，C++ 通常会调用对象的析构函数来释放资源，如果此时析构函数也抛出异常，即前一个异常未处理又出现了新的异常，从而造成程序崩溃的问题</p></li></ul><h3 id="纯虚函数有什么作用？如何实现？"><a href="#纯虚函数有什么作用？如何实现？" class="headerlink" title="纯虚函数有什么作用？如何实现？"></a>纯虚函数有什么作用？如何实现？</h3><p>作用是实现一个接口，起到规范的作用，想要继承这个类就必须覆盖该函数。</p><p>实现方式是在虚函数声明的结尾加上 <code>= 0</code> 即可。</p><h3 id="如何让一个类不能实例化？"><a href="#如何让一个类不能实例化？" class="headerlink" title="如何让一个类不能实例化？"></a>如何让一个类不能实例化？</h3><p>将类定义为抽象类（也就是存在纯虚函数）或者将构造函数声明为 <code>private</code>。</p><h3 id="public-成员、protected-成员、private-成员有什么区别？"><a href="#public-成员、protected-成员、private-成员有什么区别？" class="headerlink" title="public 成员、protected 成员、private 成员有什么区别？"></a><code>public</code> 成员、<code>protected</code> 成员、<code>private</code> 成员有什么区别？</h3><ul><li><p><code>public</code> 成员可以被本类及本类对象、友元类及友元类对象、子类及子类对象访问</p></li><li><p><code>protected</code> 成员可以被本类、友元类、子类访问，不能被任何对象访问</p></li><li><p><code>private</code> 成员只可以被本类访问</p></li></ul><h3 id="public-继承、protected-继承、private-继承有什么区别？"><a href="#public-继承、protected-继承、private-继承有什么区别？" class="headerlink" title="public 继承、protected 继承、private 继承有什么区别？"></a><code>public</code> 继承、<code>protected</code> 继承、<code>private</code> 继承有什么区别？</h3><p>不管哪类继承，子类都可以访问父类的 <code>public</code> 成员、<code>protected</code> 成员，但是继承之后，成员属性会发生变化：</p><table><thead><tr><th>父类成员</th><th><code>public</code> 继承后子类成员</th><th><code>protected</code> 继承后子类成员</th><th><code>private</code> 继承后子类成员</th></tr></thead><tbody><tr><td><code>public</code></td><td><code>public</code></td><td><code>protected</code></td><td><code>private</code></td></tr><tr><td><code>protected</code></td><td><code>protected</code></td><td><code>protected</code></td><td><code>private</code></td></tr><tr><td><code>private</code></td><td>无法继承</td><td>无法继承</td><td>无法继承</td></tr></tbody></table><h3 id="多继承存在什么问题？如何消除多继承中的二义性？"><a href="#多继承存在什么问题？如何消除多继承中的二义性？" class="headerlink" title="多继承存在什么问题？如何消除多继承中的二义性？"></a>多继承存在什么问题？如何消除多继承中的二义性？</h3><ul><li><p>增加程序的复杂度，使得程序的编写和维护比较困难，容易出错</p></li><li><p>在继承时，基类之间或基类与派生类之间发生成员同名时，将出现对成员访问的不确定性，即同名二义性；消除同名二义性的方法：</p><ul><li><p>利用作用域运算符 <code>::</code>，用于限定派生类使用的是哪个基类的成员</p></li><li><p>在派生类中定义同名成员，覆盖基类中的相关成员</p></li></ul></li><li><p>当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类的成员时，将产生另一种不确定性，即路径二义性；消除路径二义性的方法：</p><ul><li><p>消除同名二义性的两种方法都可以</p></li><li><p>使用虚继承，使得不同路径继承来的同名成员在内存中只有一份拷贝</p></li></ul></li></ul><h2 id="4-程序编译"><a href="#4-程序编译" class="headerlink" title="4 程序编译"></a>4 程序编译</h2><h3 id="程序编译的顺序是什么？"><a href="#程序编译的顺序是什么？" class="headerlink" title="程序编译的顺序是什么？"></a>程序编译的顺序是什么？</h3><ol><li><p>预处理：源代码经过预处理器，生成一个 <code>.i</code> 中间文件，这个阶段会把 <code>#include</code> 的头文件内容进行替换，并处理宏定义</p></li><li><p>编译：<code>.i</code> 中间文件生成 <code>.s</code> 汇编文件</p></li><li><p>汇编：<code>.s</code> 汇编文件经过汇编器生成 <code>.obj</code> 目标文件</p></li><li><p>链接：<code>.obj</code> 目标文件经过链接器，与 <code>lib</code> 静态链接库和 <code>dll</code> 动态链接库生成可执行文件</p></li></ol><h3 id="静态链接和动态链接有什么区别？"><a href="#静态链接和动态链接有什么区别？" class="headerlink" title="静态链接和动态链接有什么区别？"></a>静态链接和动态链接有什么区别？</h3><ul><li><p>静态链接是在编译链接时直接将需要的执行代码拷贝到调用处</p><ul><li><p>优点在于程序在发布时不需要依赖库，可以独立执行</p></li><li><p>缺点在于程序的体积会相对较大，而且如果静态库更新之后，所有可执行文件需要重新链接</p></li></ul></li><li><p>动态链接是在编译时不直接拷贝执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定代码时，在共享执行内存中寻找已经加载的动态库可执行代码，实现运行时链接</p><ul><li><p>优点在于多个程序可以共享同一个动态库，节省资源</p></li><li><p>缺点在于由于运行时加载，可能影响程序的前期执行性能</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前秋招，整理过一版 C++ 问题汇总，这次社招，重新梳理一遍。&lt;/p&gt;</summary>
    
    
    
    <category term="A3 - 技术" scheme="https://progcz.com/categories/A3-%E6%8A%80%E6%9C%AF/"/>
    
    <category term="B2 - 编程语言" scheme="https://progcz.com/categories/A3-%E6%8A%80%E6%9C%AF/B2-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C1 - CPP" scheme="https://progcz.com/categories/A3-%E6%8A%80%E6%9C%AF/B2-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C1-CPP/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="面试" scheme="https://progcz.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法的 C++ 实现、复杂度和稳定性分析</title>
    <link href="https://progcz.com/posts/1633654398/"/>
    <id>https://progcz.com/posts/1633654398/</id>
    <published>2021-10-08T00:55:03.000Z</published>
    <updated>2021-10-15T10:12:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>以下是在 LeetCode Playground 完成的 C++ 实现及测试用例：</p><ul><li><a href="https://leetcode.com/playground/gZfypPAn">https://leetcode.com/playground/gZfypPAn</a></li></ul><p>以下是来自<a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">菜鸟教程</a>的表格，给出了时间复杂度、空间复杂度和稳定性分析：</p><table><thead><tr><th align="center">算法</th><th align="center">时间复杂度 - 平均</th><th align="center">时间复杂度 - 最好</th><th align="center">时间复杂度 - 最坏</th><th align="center">空间复杂度</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center"><strong>冒泡排序</strong></td><td align="center"><code>O(n^2)</code></td><td align="center"><code>O(n)</code></td><td align="center"><code>O(n^2)</code></td><td align="center"><code>O(1)</code></td><td align="center">稳定</td></tr><tr><td align="center"><strong>插入排序</strong></td><td align="center"><code>O(n^2)</code></td><td align="center"><code>O(n)</code></td><td align="center"><code>O(n^2)</code></td><td align="center"><code>O(1)</code></td><td align="center">稳定</td></tr><tr><td align="center"><strong>选择排序</strong></td><td align="center"><code>O(n^2)</code></td><td align="center"><code>O(n^2)</code></td><td align="center"><code>O(n^2)</code></td><td align="center"><code>O(1)</code></td><td align="center">不稳定</td></tr><tr><td align="center"><strong>归并排序</strong></td><td align="center"><code>O(nlogn)</code></td><td align="center"><code>O(nlogn)</code></td><td align="center"><code>O(nlogn)</code></td><td align="center"><code>O(n)</code></td><td align="center">稳定</td></tr><tr><td align="center"><strong>快速排序</strong></td><td align="center"><code>O(nlogn)</code></td><td align="center"><code>O(nlogn)</code></td><td align="center"><code>O(n^2)</code></td><td align="center"><code>O(logn)</code></td><td align="center">不稳定</td></tr><tr><td align="center"><strong>计数排序</strong></td><td align="center"><code>O(n+k)</code></td><td align="center"><code>O(n+k)</code></td><td align="center"><code>O(n+k)</code></td><td align="center"><code>O(k)</code></td><td align="center">稳定</td></tr></tbody></table><span id="more"></span><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1 冒泡排序"></a>1 冒泡排序</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>遍历数组 <code>nums</code>，对于遍历到的元素 <code>nums[i]</code>，如果 <code>nums[i] &gt; nums[i+1]</code>，那么交换 <code>nums[i]</code> 和 <code>nums[i+1]</code>，这样一轮下来，最后一位必然是 <code>nums</code> 中最大的数字，在下一轮遍历中可以避开这一元素。不断重复这一过程，直到无可遍历元素为止。</p><p>可以参考来自<a href="https://www.runoob.com/w3cnote/bubble-sort.html">菜鸟教程</a>的动图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/10/15/01.gif"></p><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">bool</span> has_swap = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(nums[j], nums[j+<span class="number">1</span>]);</span><br><span class="line">                has_swap = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!has_swap) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info"><p>这里的实现，是在冒泡排序的基础实现之上，加了「早停」的思想，即：在一轮冒泡之后，如果没有发生交换，那么说明数组已经有序，直接退出即可。</p><p>这也是为什么，冒泡排序的时间复杂度在最好的情况下是 <code>O(n)</code>，因为最好的情况就是数组已经有序，只需遍历一次即可。</p></div><h2 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2 插入排序"></a>2 插入排序</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>遍历数组 <code>nums</code>，对于遍历到的元素 <code>nums[i]</code>，嵌套遍历并后移其前的元素，直到找到比 <code>nums[i]</code> 小的元素，将 <code>nums[i]</code> 插入其后即可。</p><p>可以参考来自<a href="https://www.runoob.com/w3cnote/insertion-sort.html">菜鸟教程</a>的动图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/10/15/02.gif"></p><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = nums[i], j = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; val; --j) &#123;</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+<span class="number">1</span>] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3 选择排序"></a>3 选择排序</h2><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><p>遍历数组 <code>nums</code>，对于遍历到的元素 <code>nums[i]</code>，嵌套遍历其后的所有元素，找出其中的最小值 <code>nums[min_num_idx]</code>，将 <code>nums[i]</code> 与 <code>nums[min_num_idx]</code> 进行交换即可。</p><p>可以参考来自<a href="https://www.runoob.com/w3cnote/selection-sort.html">菜鸟教程</a>的动图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/10/15/03.gif"></p><h3 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> min_num_idx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[min_num_idx]) &#123;</span><br><span class="line">                min_num_idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::<span class="built_in">swap</span>(nums[i], nums[min_num_idx]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4 归并排序"></a>4 归并排序</h2><h3 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h3><p>将数组 <code>nums</code> 拆分为左右两个子数组，不断向下递归，直到无法拆分为止。拷贝左右两个子数组，使用两个指针不断比较，较小者放入原数组中，自此向上递归。</p><p>可以参考来自<a href="https://www.runoob.com/w3cnote/merge-sort.html">菜鸟教程</a>的动图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/10/15/04.gif"></p><h3 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><p>递归版本：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive_core</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beg &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">merge_sort_recursive_core</span>(nums, beg, mid);</span><br><span class="line">    <span class="built_in">merge_sort_recursive_core</span>(nums, mid+<span class="number">1</span>, end);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">left_sub_arr</span><span class="params">(nums.begin()+beg, nums.begin()+mid+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">right_sub_arr</span><span class="params">(nums.begin()+mid+<span class="number">1</span>, nums.begin()+end+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = beg, left_idx = <span class="number">0</span>, right_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left_idx &lt;= mid-beg &amp;&amp; right_idx &lt;= end-mid<span class="number">-1</span>) &#123;</span><br><span class="line">        nums[i++] = left_sub_arr[left_idx] &lt; right_sub_arr[right_idx] ?</span><br><span class="line">            left_sub_arr[left_idx++] : right_sub_arr[right_idx++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (left_idx &lt;= mid-beg) &#123;</span><br><span class="line">        nums[i++] = left_sub_arr[left_idx++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (right_idx &lt;= end-mid<span class="number">-1</span>) &#123;</span><br><span class="line">        nums[i++] = right_sub_arr[right_idx++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">merge_sort_recursive_core</span>(nums, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环版本：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_loop</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> seg = <span class="number">1</span>; seg &lt; n; seg *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> beg = <span class="number">0</span>; beg &lt; n; beg += seg*<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = <span class="built_in">min</span>(n<span class="number">-1</span>, beg+seg<span class="number">-1</span>), end = <span class="built_in">min</span>(n<span class="number">-1</span>, beg+seg*<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">            <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">left_sub_arr</span><span class="params">(nums.begin()+beg, nums.begin()+mid+<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">right_sub_arr</span><span class="params">(nums.begin()+mid+<span class="number">1</span>, nums.begin()+end+<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">int</span> i = beg, left_idx = <span class="number">0</span>, right_idx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (left_idx &lt;= mid-beg &amp;&amp; right_idx &lt;= end-mid<span class="number">-1</span>) &#123;</span><br><span class="line">                nums[i++] = left_sub_arr[left_idx] &lt; right_sub_arr[right_idx] ? left_sub_arr[left_idx++] : right_sub_arr[right_idx++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left_idx &lt;= mid-beg) &#123;</span><br><span class="line">                nums[i++] = left_sub_arr[left_idx++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (right_idx &lt;= end-mid<span class="number">-1</span>) &#123;</span><br><span class="line">                nums[i++] = right_sub_arr[right_idx++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5 快速排序"></a>5 快速排序</h2><h3 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h3><p>在数组 <code>nums</code> 中，挑选出一个基准数字 <code>pivot</code>，一般为数组头部的数字。使用两个指针 <code>beg</code> 和 <code>end</code> 分别从数组头部和尾部遍历，<code>nums[end]</code> 比 <code>pivot</code> 小者挪至 <code>beg</code> 处，<code>nums[beg]</code> 比 <code>pivot</code> 大者挪至 <code>end</code> 处，从而保证在 <code>beg</code> 和 <code>end</code> 相遇时，相遇位置左侧的所有元素均小于 <code>pivot</code>，相遇位置右侧的所有元素均大于 <code>pivot</code>。之后递归地处理左右两个子数组即可。</p><p>可以参考来自<a href="https://www.runoob.com/w3cnote/quick-sort-2.html">菜鸟教程</a>的动图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/10/15/05.gif"></p><h3 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><p>递归版本：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partition_recursive</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beg &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[beg], <span class="keyword">beg_t</span> = beg, <span class="keyword">end_t</span> = end;</span><br><span class="line">    <span class="keyword">while</span> (beg &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (beg &lt; end &amp;&amp; nums[end] &gt; pivot) --end;</span><br><span class="line">        nums[beg] = nums[end];</span><br><span class="line">        <span class="keyword">while</span> (beg &lt; end &amp;&amp; nums[beg] &lt;= pivot) ++beg;</span><br><span class="line">        nums[end] = nums[beg];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[beg] = pivot;</span><br><span class="line">    <span class="built_in">partition_recursive</span>(nums, <span class="keyword">beg_t</span>, beg<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">partition_recursive</span>(nums, beg+<span class="number">1</span>, <span class="keyword">end_t</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort_recursive</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">partition_recursive</span>(nums, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环版本：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition_loop</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beg &gt;= end) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[beg], <span class="keyword">beg_t</span> = beg, <span class="keyword">end_t</span> = end;</span><br><span class="line">    <span class="keyword">while</span> (beg &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (beg &lt; end &amp;&amp; nums[end] &gt; pivot) --end;</span><br><span class="line">        nums[beg] = nums[end];</span><br><span class="line">        <span class="keyword">while</span> (beg &lt; end &amp;&amp; nums[beg] &lt;= pivot) ++beg;</span><br><span class="line">        nums[end] = nums[beg];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[beg] = pivot;</span><br><span class="line">    <span class="keyword">return</span> beg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort_loop</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    std::stack&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(&#123;<span class="number">0</span>, n<span class="number">-1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [beg, end] = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="built_in">partition_loop</span>(nums, beg, end);</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        s.<span class="built_in">push</span>(&#123;beg, idx<span class="number">-1</span>&#125;);</span><br><span class="line">        s.<span class="built_in">push</span>(&#123;idx+<span class="number">1</span>, end&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-计数排序"><a href="#6-计数排序" class="headerlink" title="6 计数排序"></a>6 计数排序</h2><h3 id="基本思想-5"><a href="#基本思想-5" class="headerlink" title="基本思想"></a>基本思想</h3><p>计数排序适用于：数据的范围不大，方差不大，且均为离散值。</p><p>在数组 <code>nums</code> 中，找到最小值 <code>min_num</code> 和最大值 <code>max_num</code>，就可以得到 <code>nums</code> 中数字的范围，将这个范围表示为计数数组 <code>cnts</code>，将 <code>nums</code> 中数字在对应索引处进行计数，最后将 <code>cnts</code> 中的数字依次填回 <code>nums</code> 即可。</p><p>可以参考来自<a href="https://www.runoob.com/w3cnote/counting-sort.html">菜鸟教程</a>的动图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/10/15/06.gif"></p><h3 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counting_sort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> min_num = INT_MAX, max_num = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">        min_num = <span class="built_in">min</span>(min_num, num);</span><br><span class="line">        max_num = <span class="built_in">max</span>(max_num, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnts</span><span class="params">(max_num-min_num+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">        ++cnts[num-min_num];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_num-min_num+<span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = cnts[i]; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">            nums[idx++] = min_num + i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;以下是在 LeetCode Playground 完成的 C++ 实现及测试用例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode.com/playground/gZfypPAn&quot;&gt;https://leetcode.com/playground/gZfypPAn&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是来自&lt;a href=&quot;https://www.runoob.com/w3cnote/ten-sorting-algorithm.html&quot;&gt;菜鸟教程&lt;/a&gt;的表格，给出了时间复杂度、空间复杂度和稳定性分析：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;算法&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;时间复杂度 - 平均&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;时间复杂度 - 最好&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;时间复杂度 - 最坏&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;空间复杂度&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;稳定性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;冒泡排序&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n^2)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n^2)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(1)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;插入排序&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n^2)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n^2)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(1)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;选择排序&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n^2)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n^2)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n^2)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(1)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;不稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;归并排序&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(nlogn)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(nlogn)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(nlogn)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;快速排序&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(nlogn)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(nlogn)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n^2)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(logn)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;不稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;计数排序&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n+k)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n+k)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(n+k)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;O(k)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="A3 - 技术" scheme="https://progcz.com/categories/A3-%E6%8A%80%E6%9C%AF/"/>
    
    <category term="B1 - 数据结构与算法" scheme="https://progcz.com/categories/A3-%E6%8A%80%E6%9C%AF/B1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="数据结构与算法" scheme="https://progcz.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="Sort" scheme="https://progcz.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>2021 August LeetCoding Challenge - Week 3</title>
    <link href="https://progcz.com/posts/1629077320/"/>
    <id>https://progcz.com/posts/1629077320/</id>
    <published>2021-08-16T01:29:05.000Z</published>
    <updated>2021-08-21T07:12:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 八月挑战专题，第三周，每日随缘更新。</p><span id="more"></span><h2 id="August-15th-Minimum-Window-Substring"><a href="#August-15th-Minimum-Window-Substring" class="headerlink" title="August 15th: Minimum Window Substring"></a>August 15th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/615/week-3-august-15th-august-21st/3891/">Minimum Window Substring</a></h2><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定字符串 <code>s</code> 和 <code>t</code>，返回 <code>s</code> 中的最短子串，使得该子串包含 <code>t</code> 中的所有字符，如果不存在，那么返回 <code>&quot;&quot;</code>。题目保证答案唯一。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><blockquote><p>参考：<a href="https://www.cnblogs.com/grandyang/p/4340948.html">[LeetCode] 76. Minimum Window Substring 最小窗口子串 - 刷尽天下</a></p></blockquote><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(1)</code></p></li><li><p>时间：<code>O(m*n)</code>，不确定</p></li></ul><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">letterCnt</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, cnt = <span class="number">0</span>, minLeft = <span class="number">-1</span>, minLen = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t) ++letterCnt[c];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--letterCnt[s[i]] &gt;= <span class="number">0</span>) ++cnt;</span><br><span class="line">            <span class="keyword">while</span> (cnt == t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minLen &gt; i - left + <span class="number">1</span>) &#123;</span><br><span class="line">                    minLen = i - left + <span class="number">1</span>;</span><br><span class="line">                    minLeft = left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (++letterCnt[s[left]] &gt; <span class="number">0</span>) --cnt;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLeft == <span class="number">-1</span> ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(minLeft, minLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-16th-Range-Sum-Query-Immutable"><a href="#August-16th-Range-Sum-Query-Immutable" class="headerlink" title="August 16th: Range Sum Query - Immutable"></a>August 16th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/615/week-3-august-15th-august-21st/3892/">Range Sum Query - Immutable</a></h2><h3 id="大意-1"><a href="#大意-1" class="headerlink" title="大意"></a>大意</h3><p>给定数组 <code>nums</code>、多组索引 <code>left</code> 和 <code>right</code>，返回 <code>left</code> 和 <code>right</code> 之间（包含两端）数字的和。</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>遍历 <code>nums</code>，记录当前数字 <code>num</code>，以及从索引 <code>0</code> 和当前索引之间（包含两端）数字的和 <code>sum</code>。</p><p>在进行计算的时候，索引 <code>left</code> 和 <code>right</code> 记录的值相减，加上 <code>left</code> 所在数字即可。</p><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(n)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; sums;</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            sums.<span class="built_in">emplace_back</span>(num, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[right].second - sums[left].second + sums[left].first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray* obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;sumRange(left,right);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="August-17th-Count-Good-Nodes-in-Binary-Tree"><a href="#August-17th-Count-Good-Nodes-in-Binary-Tree" class="headerlink" title="August 17th: Count Good Nodes in Binary Tree"></a>August 17th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/615/week-3-august-15th-august-21st/3899/">Count Good Nodes in Binary Tree</a></h2><h3 id="大意-2"><a href="#大意-2" class="headerlink" title="大意"></a>大意</h3><p>给定二叉树，其根节点为 <code>root</code>。对于某个节点 <code>node</code>，如果从 <code>root</code> 到 <code>node</code> 的路径上，没有比 <code>node</code> 值更大的节点，那么 <code>node</code> 为好节点。返回该树中好节点的数量。</p><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>在 DFS 的过程中，维护当前路径下的最大值 <code>max_num</code> 即可。</p><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(1)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">goodNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, max_num = INT_MIN;</span><br><span class="line">        <span class="built_in">dfs</span>(root, cnt, max_num);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="keyword">int</span>&amp; cnt, <span class="keyword">int</span> max_num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;val &gt;= max_num) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            max_num = node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;left, cnt, max_num);</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;right, cnt, max_num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-18th-Decode-Ways"><a href="#August-18th-Decode-Ways" class="headerlink" title="August 18th: Decode Ways"></a>August 18th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/615/week-3-august-15th-august-21st/3902/">Decode Ways</a></h2><h3 id="大意-3"><a href="#大意-3" class="headerlink" title="大意"></a>大意</h3><p>给定字符均为数字的字符串，按照以下解码规则：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#x27;A&#x27; &lt;- &quot;1&quot;</span><br><span class="line">&#x27;B&#x27; &lt;- &quot;2&quot;</span><br><span class="line">...</span><br><span class="line">&#x27;Z&#x27; &lt;- &quot;26&quot;</span><br></pre></td></tr></table></figure><p>可以对字符串进行解码。然而，同一字符串，根据不同数字的组合方式，可能有不同的解码字符串，比如 <code>11106</code> 可以对应 <code>AAJF</code> 或 <code>KJF</code>。要求返回可能的解码字符串的数量。</p><h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><blockquote><p>参考：<a href="https://www.cnblogs.com/grandyang/p/4313384.html">[LeetCode] 91. Decode Ways 解码方法 - 刷尽天下</a></p></blockquote><h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(n)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>() || s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i] = (s[i - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) ? <span class="number">0</span> : dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; (s[i - <span class="number">2</span>] == <span class="string">&#x27;1&#x27;</span> || (s[i - <span class="number">2</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s[i - <span class="number">1</span>] &lt;= <span class="string">&#x27;6&#x27;</span>))) &#123;</span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-19th-DMaximum-Product-of-Splitted-Binary-Tree"><a href="#August-19th-DMaximum-Product-of-Splitted-Binary-Tree" class="headerlink" title="August 19th: DMaximum Product of Splitted Binary Tree"></a>August 19th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/615/week-3-august-15th-august-21st/3903/">DMaximum Product of Splitted Binary Tree</a></h2><h3 id="大意-4"><a href="#大意-4" class="headerlink" title="大意"></a>大意</h3><p>给定二叉树，切断其中的一条边，两个子树各自求和，返回两和之积的最大值。</p><h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><p>使用 DFS，用父树的总和 <code>total</code> 减去当前子树的和 <code>sum</code>，就可以得到两棵子树的和，不断更新最大值即可。</p><h4 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(n)</code></p></li><li><p>时间：<code>O(1)</code></p></li></ul><h4 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> total = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        total = <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res % <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_sum = <span class="built_in">dfs</span>(node-&gt;left) + <span class="built_in">dfs</span>(node-&gt;right) + node-&gt;val;</span><br><span class="line">        res = <span class="built_in">max</span>(res, (total-cur_sum)*cur_sum);</span><br><span class="line">        <span class="keyword">return</span> cur_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-20th-Valid-Sudoku"><a href="#August-20th-Valid-Sudoku" class="headerlink" title="August 20th: Valid Sudoku"></a>August 20th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/615/week-3-august-15th-august-21st/3904/">Valid Sudoku</a></h2><h3 id="大意-5"><a href="#大意-5" class="headerlink" title="大意"></a>大意</h3><p>给定 <code>9*9</code> 的数独矩阵，判断当前是否合法。合法需要满足：</p><ol><li><p>同一行必须包含不重复的 <code>1-9</code> 之间的数字，可以有缺失</p></li><li><p>同一行必须包含不重复的 <code>1-9</code> 之间的数字，可以有缺失</p></li><li><p>同一小矩阵必须包含不重复的 <code>1-9</code> 之间的数字，可以有缺失</p></li></ol><h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3><p>使用 <code>set</code> 分别存储行、列、小矩阵中出现过的数字，如果 <code>insert</code> 失败，说明不合法，返回 <code>false</code> 即可。</p><h4 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(1)</code></p></li><li><p>时间：<code>O(1)</code></p></li></ul><h4 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">char</span>&gt; rows[<span class="number">9</span>], cols[<span class="number">9</span>], grids[<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (!rows[i].<span class="built_in">insert</span>(board[i][j]).second ||</span><br><span class="line">                    !cols[j].<span class="built_in">insert</span>(board[i][j]).second ||</span><br><span class="line">                    !grids[<span class="number">3</span>*(i/<span class="number">3</span>)+j/<span class="number">3</span>].<span class="built_in">insert</span>(board[i][j]).second) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-21st-Sudoku-Solver"><a href="#August-21st-Sudoku-Solver" class="headerlink" title="August 21st: Sudoku Solver"></a>August 21st: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/615/week-3-august-15th-august-21st/3905/">Sudoku Solver</a></h2><h3 id="大意-6"><a href="#大意-6" class="headerlink" title="大意"></a>大意</h3><p>给定 <code>9*9</code> 的数独矩阵，返回求解后的矩阵。需要满足：</p><ol><li><p>同一行必须包含不重复的 <code>1-9</code> 之间的数字</p></li><li><p>同一行必须包含不重复的 <code>1-9</code> 之间的数字</p></li><li><p>同一小矩阵必须包含不重复的 <code>1-9</code> 之间的数字</p></li></ol><h3 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h3><blockquote><p>参考：<a href="https://www.cnblogs.com/grandyang/p/4421852.html">[LeetCode] 37. Sudoku Solver 求解数独 - 刷尽天下</a></p></blockquote><h4 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(1)</code></p></li><li><p>时间：<code>O(1)</code></p></li></ul><h4 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">helper</span>(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">9</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">9</span>) <span class="keyword">return</span> <span class="built_in">helper</span>(board, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> <span class="built_in">helper</span>(board, i, j + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">&#x27;1&#x27;</span>; c &lt;= <span class="string">&#x27;9&#x27;</span>; ++c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isValid</span>(board, i , j, c)) <span class="keyword">continue</span>;</span><br><span class="line">            board[i][j] = c;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">helper</span>(board, i, j + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">9</span>; ++x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[x][j] == val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">9</span>; ++y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][y] == val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row = i - i % <span class="number">3</span>, col = j - j % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; ++x) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">3</span>; ++y) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[x + row][y + col] == val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 八月挑战专题，第三周，每日随缘更新。&lt;/p&gt;</summary>
    
    
    
    <category term="A4 - LeetCode" scheme="https://progcz.com/categories/A4-LeetCode/"/>
    
    <category term="B4 - LeetCoding Challenge" scheme="https://progcz.com/categories/A4-LeetCode/B4-LeetCoding-Challenge/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2021 August LeetCoding Challenge - Week 2</title>
    <link href="https://progcz.com/posts/1628470617/"/>
    <id>https://progcz.com/posts/1628470617/</id>
    <published>2021-08-09T00:57:37.000Z</published>
    <updated>2021-08-15T08:24:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 八月挑战专题，第二周，每日随缘更新。</p><span id="more"></span><h2 id="August-8th-Rank-Transform-of-a-Matrix"><a href="#August-8th-Rank-Transform-of-a-Matrix" class="headerlink" title="August 8th: Rank Transform of a Matrix"></a>August 8th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/614/week-2-august-8th-august-14th/3874/">Rank Transform of a Matrix</a></h2><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定 <code>m*n</code> 的矩阵 <code>matrix</code>，返回矩阵中每个元素的 <code>rank</code>。</p><p>其中，<code>rank</code> 遵循以下规则：</p><ul><li><p><code>rank</code> 从 <code>1</code> 开始。</p></li><li><p>对于在同一行或同一列的 <code>p</code> 和 <code>q</code>，</p><ul><li><p>如果 <code>p &lt; q</code>，那么 <code>rank(p) &lt; rank(q)</code>。</p></li><li><p>如果 <code>p == q</code>，那么 <code>rank(p) == rank(q)</code>。</p></li><li><p>如果 <code>p &gt; q</code>，那么 <code>rank(p) &gt; rank(q)</code>。</p></li></ul></li><li><p><code>rank</code> 应该尽可能地小。</p></li></ul><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><blockquote><p>参考：<a href="https://leetcode.com/problems/rank-transform-of-a-matrix/discuss/1391380/C%2B%2BPython-HashMap-and-Sort-and-UnionFind-Visualize-picture-Clean-and-Concise">[C++/Python] HashMap &amp; Sort &amp; UnionFind - Visualize picture - Clean &amp; Concise</a></p></blockquote><p>首先，找到同一数字的所有位置。</p><p>其次，在某个数字的所有位置中，找到在同一行和同一列的位置，以是否为同一 <code>rank</code> 聚合起来。</p><p>最后，找到同一行和同一列中目前的最大值，<code>+1</code> 即可。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(m*n*log(m*n))</code></p></li><li><p>时间：<code>O(m*n)</code></p></li></ul><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == parent[u]) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">return</span> parent[u] = <span class="built_in">Find</span>(parent[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent.<span class="built_in">count</span>(u) == <span class="number">0</span>) parent[u] = u;</span><br><span class="line">        <span class="keyword">if</span> (parent.<span class="built_in">count</span>(v) == <span class="number">0</span>) parent[v] = v;</span><br><span class="line">        <span class="keyword">int</span> pu = <span class="built_in">Find</span>(u), pv = <span class="built_in">Find</span>(v);</span><br><span class="line">        <span class="keyword">if</span> (pu != pv) parent[pu] = pv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">matrixRankTransform</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        map&lt;<span class="keyword">int</span>, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; groupByValue;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; ++r)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c)</span><br><span class="line">                groupByValue[matrix[r][c]].<span class="built_in">push_back</span>(&#123;r, c&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rank</span><span class="params">(m+n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; [_, cells]  : groupByValue) &#123;</span><br><span class="line">            UnionFind uf;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; [r, c] : cells)</span><br><span class="line">                uf.<span class="built_in">Union</span>(r, c + m);</span><br><span class="line"></span><br><span class="line">            unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; groups;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; [u, _] : uf.parent) &#123;</span><br><span class="line">                groups[uf.<span class="built_in">Find</span>(u)].<span class="built_in">push_back</span>(u);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; [_, group] : groups) &#123;</span><br><span class="line">                <span class="keyword">int</span> maxRank = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i : group) maxRank = <span class="built_in">max</span>(maxRank, rank[i]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i : group) rank[i] = maxRank + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; [r, c] : cells) matrix[r][c] = rank[r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-9th-Add-Strings"><a href="#August-9th-Add-Strings" class="headerlink" title="August 9th: Add Strings"></a>August 9th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/614/week-2-august-8th-august-14th/3875/">Add Strings</a></h2><h3 id="大意-1"><a href="#大意-1" class="headerlink" title="大意"></a>大意</h3><p>以字符串的形式，给定两个非负整数 <code>num1</code> 和 <code>num2</code>，同样以字符串的形式，返回这两个数字之和。</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>按位转换成数字，相加进位即可。</p><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(n)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">max</span>(num1.<span class="built_in">size</span>(), num2.<span class="built_in">size</span>()), next = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(num1.<span class="built_in">begin</span>(), num1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(num2.<span class="built_in">begin</span>(), num2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = i &lt; num1.<span class="built_in">size</span>() ? num1[i] : <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">char</span> c2 = i &lt; num2.<span class="built_in">size</span>() ? num2[i] : <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = c1 - <span class="string">&#x27;0&#x27;</span> + c2 - <span class="string">&#x27;0&#x27;</span> + next;</span><br><span class="line">            res.<span class="built_in">push_back</span>(sum % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            next = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(next + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-10th-Flip-String-to-Monotone-Increasing"><a href="#August-10th-Flip-String-to-Monotone-Increasing" class="headerlink" title="August 10th: Flip String to Monotone Increasing"></a>August 10th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/614/week-2-august-8th-august-14th/3876/">Flip String to Monotone Increasing</a></h2><h3 id="大意-2"><a href="#大意-2" class="headerlink" title="大意"></a>大意</h3><p>给定一个字符串 <code>s</code>，只由 <code>0</code> 和 <code>1</code> 组成，反转其中的数字，使得 <code>s</code> 成为单调增的字符串，即由若干个（可以 0 个）连续的 <code>0</code> 紧跟着若干个（可以 0 个）连续的 <code>1</code> 组成。</p><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><blockquote><p>参考：<a href="https://www.cnblogs.com/grandyang/p/11964938.html">[LeetCode] 926. Flip String to Monotone Increasing 翻转字符串到单调递增 - 刷尽天下</a></p></blockquote><p>动态规划，使用两个数组 <code>cnt1</code> 和 <code>cnt0</code>。</p><p>其中，<code>cnt1[i]</code> 表示将范围是 <code>[0, i-1]</code> 的子串内最小的将 <code>1</code> 转为 <code>0</code> 的个数，从而形成单调字符串。</p><p>同理，<code>cnt0[j]</code> 表示将范围是 <code>[j, n-1]</code> 的子串内最小的将 <code>0</code> 转为 <code>1</code> 的个数，从而形成单调字符串。</p><p>这样最终在某个位置使得 <code>cnt0[i]+cnt1[i]</code> 最小的时候，就是成为单调串的最优解。</p><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(n)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minFlipsMonoIncr</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), res = INT_MAX;</span><br><span class="line">        vector&lt;int&gt; cnt1(n+1, 0), cnt0(n+1, 0);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; ++i, --j) &#123;</span><br><span class="line">            cnt1[i] += cnt1[i<span class="number">-1</span>] + (s[i<span class="number">-1</span>] == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">            cnt0[j] += cnt0[j+<span class="number">1</span>] + (s[j] == <span class="string">&#x27;1&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res, cnt1[i] + cnt0[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-11th-Array-of-Doubled-Pairs"><a href="#August-11th-Array-of-Doubled-Pairs" class="headerlink" title="August 11th: Array of Doubled Pairs"></a>August 11th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/614/week-2-august-8th-august-14th/3877/">Array of Doubled Pairs</a></h2><h3 id="大意-3"><a href="#大意-3" class="headerlink" title="大意"></a>大意</h3><p>给定一个数组 <code>arr</code>，其元素个数为偶数。重排 <code>arr</code>，如果对于任意 <code>0 &lt;= i &lt; len(arr) / 2</code>，都能满足 <code>arr[2 * i + 1] = 2 * arr[2 * i]</code>，那么返回 <code>true</code>，否则返回 <code>false</code>。</p><h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>首先，使用 <code>map</code> 统计每个元素出现的次数。</p><p>其次，将 <code>arr</code> 按绝对值从小到大排序。</p><p>最后，遍历 <code>arr</code>，对于遍历到的 <code>num</code>，如果 <code>num</code> 在 <code>map</code> 中 <code>value</code> 不为 <code>0</code>，那么就在 <code>map</code> 中寻找 <code>2 * num</code>，如果找不到或者找到后其 <code>value</code> 为 <code>0</code>，不满足题目要求，返回 <code>false</code>。</p><h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(nlogn)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canReorderDoubled</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; um;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; num : arr) &#123;</span><br><span class="line">            ++um[num];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(a) &lt; <span class="built_in">abs</span>(b);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; num : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (um[num] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> iter = um.<span class="built_in">find</span>(<span class="number">2</span>*num);</span><br><span class="line">            <span class="keyword">if</span> (iter == um.<span class="built_in">end</span>() || iter-&gt;second &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --um[num]; --um[<span class="number">2</span>*num];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-12th-Group-Anagrams"><a href="#August-12th-Group-Anagrams" class="headerlink" title="August 12th: Group Anagrams"></a>August 12th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/614/week-2-august-8th-august-14th/3887/">Group Anagrams</a></h2><h3 id="大意-4"><a href="#大意-4" class="headerlink" title="大意"></a>大意</h3><p>给定一个字符串数组 <code>strs</code>，要求将所有的 <code>anagrams</code> 聚类到一起。</p><p>所谓 <code>anagrams</code>，是指若干个字符串，使用了相同的字符，且每个字符出现的次数也都相同。</p><h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><p>以排序后的字符串为 key，使用 <code>map</code> 聚类所有的 <code>anagrams</code> 即可。</p><h4 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(m*n*logn)</code></p></li><li><p>时间：<code>O(m*n)</code></p></li></ul><h4 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; um;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str : strs) &#123;</span><br><span class="line">            <span class="function">string <span class="title">sort_str</span><span class="params">(str.begin(), str.end())</span></span>;</span><br><span class="line">            <span class="built_in">sort</span>(sort_str.<span class="built_in">begin</span>(), sort_str.<span class="built_in">end</span>());</span><br><span class="line">            um[sort_str].<span class="built_in">push_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : um) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(p.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-13th-Set-Matrix-Zeroes"><a href="#August-13th-Set-Matrix-Zeroes" class="headerlink" title="August 13th: Set Matrix Zeroes"></a>August 13th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/614/week-2-august-8th-august-14th/3888/">Set Matrix Zeroes</a></h2><h3 id="大意-5"><a href="#大意-5" class="headerlink" title="大意"></a>大意</h3><p>给定一个矩阵 <code>matrix</code>，如果某个元素为 <code>0</code>，则将该行和该列的元素全部 <code>in-place</code> 置为 <code>0</code>。</p><h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3><p>使用两个 <code>set</code>，记录 <code>0</code> 出现的所有行和列，最后统一置为 <code>0</code> 即可。</p><h4 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O((mn)^2)</code></p></li><li><p>时间：<code>O(m+n)</code></p></li></ul><h4 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; rows, cols;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                rows.<span class="built_in">insert</span>(i); cols.<span class="built_in">insert</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> r : rows) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                matrix[r][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : cols) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">                matrix[i][c] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-14th-Remove-Boxes"><a href="#August-14th-Remove-Boxes" class="headerlink" title="August 14th: Remove Boxes"></a>August 14th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/614/week-2-august-8th-august-14th/3889/">Remove Boxes</a></h2><h3 id="大意-6"><a href="#大意-6" class="headerlink" title="大意"></a>大意</h3><p>给定数组 <code>boxes</code>，元素都为正整数，每回合可以消除 <code>k</code> 个连续且相等的元素，可以得到 <code>k*k</code> 分，直到元素全部被消除掉，返回能够获取到的最高分。</p><h3 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h3><blockquote><p>参考：<a href="https://www.cnblogs.com/grandyang/p/6850657.html">[LeetCode] 546. Remove Boxes 移除盒子 - 刷尽天下</a></p></blockquote><h4 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(n^4)</code>，不确定</p></li><li><p>时间：<code>O(n^3)</code></p></li></ul><h4 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeBoxes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; boxes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = boxes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">100</span>][<span class="number">100</span>][<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(boxes, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; boxes, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k, <span class="keyword">int</span> dp[<span class="number">100</span>][<span class="number">100</span>][<span class="number">100</span>])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; i) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j][k] &gt; <span class="number">0</span>) <span class="keyword">return</span> dp[i][j][k];</span><br><span class="line">        <span class="keyword">int</span> res = (<span class="number">1</span> + k) * (<span class="number">1</span> + k) + <span class="built_in">helper</span>(boxes, i + <span class="number">1</span>, j, <span class="number">0</span>, dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = i + <span class="number">1</span>; m &lt;= j; ++m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (boxes[m] == boxes[i]) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, <span class="built_in">helper</span>(boxes, i + <span class="number">1</span>, m - <span class="number">1</span>, <span class="number">0</span>, dp) + <span class="built_in">helper</span>(boxes, m, j, k + <span class="number">1</span>, dp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j][k] = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 八月挑战专题，第二周，每日随缘更新。&lt;/p&gt;</summary>
    
    
    
    <category term="A4 - LeetCode" scheme="https://progcz.com/categories/A4-LeetCode/"/>
    
    <category term="B4 - LeetCoding Challenge" scheme="https://progcz.com/categories/A4-LeetCode/B4-LeetCoding-Challenge/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Problem 7 - Reverse Integer</title>
    <link href="https://progcz.com/posts/1627951198/"/>
    <id>https://progcz.com/posts/1627951198/</id>
    <published>2021-08-03T00:40:37.000Z</published>
    <updated>2021-08-03T00:49:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/reverse-integer/">https://leetcode.com/problems/reverse-integer/</a></p><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定 32 位整数 <code>x</code>，返回反转后的数字，如果存在溢出，则返回 <code>0</code>。</p><span id="more"></span><h2 id="解法一：模运算"><a href="#解法一：模运算" class="headerlink" title="解法一：模运算"></a>解法一：模运算</h2><p>通过模运算来反转 <code>x</code> 即可。</p><p>需要注意的是，判断反转后的数字 <code>res</code> 是否会溢出，这个判断不能在每次模运算之后（因为如果溢出，此时已经溢出），而应该在每次模运算之前，判断 <code>res</code> 是否超出了 <code>INT_MAX/10</code>。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(1)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(res) &gt; INT_MAX/<span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-integer/&quot;&gt;https://leetcode.com/problems/reverse-integer/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h3&gt;&lt;p&gt;给定 32 位整数 &lt;code&gt;x&lt;/code&gt;，返回反转后的数字，如果存在溢出，则返回 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="A4 - LeetCode" scheme="https://progcz.com/categories/A4-LeetCode/"/>
    
    <category term="B1 - LeetCode Problems" scheme="https://progcz.com/categories/A4-LeetCode/B1-LeetCode-Problems/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Math" scheme="https://progcz.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Problem 5 - Longest Palindromic Substring</title>
    <link href="https://progcz.com/posts/1627949478/"/>
    <id>https://progcz.com/posts/1627949478/</id>
    <published>2021-08-03T00:12:10.000Z</published>
    <updated>2021-08-03T00:27:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/longest-palindromic-substring/">https://leetcode.com/problems/longest-palindromic-substring/</a></p><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定字符串 <code>s</code>，返回其中的最长回文子串。</p><span id="more"></span><h2 id="解法一：遍历扩散"><a href="#解法一：遍历扩散" class="headerlink" title="解法一：遍历扩散"></a>解法一：遍历扩散</h2><p>遍历字符串 <code>s</code>，从每个字符的位置 <code>i</code> 向外扩散，寻找最长回文子串。</p><p>需要注意的是，回文子串的长度有奇偶之分，因此：对于奇数长度，从 <code>i</code> 扩散，对于偶数长度，从 <code>i</code> 和 <code>i+1</code> 向外扩散。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(1)</code></p></li><li><p>时间：<code>O(n^2)</code></p></li></ul><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), ss_start = <span class="number">0</span>, ss_length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">helper</span>(s, i, i, ss_start, ss_length);</span><br><span class="line">            <span class="built_in">helper</span>(s, i, i+<span class="number">1</span>, ss_start, ss_length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(ss_start, ss_length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(string&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span>&amp; ss_start, <span class="keyword">int</span>&amp; ss_length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left; ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ss_length &lt; right - left - <span class="number">1</span>) &#123;</span><br><span class="line">            ss_start = left + <span class="number">1</span>;</span><br><span class="line">            ss_length = right - left - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：马拉车算法"><a href="#解法二：马拉车算法" class="headerlink" title="解法二：马拉车算法"></a>解法二：马拉车算法</h2><p>以前写过，参见：<a href="/posts/apply-manacher-s-algorithm-to-solve-longest-palindromic-substring-problem/">使用马拉车算法解决最长回文子串问题</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-substring/&quot;&gt;https://leetcode.com/problems/longest-palindromic-substring/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h3&gt;&lt;p&gt;给定字符串 &lt;code&gt;s&lt;/code&gt;，返回其中的最长回文子串。&lt;/p&gt;</summary>
    
    
    
    <category term="A4 - LeetCode" scheme="https://progcz.com/categories/A4-LeetCode/"/>
    
    <category term="B1 - LeetCode Problems" scheme="https://progcz.com/categories/A4-LeetCode/B1-LeetCode-Problems/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="String" scheme="https://progcz.com/tags/String/"/>
    
    <category term="Dynamic Programming" scheme="https://progcz.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>2021 August LeetCoding Challenge - Week 1</title>
    <link href="https://progcz.com/posts/1627831620/"/>
    <id>https://progcz.com/posts/1627831620/</id>
    <published>2021-08-01T15:28:02.000Z</published>
    <updated>2021-08-08T03:21:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 八月挑战专题，第一周，每日随缘更新。</p><span id="more"></span><h2 id="August-1st-Making-A-Large-Island"><a href="#August-1st-Making-A-Large-Island" class="headerlink" title="August 1st: Making A Large Island"></a>August 1st: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/613/week-1-august-1st-august-7th/3835/">Making A Large Island</a></h2><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定 <code>n*n</code> 的矩阵，每格中的数字为 <code>0</code> 或 <code>1</code>，可以将其中的 <code>1</code> 个格子从 <code>0</code> 置为 <code>1</code>，求解矩阵中最大「岛屿」的面积。</p><p>其中，「岛屿」是指在上、下、左、右四个方向中，连通起来的 <code>1</code> 的区域。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><blockquote><p>参考：<a href="https://leetcode.com/problems/making-a-large-island/discuss/1376700/C%2B%2B-BFS-O(n2)-5-%3A(">C++ BFS  O(n^2) 5% :(</a></p></blockquote><p>首先，遍历矩阵，使用 BFS 探索所有的岛屿，标记为不同的 <code>flag</code>，并且使用 <code>record</code> 记录不同 <code>flag</code> 对应的岛屿面积 <code>cnt</code>。</p><p>其次，遍历矩阵，找出上、下、左、右四个方向所对应的 <code>flag</code>，累加其 <code>cnt</code> 即可。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(n^2)</code></p></li><li><p>时间：<code>O(n^4)</code></p></li></ul><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dirs[<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; record, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>(), cnt = <span class="number">0</span>;</span><br><span class="line">        queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">        grid[i][j] = flag;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, y] = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; dir : dirs) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = x + dir.first, ny = y + dir.second;</span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] == <span class="number">1</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">                    grid[nx][ny] = flag;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        record[flag] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestIsland</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>(), flag = <span class="number">2</span>, res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; record;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">bfs</span>(grid, record, i, j, flag++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                unordered_set&lt;<span class="keyword">int</span>&gt; us;</span><br><span class="line">                us.<span class="built_in">insert</span>(grid[i][j]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; dir : dirs) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ni = i + dir.first, nj = j + dir.second;</span><br><span class="line">                    <span class="keyword">if</span> (ni &gt;= <span class="number">0</span> &amp;&amp; ni &lt; n &amp;&amp; nj &gt;= <span class="number">0</span> &amp;&amp; nj &lt; n) &#123;</span><br><span class="line">                        us.<span class="built_in">insert</span>(grid[ni][nj]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> sum = !grid[i][j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; flag : us) &#123;</span><br><span class="line">                    sum += record[flag];</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-2nd-Two-Sum"><a href="#August-2nd-Two-Sum" class="headerlink" title="August 2nd: Two Sum"></a>August 2nd: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/613/week-1-august-1st-august-7th/3836/">Two Sum</a></h2><h3 id="大意-1"><a href="#大意-1" class="headerlink" title="大意"></a>大意</h3><p>给定数组 <code>nums</code> 和数字 <code>target</code>，要求在 <code>nums</code> 中找到两个数字，和为 <code>target</code>，返回这两个数字的下标。</p><p>题目保证有且只有一个解，而且同一个数字不能用两次。</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>以前做过，参见：<a href="/posts/leetcode-problem-two-sum/#%E8%A7%A3%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%80%9F%E5%8A%A9-hash-map%EF%BC%8C%E7%94%A8%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4">LeetCode Problem 1 - Two Sum</a></p><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(n)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; record;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = record.<span class="built_in">find</span>(target-nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (iter != record.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, iter-&gt;second&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            record[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-3rd-Subsets-II"><a href="#August-3rd-Subsets-II" class="headerlink" title="August 3rd: Subsets II"></a>August 3rd: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/613/week-1-august-1st-august-7th/3837/">Subsets II</a></h2><h3 id="大意-2"><a href="#大意-2" class="headerlink" title="大意"></a>大意</h3><p>给定一个数组 <code>nums</code>，其中可能有重复元素，返回所有可能的子集，要求子集之间不重复。</p><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>使用 <code>set&lt;vector&lt;int&gt;&gt; s</code> 来存放所有的子集，避免出现 <code>[1,2]</code> 和 <code>[1,2]</code> 这种重复 case。</p><p>将 <code>nums</code> 进行排序，避免出现 <code>[1,2,2]</code> 和 <code>[2,1,2]</code> 这种重复 case。</p><p>遍历 <code>nums</code>，将遍历到的 <code>num</code> 与 <code>s</code> 中的每个数组组成新的数组，添加至 <code>s</code> 中即可。</p><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(2^n)</code>（不确定）</p></li><li><p>时间：<code>O(n*2^n)</code></p></li></ul><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        set&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">        s.<span class="built_in">insert</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;&#125;);</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            set&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ts</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> vi : ts) &#123;</span><br><span class="line">                vi.<span class="built_in">push_back</span>(num);</span><br><span class="line">                s.<span class="built_in">insert</span>(vi);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-4th-Path-Sum-II"><a href="#August-4th-Path-Sum-II" class="headerlink" title="August 4th: Path Sum II"></a>August 4th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/613/week-1-august-1st-august-7th/3838/">Path Sum II</a></h2><h3 id="大意-3"><a href="#大意-3" class="headerlink" title="大意"></a>大意</h3><p>给定一个二叉树的根节点 <code>root</code> 和数字 <code>targetSum</code>，返回所有从根节点到叶节点的路径，要求路径上所有节点之和等于 <code>targetSum</code>。</p><h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>使用 DFS 即可。</p><h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(nlogn)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="keyword">int</span> targetSum) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root, res, path, sum, targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; res,</span></span></span><br><span class="line"><span class="function"><span class="params">             vector&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span>&amp; sum, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        sum += node-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == targetSum) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;left, res, path, sum, targetSum);</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;right, res, path, sum, targetSum);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        sum -= node-&gt;val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-5th-Stone-Game"><a href="#August-5th-Stone-Game" class="headerlink" title="August 5th: Stone Game"></a>August 5th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/613/week-1-august-1st-august-7th/3870/">Stone Game</a></h2><h3 id="大意-4"><a href="#大意-4" class="headerlink" title="大意"></a>大意</h3><p>给定数组 <code>piles</code>，数组中数字个数为偶数，数字之和为奇数。小明和小红轮流从数组的首位或末位取数，小红先手，直到取完为止，两者手中数字之和较大者胜。假设两者均以最优策略进行游戏，返回小红是否能够获胜。</p><h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><blockquote><p>参考：<a href="https://leetcode.com/problems/stone-game/discuss/1384652/C%2B%2BPython-DP-No-math-Easy-to-understand-Clean-and-Concise">[C++/Python] DP - No math - Easy to understand - Clean &amp; Concise</a></p></blockquote><h4 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(n^2)</code></p></li><li><p>时间：<code>O(n^2)</code></p></li></ul><h4 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGame</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = piles.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;pii&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;pii&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = n - <span class="number">1</span>; left &gt;= <span class="number">0</span>; --left) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> right = left; right &lt; n; ++right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                    dp[left][right] = <span class="built_in">make_pair</span>(piles[left], <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pii pickLeft = dp[left + <span class="number">1</span>][right];</span><br><span class="line">                pii pickRight = dp[left][right - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (piles[left] + pickLeft.second &gt; piles[right] + pickRight.second) &#123;</span><br><span class="line">                    dp[left][right] = <span class="built_in">make_pair</span>(piles[left] + pickLeft.second, pickLeft.first);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[left][right] = <span class="built_in">make_pair</span>(piles[right] + pickRight.second, pickRight.first);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [aliceScore, leeScore] = dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> aliceScore &gt; leeScore;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-6th-N-ary-Tree-Level-Order-Traversal"><a href="#August-6th-N-ary-Tree-Level-Order-Traversal" class="headerlink" title="August 6th: N-ary Tree Level Order Traversal"></a>August 6th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/613/week-1-august-1st-august-7th/3871/">N-ary Tree Level Order Traversal</a></h2><h3 id="大意-5"><a href="#大意-5" class="headerlink" title="大意"></a>大意</h3><p>给定一个树，将其按层级进行序列化。</p><h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3><p>使用 BFS 即可。</p><h4 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(n)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h4 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        queue&lt;Node*&gt; q; q.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tres;</span><br><span class="line">        queue&lt;Node*&gt; tq;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            tres.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> child : node-&gt;children) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!child) <span class="keyword">continue</span>;</span><br><span class="line">                tq.<span class="built_in">push</span>(child);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                q = tq;</span><br><span class="line">                <span class="keyword">while</span> (!tq.<span class="built_in">empty</span>()) tq.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (!tres.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(tres);</span><br><span class="line">                    tres.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-7th-Palindrome-Partitioning-II"><a href="#August-7th-Palindrome-Partitioning-II" class="headerlink" title="August 7th: Palindrome Partitioning II"></a>August 7th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/613/week-1-august-1st-august-7th/3872/">Palindrome Partitioning II</a></h2><h3 id="大意-6"><a href="#大意-6" class="headerlink" title="大意"></a>大意</h3><p>给定一个字符串 <code>s</code>，切分 <code>s</code> 使得每个子串都是回文子串，返回切分的最小次数。 </p><h3 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h3><blockquote><p>参考：<a href="https://www.cnblogs.com/grandyang/p/4271456.html">[LeetCode] Palindrome Partitioning II 拆分回文串之二 - 刷尽天下</a></p></blockquote><h4 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>空间：<code>O(n^2)</code></p></li><li><p>时间：<code>O(n^2)</code></p></li></ul><h4 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">p</span>(n, vector&lt;<span class="keyword">bool</span>&gt;(n));</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; (i - j &lt; <span class="number">2</span> || p[j + <span class="number">1</span>][i - <span class="number">1</span>])) &#123;</span><br><span class="line">                    p[j][i] = <span class="literal">true</span>;</span><br><span class="line">                    dp[i] = (j == <span class="number">0</span>) ? <span class="number">0</span> : <span class="built_in">min</span>(dp[i], dp[j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 八月挑战专题，第一周，每日随缘更新。&lt;/p&gt;</summary>
    
    
    
    <category term="A4 - LeetCode" scheme="https://progcz.com/categories/A4-LeetCode/"/>
    
    <category term="B4 - LeetCoding Challenge" scheme="https://progcz.com/categories/A4-LeetCode/B4-LeetCoding-Challenge/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>上海迪士尼乐园攻略：两人行一日游</title>
    <link href="https://progcz.com/posts/1624282620/"/>
    <id>https://progcz.com/posts/1624282620/</id>
    <published>2021-06-21T13:41:11.000Z</published>
    <updated>2021-06-26T06:24:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>从去年开始，女朋友就一直念着想去上海迪士尼乐园，然而疫情使得计划一拖再拖，直到上周六才如愿以偿。</p><p>不得不说，迪士尼乐园的确是真实世界中最接近于「童话王国」的地方，迪士尼作品中的经典形象在这里都触手可及。你可以是杰克船长的水手，也可以是冰雪女王的朋友；你可以坐在蜜罐里和小熊维尼打招呼，也可以跟着小飞侠穿梭在城市的上空。</p><p>迪士尼满足你的童心、少女心，以及对于浪漫的一切幻想。<del>只要你肯花钱。</del></p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/25.png"></p><span id="more"></span><div class="note info"><p>友情提示：上海迪士尼乐园的政策几乎每月一变，可能导致攻略失效，比如很多攻略中提到的 FP 早就不复存在了，所以以下内容与其称为攻略，不如说是记录，仅供参考。</p></div><h2 id="1-购买门票"><a href="#1-购买门票" class="headerlink" title="1 购买门票"></a>1 购买门票</h2><p>我是在美团上购买的门票，价格大概是官方打 93 折。</p><blockquote><p>需要注意的是，不管是什么渠道购买的门票，都会有一行类似的注意事项：</p><p><em>乐园门票一经售出不可转让、不可退款，除非法律另有规定。指定日门票可在尚有余票且补足票价差额的前提下，于有效日的两日前更换两次等值或者更高价值的指定日门票。</em></p><p>而且我当时看到只能更换为当月的门票，所以建议提前规划行程，尤其注意天气。</p></blockquote><h2 id="2-准备随身携带的物品"><a href="#2-准备随身携带的物品" class="headerlink" title="2 准备随身携带的物品"></a>2 准备随身携带的物品</h2><p>记得携带身份证、口罩（疫情期间）、手机、移动电源及数据线、一次性雨衣（漂流项目和下雨天气）、空的非玻璃水瓶（园区内直饮水）、防晒用品（夏季）、小风扇（夏季）等等。</p><p>不能携带自拍杆、折叠椅、自热食物等等。</p><p>更多参考<a href="https://www.shanghaidisneyresort.com/rules/">上海迪士尼乐园游客须知</a>。</p><h2 id="3-住宿"><a href="#3-住宿" class="headerlink" title="3 住宿"></a>3 住宿</h2><p>我本身在上海，不用考虑住宿，所以这一部分就跳过了。</p><h2 id="4-入园"><a href="#4-入园" class="headerlink" title="4 入园"></a>4 入园</h2><p>如果购买早享卡，可以提前一个小时入园。</p><p>如果不买早享卡，建议提前至少一个小时到达园区门口排队，有包游客需要过有包安检，比较慢，无包游客只需要过安检门，比较快。</p><blockquote><p>需要注意的是，同一订单的多张门票必须同时入园，所以要么分不同订单来购买门票，要么同行的人都排有包安检，除非大家都不带包。</p></blockquote><h2 id="5-游玩"><a href="#5-游玩" class="headerlink" title="5 游玩"></a>5 游玩</h2><p>提前下载好上海迪士尼乐园的 APP，入园后将同行门票绑定在同一个 APP 内，优先领取预约等候卡，没有预约等候卡的项目可以在游玩过程中视排队情况购买尊享卡。</p><ol><li><p>领取预约等候卡，等于拥有在高峰时段排队的资格。每天可领取预约等候卡的项目不固定，可以当日在 APP 内查询。</p></li><li><p>购买尊享卡，等于拥有在任意时段插队的资格。如果想买尊享卡的项目比较多，可以考虑八件套或者六件套。</p></li></ol><p>放张盗来的图，热门项目基本一览无余。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/26.png"></p><p>再来分享一波自己拍的照片。</p><p>两个必看的舞台剧：风暴来临·杰克船长之惊天特技大冒险 &amp; 冰雪奇缘·欢唱盛会。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/27.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/28.png"></div></div></div><p>在漫威总部见到了钢铁侠的历代战甲，还碰到了钢铁侠的 COS，可惜是个视频没办法传上来。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/29.png"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/30.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/31.png"></div></div></div><p>夜晚的旋转木马，可以说是如梦如幻了。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/32.png"></p><h2 id="6-就餐"><a href="#6-就餐" class="headerlink" title="6 就餐"></a>6 就餐</h2><p>图个省事，我和女朋友在园区内吃的午饭和晚饭，每顿人均 100 左右。</p><p>午饭在加勒比海盗附近的巴博萨烧烤，左图的秋刀鱼套餐很不错。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/33.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/34.png"></div></div></div><p>晚饭在创极速光轮附近的星露台餐厅，钢铁侠牛肉汉堡非常难吃，不放图了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从去年开始，女朋友就一直念着想去上海迪士尼乐园，然而疫情使得计划一拖再拖，直到上周六才如愿以偿。&lt;/p&gt;
&lt;p&gt;不得不说，迪士尼乐园的确是真实世界中最接近于「童话王国」的地方，迪士尼作品中的经典形象在这里都触手可及。你可以是杰克船长的水手，也可以是冰雪女王的朋友；你可以坐在蜜罐里和小熊维尼打招呼，也可以跟着小飞侠穿梭在城市的上空。&lt;/p&gt;
&lt;p&gt;迪士尼满足你的童心、少女心，以及对于浪漫的一切幻想。&lt;del&gt;只要你肯花钱。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/25.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A1 - 生活" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB/"/>
    
    <category term="B1 - 经历" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB/B1-%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="上海" scheme="https://progcz.com/tags/%E4%B8%8A%E6%B5%B7/"/>
    
    <category term="迪士尼" scheme="https://progcz.com/tags/%E8%BF%AA%E5%A3%AB%E5%B0%BC/"/>
    
    <category term="加勒比海盗" scheme="https://progcz.com/tags/%E5%8A%A0%E5%8B%92%E6%AF%94%E6%B5%B7%E7%9B%97/"/>
    
    <category term="漫威" scheme="https://progcz.com/tags/%E6%BC%AB%E5%A8%81/"/>
    
  </entry>
  
  <entry>
    <title>招商银行朝朝宝：余额宝和零钱通的最佳替代品</title>
    <link href="https://progcz.com/posts/1620777814/"/>
    <id>https://progcz.com/posts/1620777814/</id>
    <published>2021-05-12T00:05:49.000Z</published>
    <updated>2021-05-13T14:14:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我们看向历史的后视镜，2013 年面世的余额宝确实是一款影响十分深远的产品，它永久地改变了人们对于短期闲置现金的处置方式，更进一步地推动了无现金支付的发展。邯郸学步的零钱通后来也不断壮大，和余额宝一起，成为人们活期理财的首要选择。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/03.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/04.png"></div></div></div><p>达成这一切，靠的便是直击用户痛点的两个特性：<strong>高收益率</strong>和<strong>随时支取</strong>。</p><p>然而，眼看着互联网金融的繁荣发展，银行自然不能坐以待毙。</p><p>招商银行推出的<strong>朝朝宝</strong>便是这样一款狙击余额宝/零钱通的活期理财产品，极大地吸引了以招商银行卡为主力卡的用户，比如我。</p><span id="more"></span><h2 id="1-在余额宝出现之前，用于日常支出的钱都放在哪里？"><a href="#1-在余额宝出现之前，用于日常支出的钱都放在哪里？" class="headerlink" title="1 在余额宝出现之前，用于日常支出的钱都放在哪里？"></a>1 在余额宝出现之前，用于日常支出的钱都放在哪里？</h2><p>无非三个选择：钱包、银行卡的活期账户、支付宝的余额。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/05.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/06.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/07.png"></div></div></div><p>这样看来，钱包和银行卡的活期账户明显是更优的选择，因为</p><ul><li>如果场景不支持扫码，可以用钱包中的现金，或者 POS 机刷银行卡支付。</li><li>如果场景支持扫码，可以在支付宝中选择使用银行卡支付。</li></ul><p>更何况，放在银行卡里，还有聊胜于无的利息收入，放在支付宝余额里，就真的只是放着而已。</p><p>所以，<strong>用户好像没有什么动力，特地把银行卡里的钱转到支付宝里。</strong></p><h2 id="2-余额宝解决了什么痛点？"><a href="#2-余额宝解决了什么痛点？" class="headerlink" title="2 余额宝解决了什么痛点？"></a>2 余额宝解决了什么痛点？</h2><h3 id="2-1-高收益率"><a href="#2-1-高收益率" class="headerlink" title="2.1 高收益率"></a>2.1 高收益率</h3><p>众所周知，余额宝本质上属于货币基金。</p><blockquote><p>货币基金的运作方式可以简单理解为，基金将用户的钱集中起来，去跟银行谈一个利息较高的大额存款，再将利息作为收益返还给用户。</p></blockquote><p>好，这就为余额宝带来了第一个极具吸引力的特性：<strong>我把钱放在余额宝里，是有收益的，而且收益远高于银行卡的活期利息。</strong></p><div class="note info"><p>热知识：2014 年，余额宝的七日年化曾高达 6.76%，万份收益 1.8 元左右。</p></div><p>但是，用户还有个小问题：我为啥不选择其他货币基金？</p><h3 id="2-2-随时支取"><a href="#2-2-随时支取" class="headerlink" title="2.2 随时支取"></a>2.2 随时支取</h3><p>我们都知道，余额宝可以用于扫码支付、淘宝购物。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/08.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/09.png"></div></div></div><p>其支撑就在于，不同于当时的其他货币基金，余额宝提供了 T+0 的快速赎回方式。</p><p>好，第二个极具吸引力的特性向我们走来：<strong>我把钱放在余额宝里，24 小时均可取出，几分钟内到账。</strong></p><p>如今，众多「宝宝」类产品，比如天天基金的活期宝，其背后的货币基金也可以实现 T+0，但是无法打通消费场景，这是来自于支付宝的降维打击。</p><h2 id="3-余额宝还有什么缺点？"><a href="#3-余额宝还有什么缺点？" class="headerlink" title="3 余额宝还有什么缺点？"></a>3 余额宝还有什么缺点？</h2><h3 id="3-1-收益率不断下滑"><a href="#3-1-收益率不断下滑" class="headerlink" title="3.1 收益率不断下滑"></a>3.1 收益率不断下滑</h3><p>我不是经济专家，无法准确给出收益率下滑的原因。</p><p>但是对于一个用户而言，这就让我把钱转到余额宝里的动力越来越低。</p><div class="note warning"><p>内心 OS：每天就那么点收益，何必费那个劲呢？</p></div><h3 id="3-2-资金分散，不便管理"><a href="#3-2-资金分散，不便管理" class="headerlink" title="3.2 资金分散，不便管理"></a>3.2 资金分散，不便管理</h3><p>这实际上并不是余额宝的缺点，而是支付宝和微信支付二分天下带来的问题。</p><p>对于日常收支、投资理财，我有非常清晰的记录和规划。我每月初都会花十几分钟的时间整理一个表格，上面清晰地记录着我的每一分钱都放在什么地方，同时根据现状做出调整和规划。</p><p>具体到用于日常支出的短期闲置现金，我一般会在余额宝和零钱通分别放 5K 整。这样的话，下个月初我就能根据剩多少钱，快速算出上个月的支出。如果有异常，再去查看账单明细，看看是什么事情花费较多，有没有可优化的空间。</p><p>虽然管理两处也不是什么特别麻烦的事情，但是如果能合为一处岂不快哉。</p><h2 id="4-为什么推荐朝朝宝？"><a href="#4-为什么推荐朝朝宝？" class="headerlink" title="4 为什么推荐朝朝宝？"></a>4 为什么推荐朝朝宝？</h2><p>对于我而言，朝朝宝完美解决了上面两个缺点。</p><h3 id="4-1-收益方面"><a href="#4-1-收益方面" class="headerlink" title="4.1 收益方面"></a>4.1 收益方面</h3><p>朝朝宝的七日年化高达 3.10%，万分收益 0.8 元左右。</p><div class="note warning"><p>作为对比，支付宝的七日年化只有 2.12%，万份收益 0.5 元左右。</p></div><p>这一点主要得益于<strong>朝朝宝背后并不是货币基金，而是五款风险评级均为 R1 的招行代销理财产品，</strong>在收益较高的同时也保证了资金的安全性。</p><blockquote><p>其中一款代销理财细节可以看官网资料：<a href="http://www.cmbchina.com/cfweb/personal/saproductdetail.aspx?saaCod=D07&funCod=8920">招银理财招赢聚宝盆 1 号现金管理类理财计划</a></p></blockquote><p>当然，收益率会不会像余额宝一样下滑，还需要持续观察，至少现在是高的对吧。</p><h3 id="4-2-管理方面"><a href="#4-2-管理方面" class="headerlink" title="4.2 管理方面"></a>4.2 管理方面</h3><p>朝朝宝支持支付宝支付，微信支付，银行转账，ATM 取款，还信用卡、花呗和贷款，购买银行理财和基金等，如果不出意外的话，应该还支持 Apple Pay 或者其他 Pay（我没试过）。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/10.png"></p><p>我只需要每月初在朝朝宝里放 1W 整，不管是支付宝还是微信支付，在扫码后选择使用银行卡支付即可。</p><p>这样的话，我就可以集中管理生活中各个方面的支出情况，我直接大呼过瘾。</p><div class="note warning"><p>需要注意的是，朝朝宝最多可转入 5W，每日也最多可转出 5W，对于日常支出较多的人来说可能不是很友好。</p></div><h2 id="5-后记"><a href="#5-后记" class="headerlink" title="5 后记"></a>5 后记</h2><p>这不是朝朝宝的软文（招行也不至于卑贱到来找我写软文），单纯只是我想分享一下好的理财产品。不构成理财建议，但是如果对你有所帮助，那就再好不过了。也祝自己早日暴富！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当我们看向历史的后视镜，2013 年面世的余额宝确实是一款影响十分深远的产品，它永久地改变了人们对于短期闲置现金的处置方式，更进一步地推动了无现金支付的发展。邯郸学步的零钱通后来也不断壮大，和余额宝一起，成为人们活期理财的首要选择。&lt;/p&gt;
&lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot;&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/03.png&quot;&gt;&lt;/div&gt;&lt;div class=&quot;group-picture-column&quot;&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/04.png&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;达成这一切，靠的便是直击用户痛点的两个特性：&lt;strong&gt;高收益率&lt;/strong&gt;和&lt;strong&gt;随时支取&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然而，眼看着互联网金融的繁荣发展，银行自然不能坐以待毙。&lt;/p&gt;
&lt;p&gt;招商银行推出的&lt;strong&gt;朝朝宝&lt;/strong&gt;便是这样一款狙击余额宝/零钱通的活期理财产品，极大地吸引了以招商银行卡为主力卡的用户，比如我。&lt;/p&gt;</summary>
    
    
    
    <category term="A2 - 投资" scheme="https://progcz.com/categories/A2-%E6%8A%95%E8%B5%84/"/>
    
    <category term="B1 - 银行理财" scheme="https://progcz.com/categories/A2-%E6%8A%95%E8%B5%84/B1-%E9%93%B6%E8%A1%8C%E7%90%86%E8%B4%A2/"/>
    
    
    <category term="招商银行" scheme="https://progcz.com/tags/%E6%8B%9B%E5%95%86%E9%93%B6%E8%A1%8C/"/>
    
    <category term="朝朝宝" scheme="https://progcz.com/tags/%E6%9C%9D%E6%9C%9D%E5%AE%9D/"/>
    
    <category term="余额宝" scheme="https://progcz.com/tags/%E4%BD%99%E9%A2%9D%E5%AE%9D/"/>
    
    <category term="零钱通" scheme="https://progcz.com/tags/%E9%9B%B6%E9%92%B1%E9%80%9A/"/>
    
    <category term="活期理财" scheme="https://progcz.com/tags/%E6%B4%BB%E6%9C%9F%E7%90%86%E8%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>从一封邮件谈谈我为什么不再想要评论系统</title>
    <link href="https://progcz.com/posts/1620608429/"/>
    <id>https://progcz.com/posts/1620608429/</id>
    <published>2021-05-10T01:01:20.000Z</published>
    <updated>2021-05-11T15:08:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>在重建站点的过程中，我曾经挣扎过要不要重设评论系统。</p><p>基础设施方面，适用于静态博客的各类评论系统都已经发展得比较成熟，比如独立服务的 <a href="https://blog.disqus.com/">Disqus</a>、依赖 GitHub Issues 的 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 和 <a href="https://github.com/utterance/utterances">Utterances</a>、依赖 LeanCloud 等的 <a href="https://github.com/xCss/Valine">Valine</a> 和 <a href="https://github.com/lizheming/waline">Waline</a>，选择颇多。</p><p>对于博客而言，评论系统可以让读者更方便地给出反馈，和作者交流彼此的观点和看法。</p><p>但是如你所见，我还是没有重设评论系统。</p><p>真正促使我放弃的，根本原因是<strong>互联网中随处可见的，无知、无营养甚至充满恶意的评论。</strong></p><p>而导火索则是这样一封邮件：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/01.png"></p><span id="more"></span><h2 id="1-事情起因（我的猜测）"><a href="#1-事情起因（我的猜测）" class="headerlink" title="1 事情起因（我的猜测）"></a>1 事情起因（我的猜测）</h2><p>这位朋友曾经使用 Cloudflare 搭过 Google Scholar 的镜像网站，突然发现不可用了，于是在 Google 搜索相关信息，看到了我一年前写的这篇文章：<a href="https://progcz.com/posts/use-cf-workers-build-google-and-github-mirrors/">使用 Cloudflare Workers 搭建 Google 和 GitHub 镜像网站</a>，认为是我的分享和传播导致了 Cloudflare 不可用，怒不可遏的同时又看到了我的邮箱，于是就有了上面那封邮件。</p><h2 id="2-我的看法"><a href="#2-我的看法" class="headerlink" title="2 我的看法"></a>2 我的看法</h2><p>这位朋友的核心观点在于：<strong>这样的知识，自己知道就好了，不要拿出来分享。</strong></p><p>可以说是非常自私了，而且多少有点逻辑的人都能看出这里面的问题：<strong>如果每个人都不分享这样的知识，那这位朋友又是从哪里获取到的呢？靠自己顿悟吗？</strong></p><p>我有时候也会很纳闷，为什么这么简单的道理，都没有出现在这类朋友的脑子里。</p><p>如果是其他网民，我可能可以理解。因为根据<a href="https://finance.sina.com.cn/tech/2020-09-29/doc-iivhuipp7144597.shtml">这篇文章</a>，2020 年网民的规模达 9.40 亿，其中学历达到本科及以上的仅为 8.8％。没有经历过高等教育的话，认知是会受到一定限制。</p><p>但是这位朋友提到了谷歌学术，说明至少已经到了高等教育的阶段，却依然这么狭隘，让我匪夷所思。</p><p>当然，这种情况不止发生了一次，在评论量较大的博客、在我认为社区氛围很好的 B 站和豆瓣，我都会频繁地看到这类评论，不然我也不会对互联网的评论环境如此失望。</p><h2 id="3-我的回复"><a href="#3-我的回复" class="headerlink" title="3 我的回复"></a>3 我的回复</h2><p>尽管无法理解，但我还是出于本能的 defence，回复了这封邮件：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/02.png"></p><p>看，这也是我不想要评论系统的原因之一，我不想为了这种事情 defence 啊。</p><p>人生已经很累了，照顾好自己的情绪都是一件非常困难的事情，就更不想陷入这种本不该存在的争论之中了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在重建站点的过程中，我曾经挣扎过要不要重设评论系统。&lt;/p&gt;
&lt;p&gt;基础设施方面，适用于静态博客的各类评论系统都已经发展得比较成熟，比如独立服务的 &lt;a href=&quot;https://blog.disqus.com/&quot;&gt;Disqus&lt;/a&gt;、依赖 GitHub Issues 的 &lt;a href=&quot;https://github.com/gitalk/gitalk&quot;&gt;Gitalk&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/utterance/utterances&quot;&gt;Utterances&lt;/a&gt;、依赖 LeanCloud 等的 &lt;a href=&quot;https://github.com/xCss/Valine&quot;&gt;Valine&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/lizheming/waline&quot;&gt;Waline&lt;/a&gt;，选择颇多。&lt;/p&gt;
&lt;p&gt;对于博客而言，评论系统可以让读者更方便地给出反馈，和作者交流彼此的观点和看法。&lt;/p&gt;
&lt;p&gt;但是如你所见，我还是没有重设评论系统。&lt;/p&gt;
&lt;p&gt;真正促使我放弃的，根本原因是&lt;strong&gt;互联网中随处可见的，无知、无营养甚至充满恶意的评论。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而导火索则是这样一封邮件：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/01.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="A1 - 生活" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB/"/>
    
    <category term="B2 - 折腾" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB/B2-%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="博客" scheme="https://progcz.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>谈谈 Hexo 的主题现状以及我对 NexT 的细节改造</title>
    <link href="https://progcz.com/posts/1619784301/"/>
    <id>https://progcz.com/posts/1619784301/</id>
    <published>2021-04-30T15:05:45.000Z</published>
    <updated>2021-04-30T15:05:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>上次发文还是三月初，中间停更了这么久，主要原因在于，之前我对主题源码进行了侵入式的改造，难以升级享受最新的版本特性，于是我就想要重建这个博客站点，兼顾可升级和可改造。</p><p>那我就想，既然要重建，何不换个主题试一下？果然，试试就逝世。</p><span id="more"></span><h2 id="1-Hexo-主题"><a href="#1-Hexo-主题" class="headerlink" title="1 Hexo 主题"></a>1 Hexo 主题</h2><p>在静态博客框架中，Hexo 向来是最受青睐的选择，没有之一。</p><p>Jekyll 作为 GitHub 官方支持的框架，可以直接托管源码而无需手动生成静态网页，Hugo 借助 Go 语言的性能优势，号称全世界最快的框架，然而这两者都有一点远落后于 Hexo，那就是最为关键的<strong>主题生态</strong>。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/01.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/02.png"></div></div></div><p>作为一个想搭博客的人来说，审美能对自己胃口才是头等大事，所以主题生态只有枝繁叶茂才能留住众口难调的用户。</p><p>Hexo 使用 Node.js 开发，从语言层面上就吸引了大批优秀的前端工程师，精美主题可以说是层出不穷。</p><p>当然再好的主题也必然有令人不甚满意的地方，这里就把 Butterfly 单拎出来说说问题。</p><h3 id="1-1-Butterfly"><a href="#1-1-Butterfly" class="headerlink" title="1.1 Butterfly"></a>1.1 <a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></h3><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/03.png"></p><p>简洁好看，尤其是首屏的视觉效果，足够吸引眼球。这也是我刚开始重建的第一选择。</p><p>但是这个主题，说得严重一点，「金玉其外，败絮其中。」</p><p>我相信，任何用过 Butterfly 的人，一定会被 <code>_config.butterfly.yml</code> 中混乱的配置给搞得心烦意乱，举个栗子：</p><p>配置中有一段是关于网站默认的展示模式，可以选择明亮/暗黑：</p><figure class="highlight yaml"><figcaption><span>code</span><a href="https://github.com/jerryc127/hexo-theme-butterfly/blob/dev/_config.yml">_config.yml</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Default display mode (網站默認的顯示模式)</span></span><br><span class="line"><span class="comment"># light (default) / dark</span></span><br><span class="line"><span class="attr">display_mode:</span> <span class="string">light</span></span><br></pre></td></tr></table></figure><p>然而在后面又出现了一段是关于暗黑模式，可以选择是否开启：</p><figure class="highlight yaml"><figcaption><span>code</span><a href="https://github.com/jerryc127/hexo-theme-butterfly/blob/dev/_config.yml">_config.yml</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># dark mode</span></span><br><span class="line"><span class="attr">darkmode:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Toggle Button to switch dark/light mode</span></span><br><span class="line">    <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Switch dark/light mode automatically (自動切換 dark mode和 light mode)</span></span><br><span class="line">    <span class="comment"># autoChangeMode: 1  Following System Settings, if the system doesn&#x27;t support dark mode, it will switch dark mode between 6 pm to 6 am</span></span><br><span class="line">    <span class="comment"># autoChangeMode: 2  Switch dark mode between 6 pm to 6 am</span></span><br><span class="line">    <span class="comment"># autoChangeMode: false</span></span><br><span class="line">    <span class="attr">autoChangeMode:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这让我不禁想问：如果我在前面选了默认明亮模式，后面又选了开启暗黑模式，那主题到底是展现哪一种？只有试过之后才能知道，无疑增加了理解成本。</p><p>类似的问题还有很多，就不赘述了。总之这个配置文件折磨了我很久，最终不得不放弃。</p><div class="note warning"><p>不管怎样，我还是很尊重主题作者的，提供免费开源的主题给大家用，本身就非常值得敬佩。但还是那句话，「若批评不自由，则赞美无意义。」</p><p><del>而且感觉主题作者是个暴躁老哥，惹不太起。</del></p></div><h2 id="2-NexT-改造"><a href="#2-NexT-改造" class="headerlink" title="2 NexT 改造"></a>2 NexT 改造</h2><p>当然，我换过不止 Butterfly 一个主题，然而其他主题即便没有混乱的配置文件，也存在大量优化不到位的细节，所以兜兜转转又回到了 NexT 的怀抱。</p><h3 id="2-1-基本配置"><a href="#2-1-基本配置" class="headerlink" title="2.1 基本配置"></a>2.1 基本配置</h3><p><code>_config.yml</code> 和 <code>_config.next.yml</code> 中的配置基本都体现在 <a href="https://github.com/ProgCZ/progcz.github.io/commit/f3cdd681835389803f187024e06124960f48d251">commit f3cdd68</a> 中，不再赘述。</p><h3 id="2-2-特殊改造"><a href="#2-2-特殊改造" class="headerlink" title="2.2 特殊改造"></a>2.2 特殊改造</h3><p>特殊改造基本都体现在 <a href="https://github.com/ProgCZ/progcz.github.io/commit/3d56b383f78c1b260edb668ff7ed8e0d6f5232fd">commit 3d56b38</a> 中，没有污染博客源码，只是通过自定义的 js 和 css 来实现。</p><ol><li><p>替换站点标题中不规范的部分</p><p> 如果足够细心的话，你就会发现，在每个分类页面中，标题中的冒号都是英文冒号，不符合中文排版规范：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/04.png"></p><p> 替换后：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/05.png"></p></li><li><p>替换归档页面中不规范的部分</p><p> 归档页面中，表达冗余，且英文叹号也不符合中文排版规范：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/06.png"></p><p> 替换后：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/07.png"></p></li><li><p>替换文章信息中不规范的部分</p><p> 这个单纯是我看中文逗号不顺眼，不能表达分类之间的层级关系：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/08.png"></p><p> 替换后：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/09.png"></p></li><li><p>替换页脚中不规范的部分</p><p> 这个也单纯是我看 copyright 字符不顺眼，有点矮：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/10.png"></p><p> 替换后：</p><p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/11.png"></p></li><li><p>动画速度调整至 0.3s</p> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.animated</span> &#123;</span><br><span class="line">    <span class="attribute">animation-duration</span>: <span class="number">0.3s</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>侧边栏字体从 <code>font-size-smaller</code> 调大至 <code>font-size-small</code></p> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu-item</span> &#123;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: $font-size-small;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.links-of-author</span> &#123;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: $font-size-small;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.site-state-item-name</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: $font-size-small;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-后记"><a href="#3-后记" class="headerlink" title="3 后记"></a>3 后记</h2><p>折腾告一段落，静下心来好好写些文章吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上次发文还是三月初，中间停更了这么久，主要原因在于，之前我对主题源码进行了侵入式的改造，难以升级享受最新的版本特性，于是我就想要重建这个博客站点，兼顾可升级和可改造。&lt;/p&gt;
&lt;p&gt;那我就想，既然要重建，何不换个主题试一下？果然，试试就逝世。&lt;/p&gt;</summary>
    
    
    
    <category term="A1 - 生活" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB/"/>
    
    <category term="B2 - 折腾" scheme="https://progcz.com/categories/A1-%E7%94%9F%E6%B4%BB/B2-%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="博客" scheme="https://progcz.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="Hexo" scheme="https://progcz.com/tags/Hexo/"/>
    
    <category term="NexT" scheme="https://progcz.com/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Problem 3 - Longest Substring Without Repeating Characters</title>
    <link href="https://progcz.com/posts/leetcode-problem-longest-substring-without-repeating-characters/"/>
    <id>https://progcz.com/posts/leetcode-problem-longest-substring-without-repeating-characters/</id>
    <published>2021-02-26T01:08:46.000Z</published>
    <updated>2021-03-03T00:07:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a></p><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定字符串，输出最长不重复子串的长度。</p><span id="more"></span><h2 id="解法一：滑动窗口"><a href="#解法一：滑动窗口" class="headerlink" title="解法一：滑动窗口"></a>解法一：滑动窗口</h2><p>借助 <code>hash_map</code>，建立起<strong>子串中</strong>字符和出现次数的映射，如果 <code>hash_map</code> 中所有字符的出现次数均不大于 <code>1</code>，那么就说明当前子串为不重复子串。</p><p>滑动窗口的左右边界分别为 <code>beg</code> 和 <code>end</code>（均初始化为 <code>0</code>），</p><ol><li><p>在遍历 <code>hash_map</code> 后判断当前子串为不重复子串的情况下，<code>end</code> 不断右移，同时将 <code>hash_map</code> 中对应字符的出现次数 <code>+1</code>。</p></li><li><p>上述 <code>end</code> 的右移停止，说明 <code>end</code> 到达字符串末尾或者当前子串为重复子串，则记录不重复子串的最大长度。</p></li><li><p>在遍历 <code>hash_map</code> 后判断当前子串为重复子串的情况下，<code>beg</code> 不断右移，同时将 <code>hash_map</code> 中对应字符的出现次数 <code>-1</code>。</p></li><li><p>上述 <code>beg</code> 的右移停止，说明 <code>beg</code> 到达 <code>end</code> 或者当前子串不为重复子串，则重复整个流程。</p></li></ol><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(n)</code>（不太确定）</p></li><li><p>时间：<code>O(n)</code></p></li></ul><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; um;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> beg = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; <span class="built_in">helper</span>(um)) &#123;</span><br><span class="line">                um[s[end++]-<span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> len = (end == n &amp;&amp; <span class="built_in">helper</span>(um)) ?</span><br><span class="line">                (end - beg) : (end - beg - <span class="number">1</span>);</span><br><span class="line">            res = <span class="built_in">max</span>(res, len);</span><br><span class="line">            <span class="keyword">while</span> (beg &lt;= end &amp;&amp; !<span class="built_in">helper</span>(um)) &#123;</span><br><span class="line">                um[s[beg++]-<span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="keyword">const</span> unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; um)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = um.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (iter != um.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;second &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++iter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：记旧账"><a href="#解法二：记旧账" class="headerlink" title="解法二：记旧账"></a>解法二：记旧账</h2><p>对于当前字符来说，往前一个一个地推字符，如果某个字符出现了两次，那么该字符前一次出现的下标，一定是最长不重复子串起点的下标减一。</p><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间复杂度：<code>O(1)</code></p></li><li><p>时间复杂度：<code>O(n)</code></p></li></ul><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><blockquote><p>参考：<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1730/Shortest-O(n)-DP-solution-with-explanations">https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1730/Shortest-O(n)-DP-solution-with-explanations</a></p></blockquote><div class="note info"><p>因为 <code>char</code> 类型是 8 位，枚举值共有 256 种，所以可以使用 <code>array&lt;int, 256&gt;</code> 代替 <code>unordered_map&lt;char, int&gt;</code> 来实现字符和下标之间的映射。</p></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        array&lt;<span class="keyword">int</span>, 256&gt; arr; arr.<span class="built_in">fill</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, loc = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 等号右边的 `loc`，就是解法中提到的「前一次出现的下标」</span></span><br><span class="line">            <span class="comment">// 等号右边的 `arr[s[i]]`，就是当前字符的「前一次出现的下标」</span></span><br><span class="line">            <span class="comment">// 两者取最大，更新 `loc`，同时 `loc` 也就是：</span></span><br><span class="line">            <span class="comment">// 对于当前字符来说的，最长不重复子串起点的下标减一</span></span><br><span class="line">            loc = <span class="built_in">max</span>(loc, arr[s[i]]);</span><br><span class="line">            <span class="comment">// 计算：对于当前字符来说的，最长不重复子串的长度</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, i-loc);</span><br><span class="line">            <span class="comment">// 更新 `arr[s[i]]`</span></span><br><span class="line">            arr[s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-substring-without-repeating-characters/&quot;&gt;https://leetcode.com/problems/longest-substring-without-repeating-characters/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h3&gt;&lt;p&gt;给定字符串，输出最长不重复子串的长度。&lt;/p&gt;</summary>
    
    
    
    <category term="A4 - LeetCode" scheme="https://progcz.com/categories/A4-LeetCode/"/>
    
    <category term="B1 - LeetCode Problems" scheme="https://progcz.com/categories/A4-LeetCode/B1-LeetCode-Problems/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="String" scheme="https://progcz.com/tags/String/"/>
    
    <category term="Hash Table" scheme="https://progcz.com/tags/Hash-Table/"/>
    
    <category term="Two Pointers" scheme="https://progcz.com/tags/Two-Pointers/"/>
    
    <category term="Sliding Window" scheme="https://progcz.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Problem 2 - Add Two Numbers</title>
    <link href="https://progcz.com/posts/leetcode-problem-add-two-numbers/"/>
    <id>https://progcz.com/posts/leetcode-problem-add-two-numbers/</id>
    <published>2021-02-24T15:54:42.000Z</published>
    <updated>2021-02-26T00:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/add-two-numbers/">https://leetcode.com/problems/add-two-numbers/</a></p><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>将两个数字的每一位，逆序地拆成两个链表 <code>l1</code> 和 <code>l2</code>，计算这两个数字的和，结果以同样顺序的链表表示。</p><span id="more"></span><h2 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h2><p>递归遍历两个输入链表，对应节点相加，<code>%10</code> 的值存入输出链表的对应节点，<code>/10</code> 的值存入输出链表的下一节点。</p><p>边界条件：两个输入链表的对应节点都为空指针。</p><div class="note info"><p>在边界条件下，需要根据下一节点的值是否为 0 而决定是否抛弃该下一节点。为了实现这一点，同时保持代码的 <code>neat</code> 性，传入递归函数的输出链表的对应节点，需要自带下一节点，这就是 C++ 实现中 <code>new ListNode(0, new ListNode(0))</code> 的由来。</p></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(n)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* root = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">helper</span>(l1, l2, root);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(ListNode* l1, ListNode* l2, ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1 &amp;&amp; !l2) &#123;</span><br><span class="line">            node-&gt;next = node-&gt;next-&gt;val ? node-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        <span class="keyword">int</span> sum = node-&gt;val +</span><br><span class="line">            (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>);</span><br><span class="line">        node-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">        node-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum/<span class="number">10</span>);</span><br><span class="line">        l1 = l1 ? l1-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        l2 = l2 ? l2-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(l1, l2, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：循环"><a href="#解法二：循环" class="headerlink" title="解法二：循环"></a>解法二：循环</h2><p>思路基本上与<a href="#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9A%E9%80%92%E5%BD%92">解法一</a>保持一致，只是将递归形式改为循环形式，同时写法上更加 neat。</p><blockquote><p>参考：<a href="https://leetcode.com/problems/add-two-numbers/discuss/997/c++-Sharing-my-11-line-c++-solution-can-someone-make-it-even-more-concise">https://leetcode.com/problems/add-two-numbers/discuss/997/c++-Sharing-my-11-line-c++-solution-can-someone-make-it-even-more-concise</a></p></blockquote><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(n)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode root(0), *node = &amp;root;</span><br><span class="line">        <span class="keyword">int</span> extra = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || extra) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = extra + </span><br><span class="line">                (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>);</span><br><span class="line">            extra = sum/<span class="number">10</span>;</span><br><span class="line">            node-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            l1 = l1 ? l1-&gt;next : l1;</span><br><span class="line">            l2 = l2 ? l2-&gt;next : l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/add-two-numbers/&quot;&gt;https://leetcode.com/problems/add-two-numbers/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h3&gt;&lt;p&gt;将两个数字的每一位，逆序地拆成两个链表 &lt;code&gt;l1&lt;/code&gt; 和 &lt;code&gt;l2&lt;/code&gt;，计算这两个数字的和，结果以同样顺序的链表表示。&lt;/p&gt;</summary>
    
    
    
    <category term="A4 - LeetCode" scheme="https://progcz.com/categories/A4-LeetCode/"/>
    
    <category term="B1 - LeetCode Problems" scheme="https://progcz.com/categories/A4-LeetCode/B1-LeetCode-Problems/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Linked List" scheme="https://progcz.com/tags/Linked-List/"/>
    
    <category term="Math" scheme="https://progcz.com/tags/Math/"/>
    
    <category term="Recursion" scheme="https://progcz.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Problem 1 - Two Sum</title>
    <link href="https://progcz.com/posts/leetcode-problem-two-sum/"/>
    <id>https://progcz.com/posts/leetcode-problem-two-sum/</id>
    <published>2021-02-17T15:48:43.000Z</published>
    <updated>2021-02-19T15:49:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/two-sum/">https://leetcode.com/problems/two-sum/</a></p><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定数组 <code>nums</code> 和数字 <code>target</code>，要求在 <code>nums</code> 中找到两个数字，和为 <code>target</code>，返回这两个数字的下标。</p><p>保证有且只有一个解，而且同一个数字不能用两次。</p><span id="more"></span><h2 id="解法一：两层循环，暴力破解"><a href="#解法一：两层循环，暴力破解" class="headerlink" title="解法一：两层循环，暴力破解"></a>解法一：两层循环，暴力破解</h2><p>两层循环，遍历所有可能的数字组合，找到则返回下标。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(1)</code></p></li><li><p>时间：<code>O(n^2)</code></p></li></ul><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：借助-hash-map，用空间换时间"><a href="#解法二：借助-hash-map，用空间换时间" class="headerlink" title="解法二：借助 hash_map，用空间换时间"></a>解法二：借助 <code>hash_map</code>，用空间换时间</h2><p>既可以使用两次循环：</p><ul><li><p>第一次循环完成「记录」：借助 <code>hash_map</code>，建立数字 <code>target-nums[i]</code> 和下标 <code>i</code> 之间的映射。</p></li><li><p>第二次循环进行「查询」：如果数字 <code>nums[i]</code> 存在于 <code>hash_map</code> 中，而且不是同一数字（下标不同），说明可以「配对」，则返回该数字下标和 <code>hash_map</code> 中记录的另一数字下标。</p></li></ul><p>也可以使用单次循环：</p><ul><li>单次循环合并「记录」和「查询」：如果数字 <code>nums[i]</code> 存在于 <code>hash_map</code> 中，说明可以「配对」，则返回该数字下标和 <code>hash_map</code> 中记录的另一数字下标，否则建立数字 <code>target-nums[i]</code> 和下标 <code>i</code> 之间的映射。</li></ul><blockquote><p>单次循环参考：<a href="https://leetcode.com/problems/two-sum/discuss/13/Accepted-C++-O(n)-Solution/263">https://leetcode.com/problems/two-sum/discuss/13/Accepted-C++-O(n)-Solution/263</a></p></blockquote><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(n)</code>（不太确定）</p></li><li><p>时间：<code>O(n)</code></p><ul><li><code>hash_map</code> 插入、查询、删除的操作，时间复杂度均为 <code>O(1)</code>。</li></ul></li></ul><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><p>两次循环：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; um = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            um[target-nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (um.<span class="built_in">find</span>(nums[i]) != um.<span class="built_in">end</span>() &amp;&amp;</span><br><span class="line">                um[nums[i]] != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;um[nums[i]], i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>单次循环：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; um;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (um.<span class="built_in">find</span>(nums[i]) != um.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;um[nums[i]], i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            um[target-nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/two-sum/&quot;&gt;https://leetcode.com/problems/two-sum/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h3&gt;&lt;p&gt;给定数组 &lt;code&gt;nums&lt;/code&gt; 和数字 &lt;code&gt;target&lt;/code&gt;，要求在 &lt;code&gt;nums&lt;/code&gt; 中找到两个数字，和为 &lt;code&gt;target&lt;/code&gt;，返回这两个数字的下标。&lt;/p&gt;
&lt;p&gt;保证有且只有一个解，而且同一个数字不能用两次。&lt;/p&gt;</summary>
    
    
    
    <category term="A4 - LeetCode" scheme="https://progcz.com/categories/A4-LeetCode/"/>
    
    <category term="B1 - LeetCode Problems" scheme="https://progcz.com/categories/A4-LeetCode/B1-LeetCode-Problems/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Array" scheme="https://progcz.com/tags/Array/"/>
    
    <category term="Hash Table" scheme="https://progcz.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>充满仪式感的「全年总结」和不太可能坚持下去的「新年计划」</title>
    <link href="https://progcz.com/posts/summary-for-past-year-and-plan-for-new-year/"/>
    <id>https://progcz.com/posts/summary-for-past-year-and-plan-for-new-year/</id>
    <published>2021-01-02T12:34:35.000Z</published>
    <updated>2021-01-02T12:34:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>即使新建好了文档，我依然不知道到底该写些什么，但是「写」这个念头就像只怎么也赶不走的乌鸦，一直在我的头顶盘旋。</p><p>也许确实是因为仪式感吧，<strong>每到了辞旧迎新的时候，总该有些「落在纸面」的文字，先跟过去的一年和解，再把自己交代给未来的一年。</strong></p><p>也罢，就让我这个记忆力和行动力都逐渐退化的人，来一场「全年总结」和「新年计划」吧！</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/01.jpg" style="zoom:100%"/><span id="more"></span><h2 id="1-全年总结"><a href="#1-全年总结" class="headerlink" title="1 全年总结"></a>1 全年总结</h2><h3 id="1-1-失去的五个月"><a href="#1-1-失去的五个月" class="headerlink" title="1.1 失去的五个月"></a>1.1 失去的五个月</h3><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/02.jpg" style="zoom:100%"/><p>但凡回顾 2020，疫情是怎么都绕不开的话题。</p><p>不论性别，不论国籍，不论贫穷或富有，不论疾病或健康，只要你还是这颗蓝色星球上的原住民，或多或少都会受到疫情的影响，唯一的区别就在于这个「或多或少」。</p><p>非常幸运，也非常惭愧，我是「或少」中的一员。</p><p>不管是磕磕绊绊但还是顺利完成了的学位答辩，还是在家只吃不动而逐渐狂妄的体重涨幅，在这场全人类都无法幸免的灾难面前，看上去都是小事。</p><p>因此，我始终对在疫情中离开人世的生命感到惋惜，他们一定也在 2020 年伊始时，怀揣着对新年的希望，如今归于尘土；我也始终对在疫情中奋战在一线的医护人员保持敬意，他们以血肉之躯，构筑起保护我们的钢铁长城。</p><div class="note warning"><p>写得越来越像高考作文了。</p><p>Whatever, it’s just the way how i was raised and educated.</p></div><p>不是超级英雄，<strong>只能保护好自己，照顾好家人，足够了。</strong></p><h3 id="1-2-十九年寒窗"><a href="#1-2-十九年寒窗" class="headerlink" title="1.2 十九年寒窗"></a>1.2 十九年寒窗</h3><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/03.jpg" style="zoom:100%"/><p>毕业算是改变人生的事情当中，意外指数最低的事情了吧。</p><p>在这种意义下，与其说是改变人生，<strong>不如说是人生早就被安排成了列车的时刻表，毕业这件事情就在单线轨道的某个站点上等着，没有丝毫悬念。</strong></p><p>虽然，我今年所面临的毕业，与以往的毕业不尽相同：</p><ul><li><p>以往的毕业，从学校到学校，换了环境而已，依然是衣食无忧的学生，终极目标不过是分数、绩点和排名。</p></li><li><p>今年的毕业，从学校到公司，真正意义上的经济独立，终极目标切换成房子、车子和存款。</p></li></ul><p>当然，还是很感谢曾经作为学生的自己，至少为我打好了阶级跃迁的基础，在人生这一新的阶段能多抢跑几秒钟。</p><h3 id="1-3-职场与人生"><a href="#1-3-职场与人生" class="headerlink" title="1.3 职场与人生"></a>1.3 职场与人生</h3><p>互联网大厂的程序员工作，一言以蔽之：节奏快，工作忙，身体累。</p><p>比起初入职场的感想，我更想探讨的是，在人生意义这个问题上的心态转变。</p><p>这是个老生常谈的哲学命题，我明白。但我还是想说说自己的理解。</p><p>过去的二十几年，从我记事开始，我就一直在为别人而活。</p><p>说起来非常简单的生活：作为学生，考试考个好成绩；作为儿女，听长辈的话。这样，父母就会很开心，长辈就会称赞我（不管是不是虚情假意），同学也会尊重我（即便是以对待书呆子的态度）。</p><p>我好像从来没想过，自己想要什么。</p><p>或者说，是周围的人告诉我的「我想要的」：努力学习，努力赚钱，有套自己的房子，有个幸福的家庭。</p><p>直到我开始问我自己：然后呢？这一切之后呢？从生到死，人这一生到底是为了什么呢？</p><p>过去的一年里，我反复地思考人生的意义，在上下班通勤的路上，在漫长而枯燥的旅途中，在每个放纵自己而熬到很困的深夜里。</p><p>而每次我都只能得到同一个答案：<strong>人生的意义是为了开心，为了愉悦的体验，为了舒适的生活。</strong></p><p>又是个老生常谈的答案，我明白。但这次，我是真的相信它了。</p><h2 id="2-新年计划"><a href="#2-新年计划" class="headerlink" title="2 新年计划"></a>2 新年计划</h2><h3 id="2-1-工作"><a href="#2-1-工作" class="headerlink" title="2.1 工作"></a>2.1 工作</h3><p>无他，努力工作，赚钱买房。</p><div class="note warning"><p>但是要牢记的是，身体是革命的本钱！任何事情的达成都不能以牺牲身体健康为前提。</p></div><h3 id="2-2-读书"><a href="#2-2-读书" class="headerlink" title="2.2 读书"></a>2.2 读书</h3><p>在将 kindle 上未读的书目消灭至只有个位数之前，不再囤书了。</p><p>至于数量，不想做硬性要求，只求在有大块时间和舒适状态的时候，能想起来读书，而不是刷手机/看视频。</p><h3 id="2-3-按摩-健身"><a href="#2-3-按摩-健身" class="headerlink" title="2.3 按摩/健身"></a>2.3 按摩/健身</h3><p>每周二按摩，每周四健身。</p><h3 id="2-4-旅游"><a href="#2-4-旅游" class="headerlink" title="2.4 旅游"></a>2.4 旅游</h3><p>希望每年能有一次旅游，实际上 2021 的额度已经分给厦门了，毕竟厦大百年校庆，是时候回去看看了。</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/04.jpg" style="zoom:100%"/><hr><h2 id="3-番外"><a href="#3-番外" class="headerlink" title="3 番外"></a>3 番外</h2><p>新年第一天，去撸了猫猫狗狗，希望能把这份开心延续一整年吧。</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/05.jpg" style="zoom:100%"/>]]></content>
    
    
    <summary type="html">&lt;p&gt;即使新建好了文档，我依然不知道到底该写些什么，但是「写」这个念头就像只怎么也赶不走的乌鸦，一直在我的头顶盘旋。&lt;/p&gt;
&lt;p&gt;也许确实是因为仪式感吧，&lt;strong&gt;每到了辞旧迎新的时候，总该有些「落在纸面」的文字，先跟过去的一年和解，再把自己交代给未来的一年。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也罢，就让我这个记忆力和行动力都逐渐退化的人，来一场「全年总结」和「新年计划」吧！&lt;/p&gt;
&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/01.jpg&quot; style=&quot;zoom:100%&quot;/&gt;</summary>
    
    
    
    <category term="A0 - 总结与计划" scheme="https://progcz.com/categories/A0-%E6%80%BB%E7%BB%93%E4%B8%8E%E8%AE%A1%E5%88%92/"/>
    
    
    <category term="计划" scheme="https://progcz.com/tags/%E8%AE%A1%E5%88%92/"/>
    
    <category term="总结" scheme="https://progcz.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>2020 August LeetCoding Challenge - Week 2</title>
    <link href="https://progcz.com/posts/2020-august-leetcoding-challenge-week-2/"/>
    <id>https://progcz.com/posts/2020-august-leetcoding-challenge-week-2/</id>
    <published>2020-08-08T15:36:56.000Z</published>
    <updated>2020-08-16T02:42:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 八月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-August-LeetCoding-Challenge/">2020 August LeetCoding Challenge</a> 查看更多。</p><span id="more"></span><h2 id="August-8th-Path-Sum-III"><a href="#August-8th-Path-Sum-III" class="headerlink" title="August 8th: Path Sum III"></a>August 8th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/550/week-2-august-8th-august-14th/3417/">Path Sum III</a></h2><p>You are given a binary tree in which each node contains an integer value.</p><p>Find the number of paths that sum to a given value.</p><p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p><p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     &#x2F;  \</span><br><span class="line">    5   -3</span><br><span class="line">   &#x2F; \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用函数 <code>func</code> 对树进行深度优先搜索，对以 <code>node</code> 为起点且满足题目要求的路径进行计数。</p><p><code>pathSum(root-&gt;left, sum)</code> 和 <code>pathSum(root-&gt;right, sum)</code> 则是分别给左右节点一次「重新开始」的机会。</p><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(root, sum) + <span class="built_in">pathSum</span>(root-&gt;left, sum) + <span class="built_in">pathSum</span>(root-&gt;right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(TreeNode *node,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = node-&gt;val==sum ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="built_in">func</span>(node-&gt;left, sum-node-&gt;val) + <span class="built_in">func</span>(node-&gt;right, sum-node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>终究还是没能在工作日坚持下来，这个系列终止吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 八月挑战专题每日随缘更新，点击类别 &lt;a href=&quot;/categories/2020-August-LeetCoding-Challenge/&quot;&gt;2020 August LeetCoding Challenge&lt;/a&gt; 查看更多。&lt;/p&gt;</summary>
    
    
    
    <category term="A4 - LeetCode" scheme="https://progcz.com/categories/A4-LeetCode/"/>
    
    <category term="B4 - LeetCoding Challenge" scheme="https://progcz.com/categories/A4-LeetCode/B4-LeetCoding-Challenge/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="数据结构与算法" scheme="https://progcz.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Challenge" scheme="https://progcz.com/tags/Challenge/"/>
    
  </entry>
  
  <entry>
    <title>2020 August LeetCoding Challenge - Week 1</title>
    <link href="https://progcz.com/posts/2020-august-leetcoding-challenge-week-1/"/>
    <id>https://progcz.com/posts/2020-august-leetcoding-challenge-week-1/</id>
    <published>2020-08-01T07:37:02.000Z</published>
    <updated>2020-08-08T03:31:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 八月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-August-LeetCoding-Challenge/">2020 August LeetCoding Challenge</a> 查看更多。</p><span id="more"></span><h2 id="August-1st-Detect-Capital"><a href="#August-1st-Detect-Capital" class="headerlink" title="August 1st: Detect Capital"></a>August 1st: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3409/">Detect Capital</a></h2><p>Given a word, you need to judge whether the usage of capitals in it is right or not.</p><p>We define the usage of capitals in a word to be right when one of the following cases holds:</p><ul><li><p>All letters in this word are capitals, like “USA”.</p></li><li><p>All letters in this word are not capitals, like “leetcode”.</p></li><li><p>Only the first letter in this word is capital, like “Google”.</p></li></ul><p>Otherwise, we define that this word doesn’t use capitals in a right way.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;USA&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;FlaG&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> The input will be a non-empty word consisting of uppercase and lowercase latin letters.</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>不管字符串 <code>word</code> 的写法是否正确，我都可以列举出其三种正确的写法，放入集合 <code>s</code> 中，判断最初的 <code>word</code> 是否存在于 <code>s</code> 中即可。</p><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">detectCapitalUse</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;string&gt; s;</span><br><span class="line">        string word_cp = word;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : word_cp) &#123;</span><br><span class="line">            ch = <span class="built_in">tolower</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">insert</span>(word_cp);</span><br><span class="line">        word_cp[<span class="number">0</span>] = <span class="built_in">toupper</span>(word_cp[<span class="number">0</span>]);</span><br><span class="line">        s.<span class="built_in">insert</span>(word_cp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : word_cp) &#123;</span><br><span class="line">            ch = <span class="built_in">toupper</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">insert</span>(word_cp);</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">find</span>(word) != s.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-2nd-Design-HashSet"><a href="#August-2nd-Design-HashSet" class="headerlink" title="August 2nd: Design HashSet"></a>August 2nd: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3410/">Design HashSet</a></h2><p>Design a HashSet without using any built-in hash table libraries.</p><p>To be specific, your design should include these functions:</p><ul><li><p><code>add(value)</code>: Insert a value into the HashSet.</p></li><li><p><code>contains(value)</code>: Return whether the value exists in the HashSet or not.</p></li><li><p><code>remove(value)</code>: Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing.</p></li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyHashSet hashSet &#x3D; new MyHashSet();</span><br><span class="line">hashSet.add(1);</span><br><span class="line">hashSet.add(2);</span><br><span class="line">hashSet.contains(1);    &#x2F;&#x2F; returns true</span><br><span class="line">hashSet.contains(3);    &#x2F;&#x2F; returns false (not found)</span><br><span class="line">hashSet.add(2);</span><br><span class="line">hashSet.contains(2);    &#x2F;&#x2F; returns true</span><br><span class="line">hashSet.remove(2);</span><br><span class="line">hashSet.contains(2);    &#x2F;&#x2F; returns false (already removed)</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p>All values will be in the range of <code>[0, 1000000]</code>.</p></li><li><p>The number of operations will be in the range of <code>[1, 10000]</code>.</p></li><li><p>Please do not use the built-in HashSet library.</p></li></ul><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>采用哈希函数 + 单向链表，将 <code>key</code> 取模后在链表中添加、删除和查找。</p><p>P.S. 空间换时间，当然可以把 <code>mod</code> 直接赋值为 <code>1000001</code>。</p><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyHashSet</span>() : <span class="built_in">mod</span>(<span class="number">1000</span>) &#123;</span><br><span class="line">        v.<span class="built_in">resize</span>(mod);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        v[key%mod].<span class="built_in">push_front</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        v[key%mod].<span class="built_in">remove</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;val : v[key%mod]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mod;</span><br><span class="line">    vector&lt;forward_list&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyHashSet* obj = new MyHashSet();</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;remove(key);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;contains(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="August-3rd-Valid-Palindrome"><a href="#August-3rd-Valid-Palindrome" class="headerlink" title="August 3rd: Valid Palindrome"></a>August 3rd: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3411/">Valid Palindrome</a></h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p><strong>Note:</strong> For the purpose of this problem, we define empty string as valid palindrome.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;race a car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>s</code> consists only of printable ASCII characters.</li></ul><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用首尾指针 <code>beg</code> 和 <code>end</code> 进行比较，如果不是数字或字母，直接跳过。</p><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> beg = <span class="number">0</span>, end = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (beg &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(s[beg])) &#123;</span><br><span class="line">                ++beg;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(s[end])) &#123;</span><br><span class="line">                --end;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[beg]) != <span class="built_in">tolower</span>(s[end])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++beg;</span><br><span class="line">            --end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-4th-Power-of-Four"><a href="#August-4th-Power-of-Four" class="headerlink" title="August 4th: Power of Four"></a>August 4th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3412/">Power of Four</a></h2><p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 16</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>每次累乘 4，实际上都是将二进制形式左移 2 位，循环判断即可。</p><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-5th-Add-and-Search-Word-Data-structure-design"><a href="#August-5th-Add-and-Search-Word-Data-structure-design" class="headerlink" title="August 5th: Add and Search Word - Data structure design"></a>August 5th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3413/">Add and Search Word - Data structure design</a></h2><p>Design a data structure that supports the following two operations:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void addWord(word)</span><br><span class="line">bool search(word)</span><br></pre></td></tr></table></figure><p>search(word) can search a literal word or a regular expression string containing only letters <code>a-z</code> or <code>.</code>. A <code>.</code> means it can represent any one letter.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addWord(&quot;bad&quot;)</span><br><span class="line">addWord(&quot;dad&quot;)</span><br><span class="line">addWord(&quot;mad&quot;)</span><br><span class="line">search(&quot;pad&quot;) -&gt; false</span><br><span class="line">search(&quot;bad&quot;) -&gt; true</span><br><span class="line">search(&quot;.ad&quot;) -&gt; true</span><br><span class="line">search(&quot;b..&quot;) -&gt; true</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>You may assume that all words are consist of lowercase letters <code>a-z</code>.</p><h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用 <code>um</code> 建立从字符串长度至字符串数组的映射，从而在查询的时候降低时间复杂度。妙啊。</p><h4 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">WordDictionary</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds a word into the data structure. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        um[word.<span class="built_in">size</span>()].<span class="built_in">push_back</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character &#x27;.&#x27; to represent any one letter. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str : um[word.<span class="built_in">size</span>()]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">is_match</span>(str, word)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_match</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[i] == <span class="string">&#x27;.&#x27;</span> || word2[i] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (word1[i] != word2[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, vector&lt;string&gt;&gt; um;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary* obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addWord(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="August-6th-Find-All-Duplicates-in-an-Array"><a href="#August-6th-Find-All-Duplicates-in-an-Array" class="headerlink" title="August 6th: Find All Duplicates in an Array"></a>August 6th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3414/">Find All Duplicates in an Array</a></h2><p>Given an array of integers, <code>1 ≤ a[i] ≤ n</code> (<code>n</code> = size of array), some elements appear <strong>twice</strong> and others appear <strong>once</strong>.</p><p>Find all the elements that appear <strong>twice</strong> in this array.</p><p>Could you do it without extra space and in <code>O(n)</code> runtime?</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[2,3]</span><br></pre></td></tr></table></figure><h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>没啥好说的，直接看代码吧。</p><h4 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; um;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            ++um[num];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : um) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t.second == <span class="number">2</span>) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(t.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-7th-Vertical-Order-Traversal-of-a-Binary-Tree"><a href="#August-7th-Vertical-Order-Traversal-of-a-Binary-Tree" class="headerlink" title="August 7th: Vertical Order Traversal of a Binary Tree"></a>August 7th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3415/">Vertical Order Traversal of a Binary Tree</a></h2><p>Given a binary tree, return the vertical order traversal of its nodes values.</p><p>For each node at position <code>(X, Y)</code>, its left and right children respectively will be at positions <code>(X-1, Y-1)</code> and <code>(X+1, Y-1)</code>.</p><p>Running a vertical line from <code>X = -infinity</code> to <code>X = +infinity</code>, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing <code>Y</code> coordinates).</p><p>If two nodes have the same position, then the value of the node that is reported first is the value that is smaller.</p><p>Return an list of non-empty reports in order of <code>X</code> coordinate.  Every report will have a list of values of nodes.</p><p><strong>Example 1:</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/06.png" style="zoom:100%"/><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[9],[3,15],[20],[7]]</span><br><span class="line">Explanation:</span><br><span class="line">Without loss of generality, we can assume the root node is at position (0, 0):</span><br><span class="line">Then, the node with value 9 occurs at position (-1, -1);</span><br><span class="line">The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2);</span><br><span class="line">The node with value 20 occurs at position (1, -1);</span><br><span class="line">The node with value 7 occurs at position (2, -2).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/07.png" style="zoom:50%"/><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7]</span><br><span class="line">Output: [[4],[2],[1,5,6],[3],[7]]</span><br><span class="line">Explanation:</span><br><span class="line">The node with value 5 and the node with value 6 have the same position according to the given scheme.</span><br><span class="line">However, in the report &quot;[1,5,6]&quot;, the node value of 5 comes first since 5 is smaller than 6.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><p>The tree will have between <code>1</code> and <code>1000</code> nodes.</p></li><li><p>Each node’s value will be between <code>0</code> and <code>1000</code>.</p></li></ol><h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，核心在于这个声明：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;&gt; m;</span><br></pre></td></tr></table></figure><p><strong>第一个 <code>int</code> 代表节点的 <code>x</code> 坐标，第二个 <code>int</code> 代表节点的 <code>y</code> 坐标，<code>vector&lt;int&gt;</code> 存放节点的值；而且，<code>x</code> 坐标按照默认升序排列，<code>y</code> 坐标按照指定降序排列，适应题目要求。</strong></p><p>其次，使用函数 <code>func</code> 遍历树，存放至对应的 <code>vector&lt;int&gt;</code> 中。</p><p>最后，遍历 <code>m</code>，将 <code>x</code> 坐标相同的点合并到 <code>v</code> 中，组织为 <code>res</code> 即可。</p><h4 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">verticalTraversal</span>(TreeNode* root) &#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;&gt; m;</span><br><span class="line">        <span class="built_in">func</span>(root, <span class="number">0</span>, <span class="number">0</span>, m);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> imp : m) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> ivp : imp.second) &#123;</span><br><span class="line">                <span class="built_in">sort</span>(ivp.second.<span class="built_in">begin</span>(), ivp.second.<span class="built_in">end</span>());</span><br><span class="line">                v.<span class="built_in">insert</span>(v.<span class="built_in">end</span>(), ivp.second.<span class="built_in">begin</span>(), ivp.second.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(TreeNode *node, <span class="keyword">int</span> x, <span class="keyword">int</span> y,</span></span></span><br><span class="line"><span class="function"><span class="params">              map&lt;<span class="keyword">int</span>, map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;&gt; &amp;m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        m[x][y].<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="built_in">func</span>(node-&gt;left, x<span class="number">-1</span>, y<span class="number">-1</span>, m);</span><br><span class="line">        <span class="built_in">func</span>(node-&gt;right, x+<span class="number">1</span>, y<span class="number">-1</span>, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 八月挑战专题每日随缘更新，点击类别 &lt;a href=&quot;/categories/2020-August-LeetCoding-Challenge/&quot;&gt;2020 August LeetCoding Challenge&lt;/a&gt; 查看更多。&lt;/p&gt;</summary>
    
    
    
    <category term="A4 - LeetCode" scheme="https://progcz.com/categories/A4-LeetCode/"/>
    
    <category term="B4 - LeetCoding Challenge" scheme="https://progcz.com/categories/A4-LeetCode/B4-LeetCoding-Challenge/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="数据结构与算法" scheme="https://progcz.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Challenge" scheme="https://progcz.com/tags/Challenge/"/>
    
  </entry>
  
</feed>
