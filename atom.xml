<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ProgCZ&#39;s Blog</title>
  
  
  <link href="https://progcz.com/atom.xml" rel="self"/>
  
  <link href="https://progcz.com/"/>
  <updated>2021-03-08T01:00:38.000Z</updated>
  <id>https://progcz.com/</id>
  
  <author>
    <name>ProgCZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode Problem 4 - Median of Two Sorted Arrays</title>
    <link href="https://progcz.com/posts/leetcode-problem-median-of-two-sorted-arrays/"/>
    <id>https://progcz.com/posts/leetcode-problem-median-of-two-sorted-arrays/</id>
    <published>2021-03-03T00:22:15.000Z</published>
    <updated>2021-03-08T01:00:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">https://leetcode.com/problems/median-of-two-sorted-arrays/</a></p><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定两个排序后的数组 <code>nums1</code> 和 <code>nums2</code>，返回这两个数组合并后的中位值。</p><span id="more"></span><h2 id="解法一：暴力排序"><a href="#解法一：暴力排序" class="headerlink" title="解法一：暴力排序"></a>解法一：暴力排序</h2><p>合并两个数组之后进行排序，返回中位值。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(n)</code></p></li><li><p>时间：<code>O((m+n)log(m+n))</code></p></li></ul><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        nums1.<span class="built_in">insert</span>(nums1.<span class="built_in">end</span>(), nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> (nums1[(n<span class="number">-1</span>)/<span class="number">2</span>] + nums1[n/<span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：二分查找"><a href="#解法二：二分查找" class="headerlink" title="解法二：二分查找"></a>解法二：二分查找</h2><blockquote><p>参考：<a href="https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2471/Very-concise-O(log(min(MN)))-iterative-solution-with-detailed-explanation">https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2471/Very-concise-O(log(min(MN)))-iterative-solution-with-detailed-explanation</a></p></blockquote><p>如果可以将两个数组各自切成左右两部分，即 <code>nums1</code> -&gt; <code>nums1_left</code> 和 <code>nums1_right</code>，<code>nums2</code> -&gt; <code>nums2_left</code> 和 <code>nums2_right</code>，然后将两个 <code>left</code> 合并，两个 <code>right</code> 合并，如果两者长度相等，且 <code>left</code> 中最大的数字都要比 <code>right</code> 中最小的数字要小，那么就能得到中位数 <code>(max(left)+min(right))/2</code>。</p><p>为了达成上述想法，需要在排序数组中找到切分的位置，自然引出二分查找。在使用二分查找的过程中，可以使用这样一个小技巧：</p><p>将数组 <code>nums</code> 的每个元素之间都插入 <code>*</code>，比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1: 1 3 4 7 11 -&gt; * 1 * 3 * 4 * 7 * 11 *</span><br><span class="line">nums2: 2 8 9 10   -&gt; * 2 * 8 * 9 * 10 *</span><br></pre></td></tr></table></figure><p>数组 <code>nums</code> 的长度 <code>n -&gt; 2*n+1</code>，对应元素下标 <code>idx -&gt; 2*idx</code>。</p><p>这样做的目的是，将 <code>nums</code> 转换为有奇数个元素的数组；这样做的好处是，对于新数组来说，需要切分的范围恒为奇数个元素，假定范围为 <code>[lo, hi]</code>（左右边界一定落在 <code>*</code> 上），那么切分的位置为 <code>c=(lo+hi)/2</code>，其左侧数字在原数组中的下标为 <code>(c-1)/2</code>，其右侧数字在原数组中的下标为 <code>c/2</code>；比如：</p><p>待补例子</p><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(1)</code></p></li><li><p>时间：<code>O(log(min(m,n)))</code></p></li></ul><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n1 &lt; n2) <span class="keyword">return</span> <span class="built_in">findMedianSortedArrays</span>(nums2, nums1);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = <span class="number">2</span> * n2;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> c2 = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> c1 = n1 + n2 - c2;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> l1 = (c1 == <span class="number">0</span>) ? INT_MIN : nums1[(c1<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> l2 = (c2 == <span class="number">0</span>) ? INT_MIN : nums2[(c2<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> r1 = (c1 == n1*<span class="number">2</span>) ? INT_MAX : nums1[c1/<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> r2 = (c2 == n2*<span class="number">2</span>) ? INT_MAX : nums2[c2/<span class="number">2</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (l1 &gt; r2) &#123;</span><br><span class="line">                lo = c2 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 &gt; r1) &#123;</span><br><span class="line">                hi = c2 - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">max</span>(l1, l2) + <span class="built_in">min</span>(r1, r2)) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/median-of-two-sorted-arrays/&quot;&gt;https://leetcode.com/problems/median-of-two-sorted-arrays/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h3&gt;&lt;p&gt;给定两个排序后的数组 &lt;code&gt;nums1&lt;/code&gt; 和 &lt;code&gt;nums2&lt;/code&gt;，返回这两个数组合并后的中位值。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="LeetCode Problems" scheme="https://progcz.com/categories/A03-LeetCode/LeetCode-Problems/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Array" scheme="https://progcz.com/tags/Array/"/>
    
    <category term="Hash Table" scheme="https://progcz.com/tags/Hash-Table/"/>
    
    <category term="Binary Search" scheme="https://progcz.com/tags/Binary-Search/"/>
    
    <category term="Divide and Conquer" scheme="https://progcz.com/tags/Divide-and-Conquer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Problem 3 - Longest Substring Without Repeating Characters</title>
    <link href="https://progcz.com/posts/leetcode-problem-longest-substring-without-repeating-characters/"/>
    <id>https://progcz.com/posts/leetcode-problem-longest-substring-without-repeating-characters/</id>
    <published>2021-02-26T01:08:46.000Z</published>
    <updated>2021-03-03T00:07:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a></p><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定字符串，输出最长不重复子串的长度。</p><span id="more"></span><h2 id="解法一：滑动窗口"><a href="#解法一：滑动窗口" class="headerlink" title="解法一：滑动窗口"></a>解法一：滑动窗口</h2><p>借助 <code>hash_map</code>，建立起<strong>子串中</strong>字符和出现次数的映射，如果 <code>hash_map</code> 中所有字符的出现次数均不大于 <code>1</code>，那么就说明当前子串为不重复子串。</p><p>滑动窗口的左右边界分别为 <code>beg</code> 和 <code>end</code>（均初始化为 <code>0</code>），</p><ol><li><p>在遍历 <code>hash_map</code> 后判断当前子串为不重复子串的情况下，<code>end</code> 不断右移，同时将 <code>hash_map</code> 中对应字符的出现次数 <code>+1</code>。</p></li><li><p>上述 <code>end</code> 的右移停止，说明 <code>end</code> 到达字符串末尾或者当前子串为重复子串，则记录不重复子串的最大长度。</p></li><li><p>在遍历 <code>hash_map</code> 后判断当前子串为重复子串的情况下，<code>beg</code> 不断右移，同时将 <code>hash_map</code> 中对应字符的出现次数 <code>-1</code>。</p></li><li><p>上述 <code>beg</code> 的右移停止，说明 <code>beg</code> 到达 <code>end</code> 或者当前子串不为重复子串，则重复整个流程。</p></li></ol><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(n)</code>（不太确定）</p></li><li><p>时间：<code>O(n)</code></p></li></ul><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; um;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> beg = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; <span class="built_in">helper</span>(um)) &#123;</span><br><span class="line">                um[s[end++]-<span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> len = (end == n &amp;&amp; <span class="built_in">helper</span>(um)) ?</span><br><span class="line">                (end - beg) : (end - beg - <span class="number">1</span>);</span><br><span class="line">            res = <span class="built_in">max</span>(res, len);</span><br><span class="line">            <span class="keyword">while</span> (beg &lt;= end &amp;&amp; !<span class="built_in">helper</span>(um)) &#123;</span><br><span class="line">                um[s[beg++]-<span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="keyword">const</span> unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; um)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = um.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (iter != um.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;second &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++iter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：记旧账"><a href="#解法二：记旧账" class="headerlink" title="解法二：记旧账"></a>解法二：记旧账</h2><p>对于当前字符来说，往前一个一个地推字符，如果某个字符出现了两次，那么该字符前一次出现的下标，一定是最长不重复子串起点的下标减一。</p><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间复杂度：<code>O(1)</code></p></li><li><p>时间复杂度：<code>O(n)</code></p></li></ul><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><blockquote><p>参考：<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1730/Shortest-O(n)-DP-solution-with-explanations">https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1730/Shortest-O(n)-DP-solution-with-explanations</a></p></blockquote><div class="note info"><p>因为 <code>char</code> 类型是 8 位，枚举值共有 256 种，所以可以使用 <code>array&lt;int, 256&gt;</code> 代替 <code>unordered_map&lt;char, int&gt;</code> 来实现字符和下标之间的映射。</p></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        array&lt;<span class="keyword">int</span>, 256&gt; arr; arr.<span class="built_in">fill</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, loc = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 等号右边的 `loc`，就是解法中提到的「前一次出现的下标」</span></span><br><span class="line">            <span class="comment">// 等号右边的 `arr[s[i]]`，就是当前字符的「前一次出现的下标」</span></span><br><span class="line">            <span class="comment">// 两者取最大，更新 `loc`，同时 `loc` 也就是：</span></span><br><span class="line">            <span class="comment">// 对于当前字符来说的，最长不重复子串起点的下标减一</span></span><br><span class="line">            loc = <span class="built_in">max</span>(loc, arr[s[i]]);</span><br><span class="line">            <span class="comment">// 计算：对于当前字符来说的，最长不重复子串的长度</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, i-loc);</span><br><span class="line">            <span class="comment">// 更新 `arr[s[i]]`</span></span><br><span class="line">            arr[s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-substring-without-repeating-characters/&quot;&gt;https://leetcode.com/problems/longest-substring-without-repeating-characters/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h3&gt;&lt;p&gt;给定字符串，输出最长不重复子串的长度。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="LeetCode Problems" scheme="https://progcz.com/categories/A03-LeetCode/LeetCode-Problems/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="String" scheme="https://progcz.com/tags/String/"/>
    
    <category term="Hash Table" scheme="https://progcz.com/tags/Hash-Table/"/>
    
    <category term="Two Pointers" scheme="https://progcz.com/tags/Two-Pointers/"/>
    
    <category term="Sliding Window" scheme="https://progcz.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Problem 2 - Add Two Numbers</title>
    <link href="https://progcz.com/posts/leetcode-problem-add-two-numbers/"/>
    <id>https://progcz.com/posts/leetcode-problem-add-two-numbers/</id>
    <published>2021-02-24T15:54:42.000Z</published>
    <updated>2021-02-26T00:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/add-two-numbers/">https://leetcode.com/problems/add-two-numbers/</a></p><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>将两个数字的每一位，逆序地拆成两个链表 <code>l1</code> 和 <code>l2</code>，计算这两个数字的和，结果以同样顺序的链表表示。</p><span id="more"></span><h2 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h2><p>递归遍历两个输入链表，对应节点相加，<code>%10</code> 的值存入输出链表的对应节点，<code>/10</code> 的值存入输出链表的下一节点。</p><p>边界条件：两个输入链表的对应节点都为空指针。</p><div class="note info"><p>在边界条件下，需要根据下一节点的值是否为 0 而决定是否抛弃该下一节点。为了实现这一点，同时保持代码的 <code>neat</code> 性，传入递归函数的输出链表的对应节点，需要自带下一节点，这就是 C++ 实现中 <code>new ListNode(0, new ListNode(0))</code> 的由来。</p></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(n)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* root = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">helper</span>(l1, l2, root);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(ListNode* l1, ListNode* l2, ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1 &amp;&amp; !l2) &#123;</span><br><span class="line">            node-&gt;next = node-&gt;next-&gt;val ? node-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        <span class="keyword">int</span> sum = node-&gt;val +</span><br><span class="line">            (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>);</span><br><span class="line">        node-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">        node-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum/<span class="number">10</span>);</span><br><span class="line">        l1 = l1 ? l1-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        l2 = l2 ? l2-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(l1, l2, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：循环"><a href="#解法二：循环" class="headerlink" title="解法二：循环"></a>解法二：循环</h2><p>思路基本上与<a href="#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9A%E9%80%92%E5%BD%92">解法一</a>保持一致，只是将递归形式改为循环形式，同时写法上更加 neat。</p><blockquote><p>参考：<a href="https://leetcode.com/problems/add-two-numbers/discuss/997/c++-Sharing-my-11-line-c++-solution-can-someone-make-it-even-more-concise">https://leetcode.com/problems/add-two-numbers/discuss/997/c++-Sharing-my-11-line-c++-solution-can-someone-make-it-even-more-concise</a></p></blockquote><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(n)</code></p></li><li><p>时间：<code>O(n)</code></p></li></ul><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode root(0), *node = &amp;root;</span><br><span class="line">        <span class="keyword">int</span> extra = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || extra) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = extra + </span><br><span class="line">                (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>);</span><br><span class="line">            extra = sum/<span class="number">10</span>;</span><br><span class="line">            node-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            l1 = l1 ? l1-&gt;next : l1;</span><br><span class="line">            l2 = l2 ? l2-&gt;next : l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/add-two-numbers/&quot;&gt;https://leetcode.com/problems/add-two-numbers/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h3&gt;&lt;p&gt;将两个数字的每一位，逆序地拆成两个链表 &lt;code&gt;l1&lt;/code&gt; 和 &lt;code&gt;l2&lt;/code&gt;，计算这两个数字的和，结果以同样顺序的链表表示。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="LeetCode Problems" scheme="https://progcz.com/categories/A03-LeetCode/LeetCode-Problems/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Linked List" scheme="https://progcz.com/tags/Linked-List/"/>
    
    <category term="Math" scheme="https://progcz.com/tags/Math/"/>
    
    <category term="Recursion" scheme="https://progcz.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Problem 1 - Two Sum</title>
    <link href="https://progcz.com/posts/leetcode-problem-two-sum/"/>
    <id>https://progcz.com/posts/leetcode-problem-two-sum/</id>
    <published>2021-02-17T15:48:43.000Z</published>
    <updated>2021-02-19T15:49:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/two-sum/">https://leetcode.com/problems/two-sum/</a></p><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定数组 <code>nums</code> 和数字 <code>target</code>，要求在 <code>nums</code> 中找到两个数字，和为 <code>target</code>，返回这两个数字的下标。</p><p>保证有且只有一个解，而且同一个数字不能用两次。</p><span id="more"></span><h2 id="解法一：两层循环，暴力破解"><a href="#解法一：两层循环，暴力破解" class="headerlink" title="解法一：两层循环，暴力破解"></a>解法一：两层循环，暴力破解</h2><p>两层循环，遍历所有可能的数字组合，找到则返回下标。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(1)</code></p></li><li><p>时间：<code>O(n^2)</code></p></li></ul><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二：借助-hash-map，用空间换时间"><a href="#解法二：借助-hash-map，用空间换时间" class="headerlink" title="解法二：借助 hash_map，用空间换时间"></a>解法二：借助 <code>hash_map</code>，用空间换时间</h2><p>既可以使用两次循环：</p><ul><li><p>第一次循环完成「记录」：借助 <code>hash_map</code>，建立数字 <code>target-nums[i]</code> 和下标 <code>i</code> 之间的映射。</p></li><li><p>第二次循环进行「查询」：如果数字 <code>nums[i]</code> 存在于 <code>hash_map</code> 中，而且不是同一数字（下标不同），说明可以「配对」，则返回该数字下标和 <code>hash_map</code> 中记录的另一数字下标。</p></li></ul><p>也可以使用单次循环：</p><ul><li>单次循环合并「记录」和「查询」：如果数字 <code>nums[i]</code> 存在于 <code>hash_map</code> 中，说明可以「配对」，则返回该数字下标和 <code>hash_map</code> 中记录的另一数字下标，否则建立数字 <code>target-nums[i]</code> 和下标 <code>i</code> 之间的映射。</li></ul><blockquote><p>单次循环参考：<a href="https://leetcode.com/problems/two-sum/discuss/13/Accepted-C++-O(n)-Solution/263">https://leetcode.com/problems/two-sum/discuss/13/Accepted-C++-O(n)-Solution/263</a></p></blockquote><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>空间：<code>O(n)</code>（不太确定）</p></li><li><p>时间：<code>O(n)</code></p><ul><li><code>hash_map</code> 插入、查询、删除的操作，时间复杂度均为 <code>O(1)</code>。</li></ul></li></ul><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><p>两次循环：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; um = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            um[target-nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (um.<span class="built_in">find</span>(nums[i]) != um.<span class="built_in">end</span>() &amp;&amp;</span><br><span class="line">                um[nums[i]] != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;um[nums[i]], i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>单次循环：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; um;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (um.<span class="built_in">find</span>(nums[i]) != um.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;um[nums[i]], i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            um[target-nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/two-sum/&quot;&gt;https://leetcode.com/problems/two-sum/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h3&gt;&lt;p&gt;给定数组 &lt;code&gt;nums&lt;/code&gt; 和数字 &lt;code&gt;target&lt;/code&gt;，要求在 &lt;code&gt;nums&lt;/code&gt; 中找到两个数字，和为 &lt;code&gt;target&lt;/code&gt;，返回这两个数字的下标。&lt;/p&gt;
&lt;p&gt;保证有且只有一个解，而且同一个数字不能用两次。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="LeetCode Problems" scheme="https://progcz.com/categories/A03-LeetCode/LeetCode-Problems/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Array" scheme="https://progcz.com/tags/Array/"/>
    
    <category term="Hash Table" scheme="https://progcz.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>充满仪式感的「全年总结」和不太可能坚持下去的「新年计划」</title>
    <link href="https://progcz.com/posts/summary-for-past-year-and-plan-for-new-year/"/>
    <id>https://progcz.com/posts/summary-for-past-year-and-plan-for-new-year/</id>
    <published>2021-01-02T12:34:35.000Z</published>
    <updated>2021-04-29T15:10:53.052Z</updated>
    
    <content type="html"><![CDATA[<p>即使新建好了文档，我依然不知道到底该写些什么，但是「写」这个念头就像只怎么也赶不走的乌鸦，一直在我的头顶盘旋。</p><p>也许确实是因为仪式感吧，<strong>每到了辞旧迎新的时候，总该有些「落在纸面」的文字，先跟过去的一年和解，再把自己交代给未来的一年。</strong></p><p>也罢，就让我这个记忆力和行动力都逐渐退化的人，来一场「全年总结」和「新年计划」吧！</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/01.jpg" style="zoom:100%"/><span id="more"></span><h2 id="1-全年总结"><a href="#1-全年总结" class="headerlink" title="1 全年总结"></a>1 全年总结</h2><h3 id="1-1-失去的五个月"><a href="#1-1-失去的五个月" class="headerlink" title="1.1 失去的五个月"></a>1.1 失去的五个月</h3><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/02.jpg" style="zoom:100%"/><p>但凡回顾 2020，疫情是怎么都绕不开的话题。</p><p>不论性别，不论国籍，不论贫穷或富有，不论疾病或健康，只要你还是这颗蓝色星球上的原住民，或多或少都会受到疫情的影响，唯一的区别就在于这个「或多或少」。</p><p>非常幸运，也非常惭愧，我是「或少」中的一员。</p><p>不管是磕磕绊绊但还是顺利完成了的学位答辩，还是在家只吃不动而逐渐狂妄的体重涨幅，在这场全人类都无法幸免的灾难面前，看上去都是小事。</p><p>因此，我始终对在疫情中离开人世的生命感到惋惜，他们一定也在 2020 年伊始时，怀揣着对新年的希望，如今归于尘土；我也始终对在疫情中奋战在一线的医护人员保持敬意，他们以血肉之躯，构筑起保护我们的钢铁长城。</p><div class="note warning"><p>写得越来越像高考作文了。</p><p>Whatever, it’s just the way how i was raised and educated.</p></div><p>不是超级英雄，<strong>只能保护好自己，照顾好家人，足够了。</strong></p><h3 id="1-2-十九年寒窗"><a href="#1-2-十九年寒窗" class="headerlink" title="1.2 十九年寒窗"></a>1.2 十九年寒窗</h3><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/03.jpg" style="zoom:100%"/><p>毕业算是改变人生的事情当中，意外指数最低的事情了吧。</p><p>在这种意义下，与其说是改变人生，<strong>不如说是人生早就被安排成了列车的时刻表，毕业这件事情就在单线轨道的某个站点上等着，没有丝毫悬念。</strong></p><p>虽然，我今年所面临的毕业，与以往的毕业不尽相同：</p><ul><li><p>以往的毕业，从学校到学校，换了环境而已，依然是衣食无忧的学生，终极目标不过是分数、绩点和排名。</p></li><li><p>今年的毕业，从学校到公司，真正意义上的经济独立，终极目标切换成房子、车子和存款。</p></li></ul><p>当然，还是很感谢曾经作为学生的自己，至少为我打好了阶级跃迁的基础，在人生这一新的阶段能多抢跑几秒钟。</p><h3 id="1-3-职场与人生"><a href="#1-3-职场与人生" class="headerlink" title="1.3 职场与人生"></a>1.3 职场与人生</h3><p>互联网大厂的程序员工作，一言以蔽之：节奏快，工作忙，身体累。</p><p>比起初入职场的感想，我更想探讨的是，在人生意义这个问题上的心态转变。</p><p>这是个老生常谈的哲学命题，我明白。但我还是想说说自己的理解。</p><p>过去的二十几年，从我记事开始，我就一直在为别人而活。</p><p>说起来非常简单的生活：作为学生，考试考个好成绩；作为儿女，听长辈的话。这样，父母就会很开心，长辈就会称赞我（不管是不是虚情假意），同学也会尊重我（即便是以对待书呆子的态度）。</p><p>我好像从来没想过，自己想要什么。</p><p>或者说，是周围的人告诉我的「我想要的」：努力学习，努力赚钱，有套自己的房子，有个幸福的家庭。</p><p>直到我开始问我自己：然后呢？这一切之后呢？从生到死，人这一生到底是为了什么呢？</p><p>过去的一年里，我反复地思考人生的意义，在上下班通勤的路上，在漫长而枯燥的旅途中，在每个放纵自己而熬到很困的深夜里。</p><p>而每次我都只能得到同一个答案：<strong>人生的意义是为了开心，为了愉悦的体验，为了舒适的生活。</strong></p><p>又是个老生常谈的答案，我明白。但这次，我是真的相信它了。</p><h2 id="2-新年计划"><a href="#2-新年计划" class="headerlink" title="2 新年计划"></a>2 新年计划</h2><h3 id="2-1-工作"><a href="#2-1-工作" class="headerlink" title="2.1 工作"></a>2.1 工作</h3><p>无他，努力工作，赚钱买房。</p><div class="note warning"><p>但是要牢记的是，身体是革命的本钱！任何事情的达成都不能以牺牲身体健康为前提。</p></div><h3 id="2-2-读书"><a href="#2-2-读书" class="headerlink" title="2.2 读书"></a>2.2 读书</h3><p>在将 kindle 上未读的书目消灭至只有个位数之前，不再囤书了。</p><p>至于数量，不想做硬性要求，只求在有大块时间和舒适状态的时候，能想起来读书，而不是刷手机/看视频。</p><h3 id="2-3-按摩-健身"><a href="#2-3-按摩-健身" class="headerlink" title="2.3 按摩/健身"></a>2.3 按摩/健身</h3><p>每周二按摩，每周四健身。</p><h3 id="2-4-旅游"><a href="#2-4-旅游" class="headerlink" title="2.4 旅游"></a>2.4 旅游</h3><p>希望每年能有一次旅游，实际上 2021 的额度已经分给厦门了，毕竟厦大百年校庆，是时候回去看看了。</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/04.jpg" style="zoom:100%"/><hr><h2 id="3-番外"><a href="#3-番外" class="headerlink" title="3 番外"></a>3 番外</h2><p>新年第一天，去撸了猫猫狗狗，希望能把这份开心延续一整年吧。</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/05.jpg" style="zoom:100%"/>]]></content>
    
    
    <summary type="html">&lt;p&gt;即使新建好了文档，我依然不知道到底该写些什么，但是「写」这个念头就像只怎么也赶不走的乌鸦，一直在我的头顶盘旋。&lt;/p&gt;
&lt;p&gt;也许确实是因为仪式感吧，&lt;strong&gt;每到了辞旧迎新的时候，总该有些「落在纸面」的文字，先跟过去的一年和解，再把自己交代给未来的一年。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也罢，就让我这个记忆力和行动力都逐渐退化的人，来一场「全年总结」和「新年计划」吧！&lt;/p&gt;
&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/01.jpg&quot; style=&quot;zoom:100%&quot;/&gt;</summary>
    
    
    
    <category term="A00 - 总结与计划" scheme="https://progcz.com/categories/A00-%E6%80%BB%E7%BB%93%E4%B8%8E%E8%AE%A1%E5%88%92/"/>
    
    
    <category term="Plan" scheme="https://progcz.com/tags/Plan/"/>
    
    <category term="Summary" scheme="https://progcz.com/tags/Summary/"/>
    
    <category term="Happiness" scheme="https://progcz.com/tags/Happiness/"/>
    
  </entry>
  
  <entry>
    <title>2020 August LeetCoding Challenge - Week 2</title>
    <link href="https://progcz.com/posts/2020-august-leetcoding-challenge-week-2/"/>
    <id>https://progcz.com/posts/2020-august-leetcoding-challenge-week-2/</id>
    <published>2020-08-08T15:36:56.000Z</published>
    <updated>2020-08-16T02:42:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 八月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-August-LeetCoding-Challenge/">2020 August LeetCoding Challenge</a> 查看更多。</p><span id="more"></span><h2 id="August-8th-Path-Sum-III"><a href="#August-8th-Path-Sum-III" class="headerlink" title="August 8th: Path Sum III"></a>August 8th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/550/week-2-august-8th-august-14th/3417/">Path Sum III</a></h2><p>You are given a binary tree in which each node contains an integer value.</p><p>Find the number of paths that sum to a given value.</p><p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p><p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     &#x2F;  \</span><br><span class="line">    5   -3</span><br><span class="line">   &#x2F; \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用函数 <code>func</code> 对树进行深度优先搜索，对以 <code>node</code> 为起点且满足题目要求的路径进行计数。</p><p><code>pathSum(root-&gt;left, sum)</code> 和 <code>pathSum(root-&gt;right, sum)</code> 则是分别给左右节点一次「重新开始」的机会。</p><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(root, sum) + <span class="built_in">pathSum</span>(root-&gt;left, sum) + <span class="built_in">pathSum</span>(root-&gt;right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(TreeNode *node,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = node-&gt;val==sum ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="built_in">func</span>(node-&gt;left, sum-node-&gt;val) + <span class="built_in">func</span>(node-&gt;right, sum-node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>终究还是没能在工作日坚持下来，这个系列终止吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 八月挑战专题每日随缘更新，点击类别 &lt;a href=&quot;/categories/2020-August-LeetCoding-Challenge/&quot;&gt;2020 August LeetCoding Challenge&lt;/a&gt; 查看更多。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="2020 LeetCoding Challenge" scheme="https://progcz.com/categories/A03-LeetCode/2020-LeetCoding-Challenge/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Data Structure and Algorithm" scheme="https://progcz.com/tags/Data-Structure-and-Algorithm/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Challenge" scheme="https://progcz.com/tags/Challenge/"/>
    
  </entry>
  
  <entry>
    <title>2020 August LeetCoding Challenge - Week 1</title>
    <link href="https://progcz.com/posts/2020-august-leetcoding-challenge-week-1/"/>
    <id>https://progcz.com/posts/2020-august-leetcoding-challenge-week-1/</id>
    <published>2020-08-01T07:37:02.000Z</published>
    <updated>2020-08-08T03:31:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 八月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-August-LeetCoding-Challenge/">2020 August LeetCoding Challenge</a> 查看更多。</p><span id="more"></span><h2 id="August-1st-Detect-Capital"><a href="#August-1st-Detect-Capital" class="headerlink" title="August 1st: Detect Capital"></a>August 1st: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3409/">Detect Capital</a></h2><p>Given a word, you need to judge whether the usage of capitals in it is right or not.</p><p>We define the usage of capitals in a word to be right when one of the following cases holds:</p><ul><li><p>All letters in this word are capitals, like “USA”.</p></li><li><p>All letters in this word are not capitals, like “leetcode”.</p></li><li><p>Only the first letter in this word is capital, like “Google”.</p></li></ul><p>Otherwise, we define that this word doesn’t use capitals in a right way.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;USA&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;FlaG&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> The input will be a non-empty word consisting of uppercase and lowercase latin letters.</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>不管字符串 <code>word</code> 的写法是否正确，我都可以列举出其三种正确的写法，放入集合 <code>s</code> 中，判断最初的 <code>word</code> 是否存在于 <code>s</code> 中即可。</p><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">detectCapitalUse</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;string&gt; s;</span><br><span class="line">        string word_cp = word;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : word_cp) &#123;</span><br><span class="line">            ch = <span class="built_in">tolower</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">insert</span>(word_cp);</span><br><span class="line">        word_cp[<span class="number">0</span>] = <span class="built_in">toupper</span>(word_cp[<span class="number">0</span>]);</span><br><span class="line">        s.<span class="built_in">insert</span>(word_cp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : word_cp) &#123;</span><br><span class="line">            ch = <span class="built_in">toupper</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">insert</span>(word_cp);</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">find</span>(word) != s.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-2nd-Design-HashSet"><a href="#August-2nd-Design-HashSet" class="headerlink" title="August 2nd: Design HashSet"></a>August 2nd: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3410/">Design HashSet</a></h2><p>Design a HashSet without using any built-in hash table libraries.</p><p>To be specific, your design should include these functions:</p><ul><li><p><code>add(value)</code>: Insert a value into the HashSet.</p></li><li><p><code>contains(value)</code>: Return whether the value exists in the HashSet or not.</p></li><li><p><code>remove(value)</code>: Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing.</p></li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyHashSet hashSet &#x3D; new MyHashSet();</span><br><span class="line">hashSet.add(1);</span><br><span class="line">hashSet.add(2);</span><br><span class="line">hashSet.contains(1);    &#x2F;&#x2F; returns true</span><br><span class="line">hashSet.contains(3);    &#x2F;&#x2F; returns false (not found)</span><br><span class="line">hashSet.add(2);</span><br><span class="line">hashSet.contains(2);    &#x2F;&#x2F; returns true</span><br><span class="line">hashSet.remove(2);</span><br><span class="line">hashSet.contains(2);    &#x2F;&#x2F; returns false (already removed)</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p>All values will be in the range of <code>[0, 1000000]</code>.</p></li><li><p>The number of operations will be in the range of <code>[1, 10000]</code>.</p></li><li><p>Please do not use the built-in HashSet library.</p></li></ul><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>采用哈希函数 + 单向链表，将 <code>key</code> 取模后在链表中添加、删除和查找。</p><p>P.S. 空间换时间，当然可以把 <code>mod</code> 直接赋值为 <code>1000001</code>。</p><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyHashSet</span>() : <span class="built_in">mod</span>(<span class="number">1000</span>) &#123;</span><br><span class="line">        v.<span class="built_in">resize</span>(mod);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        v[key%mod].<span class="built_in">push_front</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        v[key%mod].<span class="built_in">remove</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;val : v[key%mod]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mod;</span><br><span class="line">    vector&lt;forward_list&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyHashSet* obj = new MyHashSet();</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;remove(key);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;contains(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="August-3rd-Valid-Palindrome"><a href="#August-3rd-Valid-Palindrome" class="headerlink" title="August 3rd: Valid Palindrome"></a>August 3rd: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3411/">Valid Palindrome</a></h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p><strong>Note:</strong> For the purpose of this problem, we define empty string as valid palindrome.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;race a car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>s</code> consists only of printable ASCII characters.</li></ul><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用首尾指针 <code>beg</code> 和 <code>end</code> 进行比较，如果不是数字或字母，直接跳过。</p><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> beg = <span class="number">0</span>, end = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (beg &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(s[beg])) &#123;</span><br><span class="line">                ++beg;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(s[end])) &#123;</span><br><span class="line">                --end;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[beg]) != <span class="built_in">tolower</span>(s[end])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++beg;</span><br><span class="line">            --end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-4th-Power-of-Four"><a href="#August-4th-Power-of-Four" class="headerlink" title="August 4th: Power of Four"></a>August 4th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3412/">Power of Four</a></h2><p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 16</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>每次累乘 4，实际上都是将二进制形式左移 2 位，循环判断即可。</p><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-5th-Add-and-Search-Word-Data-structure-design"><a href="#August-5th-Add-and-Search-Word-Data-structure-design" class="headerlink" title="August 5th: Add and Search Word - Data structure design"></a>August 5th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3413/">Add and Search Word - Data structure design</a></h2><p>Design a data structure that supports the following two operations:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void addWord(word)</span><br><span class="line">bool search(word)</span><br></pre></td></tr></table></figure><p>search(word) can search a literal word or a regular expression string containing only letters <code>a-z</code> or <code>.</code>. A <code>.</code> means it can represent any one letter.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addWord(&quot;bad&quot;)</span><br><span class="line">addWord(&quot;dad&quot;)</span><br><span class="line">addWord(&quot;mad&quot;)</span><br><span class="line">search(&quot;pad&quot;) -&gt; false</span><br><span class="line">search(&quot;bad&quot;) -&gt; true</span><br><span class="line">search(&quot;.ad&quot;) -&gt; true</span><br><span class="line">search(&quot;b..&quot;) -&gt; true</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>You may assume that all words are consist of lowercase letters <code>a-z</code>.</p><h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用 <code>um</code> 建立从字符串长度至字符串数组的映射，从而在查询的时候降低时间复杂度。妙啊。</p><h4 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">WordDictionary</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds a word into the data structure. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        um[word.<span class="built_in">size</span>()].<span class="built_in">push_back</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character &#x27;.&#x27; to represent any one letter. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str : um[word.<span class="built_in">size</span>()]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">is_match</span>(str, word)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_match</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[i] == <span class="string">&#x27;.&#x27;</span> || word2[i] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (word1[i] != word2[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, vector&lt;string&gt;&gt; um;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary* obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addWord(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="August-6th-Find-All-Duplicates-in-an-Array"><a href="#August-6th-Find-All-Duplicates-in-an-Array" class="headerlink" title="August 6th: Find All Duplicates in an Array"></a>August 6th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3414/">Find All Duplicates in an Array</a></h2><p>Given an array of integers, <code>1 ≤ a[i] ≤ n</code> (<code>n</code> = size of array), some elements appear <strong>twice</strong> and others appear <strong>once</strong>.</p><p>Find all the elements that appear <strong>twice</strong> in this array.</p><p>Could you do it without extra space and in <code>O(n)</code> runtime?</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[2,3]</span><br></pre></td></tr></table></figure><h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>没啥好说的，直接看代码吧。</p><h4 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; um;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            ++um[num];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : um) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t.second == <span class="number">2</span>) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(t.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="August-7th-Vertical-Order-Traversal-of-a-Binary-Tree"><a href="#August-7th-Vertical-Order-Traversal-of-a-Binary-Tree" class="headerlink" title="August 7th: Vertical Order Traversal of a Binary Tree"></a>August 7th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3415/">Vertical Order Traversal of a Binary Tree</a></h2><p>Given a binary tree, return the vertical order traversal of its nodes values.</p><p>For each node at position <code>(X, Y)</code>, its left and right children respectively will be at positions <code>(X-1, Y-1)</code> and <code>(X+1, Y-1)</code>.</p><p>Running a vertical line from <code>X = -infinity</code> to <code>X = +infinity</code>, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing <code>Y</code> coordinates).</p><p>If two nodes have the same position, then the value of the node that is reported first is the value that is smaller.</p><p>Return an list of non-empty reports in order of <code>X</code> coordinate.  Every report will have a list of values of nodes.</p><p><strong>Example 1:</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/06.png" style="zoom:100%"/><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[9],[3,15],[20],[7]]</span><br><span class="line">Explanation:</span><br><span class="line">Without loss of generality, we can assume the root node is at position (0, 0):</span><br><span class="line">Then, the node with value 9 occurs at position (-1, -1);</span><br><span class="line">The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2);</span><br><span class="line">The node with value 20 occurs at position (1, -1);</span><br><span class="line">The node with value 7 occurs at position (2, -2).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/07.png" style="zoom:50%"/><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7]</span><br><span class="line">Output: [[4],[2],[1,5,6],[3],[7]]</span><br><span class="line">Explanation:</span><br><span class="line">The node with value 5 and the node with value 6 have the same position according to the given scheme.</span><br><span class="line">However, in the report &quot;[1,5,6]&quot;, the node value of 5 comes first since 5 is smaller than 6.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><p>The tree will have between <code>1</code> and <code>1000</code> nodes.</p></li><li><p>Each node’s value will be between <code>0</code> and <code>1000</code>.</p></li></ol><h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，核心在于这个声明：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;&gt; m;</span><br></pre></td></tr></table></figure><p><strong>第一个 <code>int</code> 代表节点的 <code>x</code> 坐标，第二个 <code>int</code> 代表节点的 <code>y</code> 坐标，<code>vector&lt;int&gt;</code> 存放节点的值；而且，<code>x</code> 坐标按照默认升序排列，<code>y</code> 坐标按照指定降序排列，适应题目要求。</strong></p><p>其次，使用函数 <code>func</code> 遍历树，存放至对应的 <code>vector&lt;int&gt;</code> 中。</p><p>最后，遍历 <code>m</code>，将 <code>x</code> 坐标相同的点合并到 <code>v</code> 中，组织为 <code>res</code> 即可。</p><h4 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">verticalTraversal</span>(TreeNode* root) &#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;&gt; m;</span><br><span class="line">        <span class="built_in">func</span>(root, <span class="number">0</span>, <span class="number">0</span>, m);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> imp : m) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> ivp : imp.second) &#123;</span><br><span class="line">                <span class="built_in">sort</span>(ivp.second.<span class="built_in">begin</span>(), ivp.second.<span class="built_in">end</span>());</span><br><span class="line">                v.<span class="built_in">insert</span>(v.<span class="built_in">end</span>(), ivp.second.<span class="built_in">begin</span>(), ivp.second.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(TreeNode *node, <span class="keyword">int</span> x, <span class="keyword">int</span> y,</span></span></span><br><span class="line"><span class="function"><span class="params">              map&lt;<span class="keyword">int</span>, map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;&gt; &amp;m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        m[x][y].<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="built_in">func</span>(node-&gt;left, x<span class="number">-1</span>, y<span class="number">-1</span>, m);</span><br><span class="line">        <span class="built_in">func</span>(node-&gt;right, x+<span class="number">1</span>, y<span class="number">-1</span>, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 八月挑战专题每日随缘更新，点击类别 &lt;a href=&quot;/categories/2020-August-LeetCoding-Challenge/&quot;&gt;2020 August LeetCoding Challenge&lt;/a&gt; 查看更多。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="2020 LeetCoding Challenge" scheme="https://progcz.com/categories/A03-LeetCode/2020-LeetCoding-Challenge/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Data Structure and Algorithm" scheme="https://progcz.com/tags/Data-Structure-and-Algorithm/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Challenge" scheme="https://progcz.com/tags/Challenge/"/>
    
  </entry>
  
  <entry>
    <title>我的工作桌面长啥样</title>
    <link href="https://progcz.com/posts/what-does-my-work-desktop-look-like/"/>
    <id>https://progcz.com/posts/what-does-my-work-desktop-look-like/</id>
    <published>2020-08-01T07:11:15.000Z</published>
    <updated>2020-11-26T01:57:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉，已经入职两个月了。</p><p>在这两个月里，我一直在适应工作节奏，所以没有时间更新博客（虽然也没什么人看）。</p><p>在这两个月里，我的工作桌面也在不断进化，不断适应我的使用习惯，到现在也算是个初级形态了，所以打算在这里梳理一下（其实就是想晒装备）。</p><p>先来张工作桌面的整体照片过过瘾：</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/00.png" style="zoom:100%"/><span id="more"></span><h2 id="1-「公司发的」MacBook-Pro-16"><a href="#1-「公司发的」MacBook-Pro-16" class="headerlink" title="1 「公司发的」MacBook Pro 16"></a>1 「公司发的」MacBook Pro 16</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/01.png" style="zoom:100%"/><p>整个桌面都是围绕着 MacBook Pro 16 来布置的，具体配置：</p><table><thead><tr><th>条目</th><th>明细</th></tr></thead><tbody><tr><td>处理器</td><td>2.6 GHz 6‑core Intel Core i7</td></tr><tr><td>图形卡-1</td><td>AMD Radeon Pro 5300M 4 GB</td></tr><tr><td>图形卡-2</td><td>Intel UHD Graphics 630 1536 MB</td></tr><tr><td>内存</td><td>16 GB 2667 MHz DDR4</td></tr><tr><td>储存空间</td><td>512 GB SSD</td></tr></tbody></table><p>我已经过了那个对配置敏感的年纪，拿到这个电脑之后也只会感叹「好漂亮」和「好流畅」了。</p><p>在日常开发中，MacBook Pro 的性能确实绰绰有余，毕竟编译之类的苦差事都是在远程开发机上完成的，本地只是开开 Chrome 和 VS Code 而已。</p><p>P.S. 散热架也是公司发的，感觉薅了太多羊毛。</p><h2 id="2-「公司发的」Dell-U2720Q-4K-显示器"><a href="#2-「公司发的」Dell-U2720Q-4K-显示器" class="headerlink" title="2 「公司发的」Dell U2720Q 4K 显示器"></a>2 「公司发的」Dell U2720Q 4K 显示器</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/02.png" style="zoom:100%"/><p>两台 4K 显示器的幸福，我以前无法想象，现在除了开会和回家以外，MacBook Pro 基本上都是合盖的状态，因为两个显示器已经够我看的了，多了怕鼠标都挪不过来。</p><p>另外一个让人感到幸福的细节，就是可以使用单根 Type-C 数据线合并「显示」、「充电」和「扩展」的功能，显示器的下行接口可以外接键盘和鼠标，极大地节约了 MacBook Pro 的接口数量。</p><p>但是我有两台显示器，为了达到显示的最佳效果，还是不可避免地占用了 MacBook Pro 的两个接口。</p><h2 id="3-「自己买的」DURGOD-TAURUS-K320-茶轴机械键盘"><a href="#3-「自己买的」DURGOD-TAURUS-K320-茶轴机械键盘" class="headerlink" title="3 「自己买的」DURGOD TAURUS K320 茶轴机械键盘"></a>3 「自己买的」DURGOD TAURUS K320 茶轴机械键盘</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/03.png" style="zoom:100%"/><p>当时买这款机械键盘，主要是看中了 PBT 键帽，长期使用不打油的体验也是非常幸福。</p><h2 id="4-「自己买的」Logitech-MX-Master-2S-无线蓝牙鼠标"><a href="#4-「自己买的」Logitech-MX-Master-2S-无线蓝牙鼠标" class="headerlink" title="4 「自己买的」Logitech MX Master 2S 无线蓝牙鼠标"></a>4 「自己买的」Logitech MX Master 2S 无线蓝牙鼠标</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/04.png" style="zoom:50%"/><p>不解释，办公神器。</p><h2 id="5-「自己买的」AirPods-2-无线蓝牙耳机"><a href="#5-「自己买的」AirPods-2-无线蓝牙耳机" class="headerlink" title="5 「自己买的」AirPods 2 无线蓝牙耳机"></a>5 「自己买的」AirPods 2 无线蓝牙耳机</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/05.png" style="zoom:25%"/><p>MacBook Pro 的耳机孔在右侧，使用的有线耳机总是和使用鼠标的手发生干涉，所以我就入手了 AirPods，在一众无线蓝牙耳机中算是最省心的选择了，连接、音质和通话质量都足够稳定，别无他求。</p><h2 id="6-写在最后"><a href="#6-写在最后" class="headerlink" title="6 写在最后"></a>6 写在最后</h2><p>之前在 V2EX 看到一句话，与君共勉：</p><blockquote><p>入职以后，公司给每位员工发了一台电脑，表面上看是每个人拥有了一台电脑，其实是给每台电脑配了一个人。</p></blockquote><hr><h2 id="7-更新（2020-11-26）"><a href="#7-更新（2020-11-26）" class="headerlink" title="7 更新（2020-11-26）"></a>7 更新（2020-11-26）</h2><p>惯例，先放张工作桌面 2.0 的整体照片：</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/11/00.jpg" style="zoom:100%"/><p>改动：</p><ul><li><p>常年合盖使用的 MBP 被我挪到了左侧，这样键盘就可以向前推进，得到伸展的手臂感觉舒适了许多。</p></li><li><p>两个显示器都用包装盒架起了一定的高度，仰在椅子上的时候视线更加舒服了。</p></li><li><p>AirPods 2 =&gt; AirPods Pro，网吧工位少不了降噪。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;不知不觉，已经入职两个月了。&lt;/p&gt;
&lt;p&gt;在这两个月里，我一直在适应工作节奏，所以没有时间更新博客（虽然也没什么人看）。&lt;/p&gt;
&lt;p&gt;在这两个月里，我的工作桌面也在不断进化，不断适应我的使用习惯，到现在也算是个初级形态了，所以打算在这里梳理一下（其实就是想晒装备）。&lt;/p&gt;
&lt;p&gt;先来张工作桌面的整体照片过过瘾：&lt;/p&gt;
&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/00.png&quot; style=&quot;zoom:100%&quot;/&gt;</summary>
    
    
    
    <category term="A01 - 生活随笔" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="折腾" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="Work" scheme="https://progcz.com/tags/Work/"/>
    
    <category term="Desktop" scheme="https://progcz.com/tags/Desktop/"/>
    
    <category term="MacBook Pro" scheme="https://progcz.com/tags/MacBook-Pro/"/>
    
  </entry>
  
  <entry>
    <title>记录一次在上海租房的经历</title>
    <link href="https://progcz.com/posts/record-for-rent-in-shanghai/"/>
    <id>https://progcz.com/posts/record-for-rent-in-shanghai/</id>
    <published>2020-06-13T07:08:48.000Z</published>
    <updated>2021-04-29T15:10:53.052Z</updated>
    
    <content type="html"><![CDATA[<p>入职之前，我预留了一周的时间用来租房，本以为做好了充足的准备，但还是碰到了很多「租房新手」必踩的坑。果然，<strong>小马还是要自己过一遍河才能知道河水的深浅。</strong></p><p>所以，趁着自己的记忆还够新鲜，记录一下这次在上海租房的经历，为以后的自己留下亿点经验和教训。</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/06/00.png" style="zoom:100%"/><span id="more"></span><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1 需求"></a>1 需求</h2><p>在租房之前，需要<strong>梳理一遍自己的需求，哪些是必不可少的，哪些是可以妥协的。</strong></p><p>当然，下面列出的这些需求仅适用于我个人，读者需要自行甄别。</p><h3 id="1-1-必不可少的"><a href="#1-1-必不可少的" class="headerlink" title="1.1 必不可少的"></a>1.1 必不可少的</h3><div class="note warning"><p>对于「必不可少的」需求，一旦确定之后，即便中介再怎么花言巧语，也不能有半点动摇。</p></div><ul><li><p><strong>距离公司的步行时间不超过 15 分钟，</strong>能够有效提升幸福感。</p></li><li><p><strong>房子不在一楼或顶楼，</strong>避免一楼的过于潮湿和顶楼的过冷过热。</p></li><li><p><strong>房间的装修时间至少在一年以上，</strong>避免存在甲醛和苯等污染问题。</p><p>我刚开始租的就是新装修了一个月的房间，年少无知的我觉得只要通风就好了，结果在房间里面待了几个小时之后，嗓子就开始不舒服。所以，我只租了几天，就直接与房东违约，押金自然要不回来了，肉疼但还是保命要紧。</p></li><li><p><strong>独立卫生间，不必与他人分享马桶和浴室，</strong>不管从时间还是空间的角度，都能够有效提升幸福感。</p><p>预算充足的话，可以考虑<strong>「整租」独立的一居室</strong>；预算有限的话，可以考虑<strong>「合租」带独卫的卧室</strong>。</p></li><li><p><strong>家具和家电：床、空调、衣柜、洗衣机、热水器。</strong></p></li></ul><h3 id="1-2-可以妥协的"><a href="#1-2-可以妥协的" class="headerlink" title="1.2 可以妥协的"></a>1.2 可以妥协的</h3><ul><li><p><strong>可以晾衣服的地方。</strong></p><p>预算充足的话，可以考虑<strong>朝南阳台</strong>；预算有限的话，可以考虑<strong>朝南外窗（带外置晾衣架）</strong>。</p><p>当然，朝北也是可以的，毕竟洗衣机甩干后的衣服只要再风干就可以了。</p></li><li><p><strong>厨房。</strong></p></li><li><p><strong>家具和家电：冰箱、电视、沙发。</strong></p></li></ul><h3 id="1-3-其他"><a href="#1-3-其他" class="headerlink" title="1.3 其他"></a>1.3 其他</h3><h4 id="1-3-1-关于二房东"><a href="#1-3-1-关于二房东" class="headerlink" title="1.3.1 关于二房东"></a>1.3.1 关于二房东</h4><p>我之前看过的很多租房攻略都有提到：千万不要租二房东的房子。</p><p>但是，其实有相当一部分的房源都来自<strong>「职业」二房东</strong>，这种二房东并不是真正的租客，而是因为原房东手中有闲置的房子而又怕麻烦，于是将房子出租给二房东，由二房东来管理出租的事情。真正应该避开的是<strong>「非职业」二房东</strong>，这种二房东是真正的租客，但是因为某些原因而不得已将其转租，在这种情况下就很难保障自己的租房权益。</p><p>所以，可以要求<strong>查看二房东的原租房合同和原房东的房产证。</strong>查看租房合同是否长达数年，就可以大致判断是否为「职业」二房东。而且，查看租房合同的开始日期，也可以大致判断房间的装修时间。</p><h4 id="1-3-2-关于隔断"><a href="#1-3-2-关于隔断" class="headerlink" title="1.3.2 关于隔断"></a>1.3.2 关于隔断</h4><p>预算有限的话，一般只能考虑隔断的房间了。但是，隔断属于违规建筑，其最大的风险在于<strong>房间可能随时会被政府强拆。</strong></p><p>所以，可以要求<strong>在租房合同中注明：如果房间因为违规建筑而导致乙方无法居住，那么不算乙方违约，甲方需退还押金和剩余租金。</strong></p><div class="note info"><p>问：如何判断隔断？</p><p>答：实地看房时敲一下四周的墙。如果声音很闷，就是原装的墙，如果声音很响，就是隔断的墙。</p></div><h2 id="2-找房"><a href="#2-找房" class="headerlink" title="2 找房"></a>2 找房</h2><h3 id="2-1-短租"><a href="#2-1-短租" class="headerlink" title="2.1 短租"></a>2.1 短租</h3><p>我没有短租过，但是个人感觉短租的话直接选择<strong>自如或蛋壳</strong>即可，省心省力且价格也没有高很多。</p><p>但是，自如或蛋壳被人诟病最多的就是污染问题，所以需要实地看房，感受一下房间内的空气质量。</p><h3 id="2-2-长租"><a href="#2-2-长租" class="headerlink" title="2.2 长租"></a>2.2 长租</h3><p>长租的话还是建议找当地的<strong>大中介</strong>，比如链家、我爱我家等。</p><h2 id="3-看房"><a href="#3-看房" class="headerlink" title="3 看房"></a>3 看房</h2><p>这一步主要是看房间是否满足需求，同时检查一下房间内设施的基本情况，包括但不仅限于：</p><ul><li><p>检查是否新装修，是否存在污染问题。</p></li><li><p>检查防盗门、窗户是否完好。</p></li><li><p>检查家具、家电是否老化。</p></li><li><p>检查水管是否通畅、电路是否老化。</p></li><li><p>检查卫生情况。</p></li></ul><h2 id="4-签订合同"><a href="#4-签订合同" class="headerlink" title="4 签订合同"></a>4 签订合同</h2><p>大中介的合同一般没有什么问题，只是需要注意以下几点：</p><ul><li><p><strong>明确费用明细，</strong>包括但不仅限于：押金、房租、中介费、服务费、物业费、水电费、煤气费、宽带费、维修费等。</p></li><li><p><strong>明确房东和房客的违约条款。</strong></p></li><li><p><strong>拍照或录像记录房间内设施的基本情况，</strong>避免后续的维修纠纷。</p></li><li><p><strong>（独居女生尤其注意）与房东沟通是否可以换锁。</strong></p></li><li><p><strong>与房东当面签订合同，拍照留存房东的身份证、房产证，如果是二房东，拍照留存二房东的原租房合同和原房东的身份证、房产证。</strong></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;入职之前，我预留了一周的时间用来租房，本以为做好了充足的准备，但还是碰到了很多「租房新手」必踩的坑。果然，&lt;strong&gt;小马还是要自己过一遍河才能知道河水的深浅。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，趁着自己的记忆还够新鲜，记录一下这次在上海租房的经历，为以后的自己留下亿点经验和教训。&lt;/p&gt;
&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/06/00.png&quot; style=&quot;zoom:100%&quot;/&gt;</summary>
    
    
    
    <category term="A01 - 生活随笔" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="经历" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="Life" scheme="https://progcz.com/tags/Life/"/>
    
    <category term="Shanghai" scheme="https://progcz.com/tags/Shanghai/"/>
    
    <category term="Rent" scheme="https://progcz.com/tags/Rent/"/>
    
  </entry>
  
  <entry>
    <title>记录使用 IFTTT + Telegram 订阅 RSS 的推送模板</title>
    <link href="https://progcz.com/posts/record-use-ifttt-tg-sub-rss-push-template/"/>
    <id>https://progcz.com/posts/record-use-ifttt-tg-sub-rss-push-template/</id>
    <published>2020-05-24T10:30:11.000Z</published>
    <updated>2021-04-29T15:10:53.052Z</updated>
    
    <content type="html"><![CDATA[<p>对于大部分使用 RSS 的人来说，RSS 最大的优势便是能够提供<strong>「聚合阅读」</strong>的功能，也就是在一个地方阅读多篇不同来源的文章，而且可以自主选择订阅源，拒绝推荐引擎的「投喂」。然而对于我来说，RSS 还有一个重要的作用在于能够提供<strong>「即时通知」</strong>的功能，也就是<strong>「一旦发生了什么，请立刻通知我」</strong>。</p><p>所以，为了实现<strong>「即时通知」</strong>的功能，<strong>可以使用 IFTTT 将 RSS 订阅内容推送至 Telegram 的对话、群组或公开频道，形成属于自己的「信息流」。</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/10.png" style="zoom:100%"/><span id="more"></span><h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0 写在前面"></a>0 写在前面</h2><p>本文不介绍具体教程，只记录其中使用的推送模板，留作以后参考。</p><p><strong>如果你想了解具体教程，推荐参考<a href="https://sword.studio/157.html">这篇文章</a>。</strong></p><p>另外，<strong>如果你也使用 <a href="https://docs.rsshub.app/">RSSHub</a>，推荐参考<a href="https://docs.rsshub.app/install/#bu-shu-dao-vercel-zeit-now">官方文档</a>将其部署至 <a href="https://vercel.com/">Vercel</a>，</strong>从而搭建属于自己的订阅引擎。</p><h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1 应用场景"></a>1 应用场景</h2><p>在 Telegram 中，我创建了两个公开频道，分别是：</p><ul><li><p><strong><a href="https://t.me/ProgCZChannel">ProgCZ’s Blog - Channel</a> 用于同步本博客更新的文章。</strong></p></li><li><p><strong><a href="https://t.me/ProgCZFlow">ProgCZ’s Flow</a> 用于建立专属于自己的信息流。</strong></p></li></ul><h2 id="2-推送模板"><a href="#2-推送模板" class="headerlink" title="2 推送模板"></a>2 推送模板</h2><p>在 IFTTT 中，需要设置推送模板，分为两种情况：</p><ul><li><p><strong>对于内容较多的订阅源（比如博客文章），只是推送其标题、链接和来源，</strong>模板如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标题：&lt;b&gt;&#123;&#123;EntryTitle&#125;&#125;&lt;&#x2F;b&gt;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">链接：&lt;b&gt;&#123;&#123;EntryUrl&#125;&#125;&lt;&#x2F;b&gt;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">来自：&lt;a href&#x3D;&quot;&#123;&#123;FeedUrl&#125;&#125;&quot;&gt;&#123;&#123;FeedTitle&#125;&#125;&lt;&#x2F;a&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure><p>同时，<strong>开启「网页预览」功能。</strong></p></li><li><p><strong>对于内容较少的订阅源（比如购物优惠），推送其标题、内容、链接和来源，</strong>模板如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标题：&lt;b&gt;&#123;&#123;EntryTitle&#125;&#125;&lt;&#x2F;b&gt;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&#123;&#123;EntryContent&#125;&#125;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">链接：&lt;b&gt;&#123;&#123;EntryUrl&#125;&#125;&lt;&#x2F;b&gt;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">来自：&lt;a href&#x3D;&quot;&#123;&#123;FeedUrl&#125;&#125;&quot;&gt;&#123;&#123;FeedTitle&#125;&#125;&lt;&#x2F;a&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure><p>同时，<strong>关闭「网页预览」功能。</strong></p></li></ul><h2 id="3-预览效果"><a href="#3-预览效果" class="headerlink" title="3 预览效果"></a>3 预览效果</h2><p>如果你想预览效果，可以在科学环境中访问 <a href="https://t.me/s/ProgCZChannel">ProgCZ’s Blog - Channel</a> 和 <a href="https://t.me/s/ProgCZFlow">ProgCZ’s Flow</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于大部分使用 RSS 的人来说，RSS 最大的优势便是能够提供&lt;strong&gt;「聚合阅读」&lt;/strong&gt;的功能，也就是在一个地方阅读多篇不同来源的文章，而且可以自主选择订阅源，拒绝推荐引擎的「投喂」。然而对于我来说，RSS 还有一个重要的作用在于能够提供&lt;strong&gt;「即时通知」&lt;/strong&gt;的功能，也就是&lt;strong&gt;「一旦发生了什么，请立刻通知我」&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以，为了实现&lt;strong&gt;「即时通知」&lt;/strong&gt;的功能，&lt;strong&gt;可以使用 IFTTT 将 RSS 订阅内容推送至 Telegram 的对话、群组或公开频道，形成属于自己的「信息流」。&lt;/strong&gt;&lt;/p&gt;
&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/10.png&quot; style=&quot;zoom:100%&quot;/&gt;</summary>
    
    
    
    <category term="A01 - 生活随笔" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="折腾" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="IFTTT" scheme="https://progcz.com/tags/IFTTT/"/>
    
    <category term="Telegram" scheme="https://progcz.com/tags/Telegram/"/>
    
    <category term="RSS" scheme="https://progcz.com/tags/RSS/"/>
    
  </entry>
  
  <entry>
    <title>使用 Cloudflare Workers 搭建 Google 和 GitHub 镜像网站</title>
    <link href="https://progcz.com/posts/use-cf-workers-build-google-and-github-mirrors/"/>
    <id>https://progcz.com/posts/use-cf-workers-build-google-and-github-mirrors/</id>
    <published>2020-05-23T13:32:58.000Z</published>
    <updated>2021-04-29T15:10:53.052Z</updated>
    
    <content type="html"><![CDATA[<p>对于 Google 来说，虽然大部分时间都能够在科学环境中网上冲浪，但是<strong>难免有需要在普通环境中使用 Google 的情况，</strong>而对于 GitHub 来说，虽然目前可以无障碍访问，但是<strong>在普通环境中下载某些 Release（比如科学工具的客户端）的速度实在太慢。</strong></p><p>如果你也有和我一样的困扰，那么可以考虑<strong>使用 Cloudflare Workers 搭建属于自己的镜像网站，</strong>在普通环境中备用。</p><span id="more"></span><h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0 写在前面"></a>0 写在前面</h2><p>如果你只是在寻找临时的解决方案，而又不想费劲的话，那么可以直接使用我已经搭建好的镜像网站。</p><div class="note warning"><p>但是，请你务必遵守以下约定：</p><ol><li><p><strong>不滥用服务。</strong>因为每个 Cloudflare 账户每天只有 100,000 次请求的额度。</p></li><li><p><strong>不登录自己的任何账号。</strong>虽然我保证不拦截你的数据，但是防人之心不可无。</p></li><li><p><strong>不违反大陆的法律法规。</strong>虽然你需要科学，但是请保持理性。</p></li></ol></div><ul><li><p>Google 镜像网站：<a href="https://google.progcz.workers.dev/">https://google.progcz.workers.dev/</a></p></li><li><p>GitHub 镜像网站：<a href="https://github.progcz.workers.dev/">https://github.progcz.workers.dev/</a></p></li></ul><h2 id="1-注册并登录-Cloudflare-账号"><a href="#1-注册并登录-Cloudflare-账号" class="headerlink" title="1 注册并登录 Cloudflare 账号"></a>1 注册并登录 Cloudflare 账号</h2><p>这没啥好说的，前往 [Cloudflare 官网](&lt;<a href="https://www.cloudflare.com/)%E8%87%AA%E8%A1%8C%E6%B3%A8%E5%86%8C%E5%B9%B6%E7%99%BB%E5%BD%95%EF%BC%8C%E7%84%B6%E5%90%8E**%E7%82%B9%E5%87%BB%E3%80%8CWorkers%E3%80%8D%E3%80%82">https://www.cloudflare.com/)自行注册并登录，然后**点击「Workers」。</a>**</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/06.png" style="zoom:100%"/><h2 id="2-创建新的-Worker-应用"><a href="#2-创建新的-Worker-应用" class="headerlink" title="2 创建新的 Worker 应用"></a>2 创建新的 Worker 应用</h2><p>进入 Workers 页面之后，新用户需要设置用户名（比如 <code>progcz</code>），然后<strong>点击「创建 Worker」。</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/07.png" style="zoom:100%"/><h2 id="3-部署-Worker-应用"><a href="#3-部署-Worker-应用" class="headerlink" title="3 部署 Worker 应用"></a>3 部署 Worker 应用</h2><p><strong>自行修改应用名（比如 <code>test</code>），将 <a href="https://github.com/ProgCZ/code-cloud-a/blob/master/2020/05/cf-workers-mirrors/index.js">index.js</a> 中的代码拷贝至脚本中，点击「保存并部署」，</strong>然后就可以通过 <a href="https://test.progcz.workers.dev/">https://test.progcz.workers.dev/</a>（注意替换应用名 <code>test</code> 和用户名 <code>progcz</code>）访问 Google 的镜像网站了。</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/08.png" style="zoom:100%"/><h2 id="4-自定义-index-js-脚本"><a href="#4-自定义-index-js-脚本" class="headerlink" title="4 自定义 index.js 脚本"></a>4 自定义 index.js 脚本</h2><div class="note info"><p>上文的 <a href="https://github.com/ProgCZ/code-cloud-a/blob/master/2020/05/cf-workers-mirrors/index.js">index.js</a> 其实来自于 <a href="https://github.com/Berkeley-Reject/Workers-Proxy">Berkeley-Reject/Workers-Proxy</a> 仓库，但是代码中设置了对于国内访问的屏蔽，所以为了避免误用，我就在自行修改之后保存了一份。</p></div><p>可以通过修改以下部分来搭建不同的镜像网站：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Website you intended to retrieve for users.</span></span><br><span class="line"><span class="keyword">const</span> upstream = <span class="string">&#x27;www.google.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Custom pathname for the upstream website.</span></span><br><span class="line"><span class="keyword">const</span> upstream_path = <span class="string">&#x27;/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Website you intended to retrieve for users using mobile devices.</span></span><br><span class="line"><span class="keyword">const</span> upstream_mobile = <span class="string">&#x27;www.google.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Countries and regions where you wish to suspend your service.</span></span><br><span class="line"><span class="keyword">const</span> blocked_region = [<span class="string">&#x27;KP&#x27;</span>, <span class="string">&#x27;SY&#x27;</span>, <span class="string">&#x27;PK&#x27;</span>, <span class="string">&#x27;CU&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// IP addresses which you wish to block from using your service.</span></span><br><span class="line"><span class="keyword">const</span> blocked_ip_address = [<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Whether to use HTTPS protocol for upstream address.</span></span><br><span class="line"><span class="keyword">const</span> https = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Whether to disable cache.</span></span><br><span class="line"><span class="keyword">const</span> disable_cache = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace texts.</span></span><br><span class="line"><span class="keyword">const</span> replace_dict = &#123;</span><br><span class="line">    <span class="string">&#x27;$upstream&#x27;</span>: <span class="string">&#x27;$custom_domain&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;//google.com&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p>需要注意的是，上述代码只是 <a href="https://github.com/ProgCZ/code-cloud-a/blob/master/2020/05/cf-workers-mirrors/index.js">index.js</a> 的一小部分。</p></div><p>比如，对于 GitHub 来说，我们只需要<strong>将 <code>upstream</code>、<code>upstream_mobile</code> 和 <code>replace_dict</code> 中的 <code>google.com</code> 修改为 <code>github.com</code> 即可。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于 Google 来说，虽然大部分时间都能够在科学环境中网上冲浪，但是&lt;strong&gt;难免有需要在普通环境中使用 Google 的情况，&lt;/strong&gt;而对于 GitHub 来说，虽然目前可以无障碍访问，但是&lt;strong&gt;在普通环境中下载某些 Release（比如科学工具的客户端）的速度实在太慢。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你也有和我一样的困扰，那么可以考虑&lt;strong&gt;使用 Cloudflare Workers 搭建属于自己的镜像网站，&lt;/strong&gt;在普通环境中备用。&lt;/p&gt;</summary>
    
    
    
    <category term="A01 - 生活随笔" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="折腾" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="GitHub" scheme="https://progcz.com/tags/GitHub/"/>
    
    <category term="Cloudflare" scheme="https://progcz.com/tags/Cloudflare/"/>
    
    <category term="Google" scheme="https://progcz.com/tags/Google/"/>
    
    <category term="Mirror" scheme="https://progcz.com/tags/Mirror/"/>
    
  </entry>
  
  <entry>
    <title>2020 May LeetCoding Challenge - Week 4</title>
    <link href="https://progcz.com/posts/2020-may-leetcoding-challenge-week-4/"/>
    <id>https://progcz.com/posts/2020-may-leetcoding-challenge-week-4/</id>
    <published>2020-05-22T11:55:57.000Z</published>
    <updated>2020-05-28T11:24:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 五月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-May-LeetCoding-Challenge/">2020 May LeetCoding Challenge</a> 查看更多。</p><span id="more"></span><h2 id="May-22nd-Sort-Characters-By-Frequency"><a href="#May-22nd-Sort-Characters-By-Frequency" class="headerlink" title="May 22nd: Sort Characters By Frequency"></a>May 22nd: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3337/">Sort Characters By Frequency</a></h2><p>Given a string, sort it in decreasing order based on the frequency of characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;tree&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;eert&quot;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">&#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.</span><br><span class="line">So &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Both &#39;c&#39; and &#39;a&#39; appear three times, so &quot;aaaccc&quot; is also a valid answer.</span><br><span class="line">Note that &quot;cacaca&quot; is incorrect, as the same characters must be together.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;Aabb&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;bbAa&quot;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">&quot;bbaA&quot; is also a valid answer, but &quot;Aabb&quot; is incorrect.</span><br><span class="line">Note that &#39;A&#39; and &#39;a&#39; are treated as two different characters.</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用 <code>vector&lt;pair&lt;int, char&gt;&gt; vec(256)</code> 保存字符串 <code>s</code> 中<strong>每个字符出现的次数</strong>及<strong>字符本身</strong>。从大到小进行排序之后，重新拼接成新的字符串 <code>res</code> 即可。</p><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">frequencySort</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;&gt; <span class="built_in">vec</span>(<span class="number">256</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[ch].first++ == <span class="number">0</span>) &#123;</span><br><span class="line">                vec[ch].second = ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">rbegin</span>(), vec.<span class="built_in">rend</span>());</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : vec) &#123;</span><br><span class="line">            res += <span class="built_in">string</span>(p.first, p.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-23rd-Interval-List-Intersections"><a href="#May-23rd-Interval-List-Intersections" class="headerlink" title="May 23rd: Interval List Intersections"></a>May 23rd: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3338/">Interval List Intersections</a></h2><p>Given two lists of <strong>closed</strong> intervals, each list of intervals is pairwise disjoint and in sorted order.</p><p>Return the intersection of these two interval lists.</p><p><em>(Formally, a closed interval <code>[a, b]</code> (with <code>a &lt;= b</code>) denotes the set of real numbers <code>x</code> with <code>a &lt;= x &lt;= b</code>. The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3].)</em></p><p><strong>Example 1:</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/05.png" style="zoom:80%"/><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A &#x3D; [[0,2],[5,10],[13,23],[24,25]], B &#x3D; [[1,5],[8,12],[15,24],[25,26]]</span><br><span class="line">Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]</span><br><span class="line">Reminder: The inputs and the desired output are lists of Interval objects, and not arrays or lists.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p><code>0 &lt;= A.length &lt; 1000</code></p></li><li><p><code>0 &lt;= B.length &lt; 1000</code></p></li><li><p><code>0 &lt;= A[i].start, A[i].end, B[i].start, B[i].end &lt; 10^9</code></p></li></ul><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>因为 <code>A</code> 和 <code>B</code> 的数据量都不大，所以可以嵌套遍历。在遍历过程中：</p><ul><li><p><strong>如果 <code>a</code> 的右界小于 <code>b</code> 的左界，说明两者不相交，而且因为 <code>B</code> 有序，所以 <code>b</code> 之后的区间也不可能与 <code>a</code> 相交，跳出小循环。</strong></p></li><li><p><strong>如果 <code>a</code> 的左界大于 <code>b</code> 的右界，说明两者不相交，进入下一次小循环。</strong></p></li></ul><p>如果两者相交，那么两者<strong>左界的最大值和右界的最小值之间就是相交的区间。</strong></p><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">intervalIntersection</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; B) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : A) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> b : B) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[<span class="number">1</span>] &lt; b[<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (a[<span class="number">0</span>] &gt; b[<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;<span class="built_in">max</span>(a[<span class="number">0</span>], b[<span class="number">0</span>]), <span class="built_in">min</span>(a[<span class="number">1</span>], b[<span class="number">1</span>])&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-24th-Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#May-24th-Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="May 24th: Construct Binary Search Tree from Preorder Traversal"></a>May 24th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3339/">Construct Binary Search Tree from Preorder Traversal</a></h2><p>Return the root node of a binary <strong>search</strong> tree that matches the given <code>preorder</code> traversal.</p><p><em>(Recall that a binary search tree is a binary tree where for every node, any descendant of <code>node.left</code> has a value <code>&lt; node.val</code>, and any descendant of <code>node.right</code> has a value <code>&gt; node.val</code>. Also recall that a preorder traversal displays the value of the <code>node</code> first, then traverses <code>node.left</code>, then traverses <code>node.right</code>.)</em></p><p>It’s guaranteed that for the given test cases there is always possible to find a binary search tree with the given requirements.</p><p><strong>Example 1:</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/09.png" style="zoom:80%"/><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [8,5,1,7,10,12]</span><br><span class="line">Output: [8,5,10,1,7,null,12]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><p><code>1 &lt;= preorder.length &lt;= 100</code></p></li><li><p><code>1 &lt;= preorder[i] &lt;= 10^8</code></p></li><li><p>The values of <code>preorder</code> are distinct.</p></li></ul><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p><strong>利用 <code>func</code> 函数将 <code>preorder</code> 的 <code>[beg, end]</code> 区间分割为根节点、左子树和右子树。</strong>具体地：</p><ul><li><p>对于根节点，因为 <code>preorder</code> 是前序遍历，所以<strong>根节点必然是 <code>preorder[beg]</code>。</strong></p></li><li><p>对于左子树和右子树，在 <code>preorder</code> 的 <code>[beg+1, end]</code> 区间内遍历寻找第一个大于 <code>preorder[beg]</code> 的数字，其下标为 <code>idx</code>，那么<strong>左子树必然是 <code>preorder[beg+1, idx-1]</code>，右子树必然是 <code>preorder[idx, end]</code>。</strong></p></li></ul><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstFromPreorder</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">func</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;preorder, <span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beg &gt; end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = beg + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt;= end &amp;&amp; preorder[idx] &lt; preorder[beg]) ++idx;</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[beg]);</span><br><span class="line">        node-&gt;left = <span class="built_in">func</span>(preorder, beg+<span class="number">1</span>, idx<span class="number">-1</span>);</span><br><span class="line">        node-&gt;right = <span class="built_in">func</span>(preorder, idx, end);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-25th-Uncrossed-Lines"><a href="#May-25th-Uncrossed-Lines" class="headerlink" title="May 25th: Uncrossed Lines"></a>May 25th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3340/">Uncrossed Lines</a></h2><p>We write the integers of <code>A</code> and <code>B</code> (in the order they are given) on two separate horizontal lines.</p><p>Now, we may draw connecting lines: a straight line connecting two numbers <code>A[i]</code> and <code>B[j]</code> such that:</p><ul><li><p><code>A[i] == B[j]</code>;</p></li><li><p>The line we draw does not intersect any other connecting (non-horizontal) line.</p></li></ul><p>Note that a connecting lines cannot intersect even at the endpoints: each number can only belong to one connecting line.</p><p>Return the maximum number of connecting lines we can draw in this way.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A &#x3D; [1,4,2], B &#x3D; [1,2,4]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We can draw 2 uncrossed lines as in the diagram.</span><br><span class="line">We cannot draw 3 uncrossed lines, because the line from A[1]&#x3D;4 to B[2]&#x3D;4 will intersect the line from A[2]&#x3D;2 to B[1]&#x3D;2.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A &#x3D; [2,5,1,2,5], B &#x3D; [10,5,2,1,5,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A &#x3D; [1,3,7,1,7,5], B &#x3D; [1,9,2,5,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p><code>1 &lt;= A.length &lt;= 500</code></p></li><li><p><code>1 &lt;= B.length &lt;= 500</code></p></li><li><p><code>1 &lt;= A[i], B[i] &lt;= 2000</code></p></li></ul><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://leetcode.com/problems/uncrossed-lines/discuss/650947/C%2B%2B-DP-with-explanation">C++ DP with explanation</a></p><p>P.S. 嗨，看着动态规划的代码感觉还挺好理解的，自己写就写不出来。</p><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.<span class="built_in">size</span>(), n = B.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i] == B[j]) dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span> + dp[i][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="built_in">max</span>(dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-26th-Contiguous-Array"><a href="#May-26th-Contiguous-Array" class="headerlink" title="May 26th: Contiguous Array"></a>May 26th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3341/">Contiguous Array</a></h2><p>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,1,0]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> The length of the given binary array will not exceed 50,000.</p><h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://www.cnblogs.com/grandyang/p/6529857.html">[LeetCode] 525. Contiguous Array 相连的数组 - 刷尽天下</a></p><p>遍历 <code>nums</code> 中的数字 <code>num</code>，如果为 <code>1</code> 则累加 <code>1</code> 至 <code>sum</code>，如果为 <code>0</code> 则累加 <code>-1</code> 至 <code>sum</code>。</p><p>使用 <code>map&lt;int, int&gt; m</code> 记录首次出现某个 <code>sum</code> 的下标，如果之后再次出现该 <code>sum</code>，说明两者之间的子数组满足题目要求，寻找其长度的最大值即可。</p><h4 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(), sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sum += nums[i] ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(sum)) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, i-m[sum]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                m[sum] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-27th-Possible-Bipartition"><a href="#May-27th-Possible-Bipartition" class="headerlink" title="May 27th: Possible Bipartition"></a>May 27th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3342/">Possible Bipartition</a></h2><p>Given a set of <code>N</code> people (numbered <code>1, 2, ..., N</code>), we would like to split everyone into two groups of <strong>any</strong> size.</p><p>Each person may dislike some other people, and they should not go into the same group.</p><p>Formally, if <code>dislikes[i] = [a, b]</code>, it means it is not allowed to put the people numbered <code>a</code> and <code>b</code> into the same group.</p><p>Return <code>true</code> if and only if it is possible to split everyone into two groups in this way.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 4, dislikes &#x3D; [[1,2],[1,3],[2,4]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: group1 [1,4], group2 [2,3]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 3, dislikes &#x3D; [[1,2],[1,3],[2,3]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 5, dislikes &#x3D; [[1,2],[2,3],[3,4],[4,5],[1,5]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p><code>1 &lt;= N &lt;= 2000</code></p></li><li><p><code>0 &lt;= dislikes.length &lt;= 10000</code></p></li><li><p><code>1 &lt;= dislikes[i][j] &lt;= N</code></p></li><li><p><code>dislikes[i][0] &lt; dislikes[i][1]</code></p></li><li><p>There does not exist <code>i != j</code> for which <code>dislikes[i] == dislikes[j]</code>.</p></li></ul><h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://www.cnblogs.com/grandyang/p/10317141.html">[LeetCode] 886. Possible Bipartition 可能的二分图 - 刷尽天下</a></p><p>放弃治疗，直接看大佬的解法吧。</p><h4 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">possibleBipartition</span><span class="params">(<span class="keyword">int</span> N, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; dislikes)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">g</span>(N+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(N+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> dislike : dislikes) &#123;</span><br><span class="line">            g[dislike[<span class="number">0</span>]][dislike[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">            g[dislike[<span class="number">1</span>]][dislike[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">colors</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (colors[i] == <span class="number">0</span> &amp;&amp; !<span class="built_in">func</span>(g, i, <span class="number">1</span>, colors)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; g, <span class="keyword">int</span> cur, <span class="keyword">int</span> color, vector&lt;<span class="keyword">int</span>&gt;&amp; colors)</span> </span>&#123;</span><br><span class="line">        colors[cur] = color;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[cur][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (colors[i] == color) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (colors[i] == <span class="number">0</span> &amp;&amp; !<span class="built_in">func</span>(g, i, -color, colors)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-28th-Counting-Bits"><a href="#May-28th-Counting-Bits" class="headerlink" title="May 28th: Counting Bits"></a>May 28th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3343/">Counting Bits</a></h2><p>Given a non negative integer number <strong>num</strong>. For every numbers <strong>i</strong> in the range <strong>0 ≤ i ≤ num</strong> calculate the number of 1’s in their binary representation and return them as an array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: [0,1,1]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure><h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>充分利用之前的结果：计算 <code>i</code> 中 <code>1</code> 的个数，那么只需要知道 <code>i&gt;&gt;1</code> 中 <code>1</code> 的个数（即 <code>res[i&gt;&gt;1]</code>）和 <code>i</code> 的最后一位是否为 <code>1</code>（即 <code>i&amp;0x1</code>），相加即可。</p><h4 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(res[i&gt;&gt;<span class="number">1</span>]+(i&amp;<span class="number">0x1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 五月挑战专题每日随缘更新，点击类别 &lt;a href=&quot;/categories/2020-May-LeetCoding-Challenge/&quot;&gt;2020 May LeetCoding Challenge&lt;/a&gt; 查看更多。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="2020 LeetCoding Challenge" scheme="https://progcz.com/categories/A03-LeetCode/2020-LeetCoding-Challenge/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Data Structure and Algorithm" scheme="https://progcz.com/tags/Data-Structure-and-Algorithm/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Challenge" scheme="https://progcz.com/tags/Challenge/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Weekly Contest 189 (1450 - 1453)</title>
    <link href="https://progcz.com/posts/leetcode-weekly-contest-189-1450-1453/"/>
    <id>https://progcz.com/posts/leetcode-weekly-contest-189-1450-1453/</id>
    <published>2020-05-17T06:53:16.000Z</published>
    <updated>2021-04-29T15:10:53.052Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 周赛专题每周随缘更新，点击类别 <a href="/categories/LeetCode-Weekly-Contest/">LeetCode Weekly Contest</a> 查看更多。</p><p>本次比赛通过 <code>3</code> 题，时间为 <code>0:48:25</code>，排名为 <code>2708/13036</code>。</p><span id="more"></span><h2 id="1450-Number-of-Students-Doing-Homework-at-a-Given-Time-Easy"><a href="#1450-Number-of-Students-Doing-Homework-at-a-Given-Time-Easy" class="headerlink" title="1450. Number of Students Doing Homework at a Given Time #Easy"></a><a href="https://leetcode.com/contest/weekly-contest-189/problems/number-of-students-doing-homework-at-a-given-time/">1450. Number of Students Doing Homework at a Given Time</a> #Easy</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>侮辱智商，不解释了。</p><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">busyStudent</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; startTime, vector&lt;<span class="keyword">int</span>&gt;&amp; endTime, <span class="keyword">int</span> queryTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = startTime.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (startTime[i] &lt;= queryTime &amp;&amp; endTime[i] &gt;= queryTime) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1451-Rearrange-Words-in-a-Sentence-Medium"><a href="#1451-Rearrange-Words-in-a-Sentence-Medium" class="headerlink" title="1451. Rearrange Words in a Sentence #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-189/problems/rearrange-words-in-a-sentence">1451. Rearrange Words in a Sentence</a> #Medium</h2><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用 <code>vector&lt;pair&lt;vector&lt;int&gt;, string&gt;&gt; vec</code> 存放分割后的子字符串，<strong>其中 <code>vector&lt;int&gt;</code> 包含两个数字，第一个为字符串的长度，第二个为字符串的序号，</strong>从而在之后的 <code>sort</code> 中按照字符串的长度排序，如果长度相等，则按照字符串的原顺序排序。</p><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">arrangeWords</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        text[<span class="number">0</span>] -= <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        text.<span class="built_in">push_back</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, cur = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        vector&lt;pair&lt;vector&lt;<span class="keyword">int</span>&gt;, string&gt;&gt; vec;</span><br><span class="line">        <span class="keyword">while</span> ((cur = text.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>, pre)) != string::npos) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;cur-pre, cnt++&#125;,</span><br><span class="line">                                    text.<span class="built_in">substr</span>(pre, cur-pre)));</span><br><span class="line">            pre = cur+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : vec) res += p.second + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">        res[<span class="number">0</span>] += <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1452-People-Whose-List-of-Favorite-Companies-Is-Not-a-Subset-of-Another-List-Medium"><a href="#1452-People-Whose-List-of-Favorite-Companies-Is-Not-a-Subset-of-Another-List-Medium" class="headerlink" title="1452. People Whose List of Favorite Companies Is Not a Subset of Another List #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-189/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/">1452. People Whose List of Favorite Companies Is Not a Subset of Another List</a> #Medium</h2><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，<strong>将每组公司从 <code>vector&lt;string&gt;</code> 重新组织为 <code>set&lt;string&gt;</code>，</strong>从而方便后续查找。</p><p>其次，嵌套遍历，<strong>其中 <code>b1</code> 用于标记 <code>vec[i]</code> 是否包含于其他任何组，<code>b2</code> 用于标记 <code>vec[i]</code> 是否包含于 <code>vec[j]</code>。</strong></p><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">peopleIndexes</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; favoriteCompanies)</span> </span>&#123;</span><br><span class="line">        vector&lt;set&lt;string&gt;&gt; vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> vs : favoriteCompanies) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(set&lt;string&gt;(vs.<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">bool</span> b1 = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vec[i].<span class="built_in">size</span>() &gt;= vec[j].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">bool</span> b2 = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> s : vec[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (vec[j].<span class="built_in">find</span>(s) == vec[j].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        b2 = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (b2) b1 = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!b1) res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1453-Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard-Hard"><a href="#1453-Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard-Hard" class="headerlink" title="1453. Maximum Number of Darts Inside of a Circular Dartboard #Hard"></a><a href="https://leetcode.com/contest/weekly-contest-189/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/">1453. Maximum Number of Darts Inside of a Circular Dartboard</a> #Hard</h2><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/discuss/636416/c%2B%2B-O(n2logn)-angular-sweep-(with-picture)">[c++] O(n^2logn), angular sweep (with picture)</a></p><p>又是放弃治疗系列，直接看大佬的解法吧。</p><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numPoints</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">double</span>&gt;&gt; <span class="built_in">dist</span>(n, vector&lt;<span class="keyword">double</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                dist[i][j] = dist[j][i] = <span class="built_in">sqrt</span>((points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) * (points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) +</span><br><span class="line">                                               (points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]) * (points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            vector&lt;pair&lt;<span class="keyword">double</span>, <span class="keyword">bool</span>&gt;&gt; angles;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != i &amp;&amp; dist[i][j] &lt;= <span class="number">2</span> * r) &#123;</span><br><span class="line">                    <span class="keyword">double</span> A = <span class="built_in">atan2</span>(points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>], points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">double</span> B = <span class="built_in">acos</span>(dist[i][j] / (<span class="number">2.0</span> * r));</span><br><span class="line">                    <span class="keyword">double</span> alpha = A - B;</span><br><span class="line">                    <span class="keyword">double</span> beta = A + B;</span><br><span class="line">                    angles.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(alpha, <span class="literal">false</span>));</span><br><span class="line">                    angles.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(beta, <span class="literal">true</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(angles.<span class="built_in">begin</span>(), angles.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = angles.<span class="built_in">begin</span>(); it != angles.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((*it).second == <span class="literal">false</span>) ++cnt;</span><br><span class="line">                <span class="keyword">else</span> --cnt;</span><br><span class="line">                res = <span class="built_in">max</span>(res, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 周赛专题每周随缘更新，点击类别 &lt;a href=&quot;/categories/LeetCode-Weekly-Contest/&quot;&gt;LeetCode Weekly Contest&lt;/a&gt; 查看更多。&lt;/p&gt;
&lt;p&gt;本次比赛通过 &lt;code&gt;3&lt;/code&gt; 题，时间为 &lt;code&gt;0:48:25&lt;/code&gt;，排名为 &lt;code&gt;2708/13036&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="LeetCode Weekly Contest" scheme="https://progcz.com/categories/A03-LeetCode/LeetCode-Weekly-Contest/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Data Structure and Algorithm" scheme="https://progcz.com/tags/Data-Structure-and-Algorithm/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 May LeetCoding Challenge - Week 3</title>
    <link href="https://progcz.com/posts/2020-may-leetcoding-challenge-week-3/"/>
    <id>https://progcz.com/posts/2020-may-leetcoding-challenge-week-3/</id>
    <published>2020-05-15T08:23:22.000Z</published>
    <updated>2020-05-21T08:24:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 五月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-May-LeetCoding-Challenge/">2020 May LeetCoding Challenge</a> 查看更多。</p><span id="more"></span><h2 id="May-15th-Maximum-Sum-Circular-Subarray"><a href="#May-15th-Maximum-Sum-Circular-Subarray" class="headerlink" title="May 15th: Maximum Sum Circular Subarray"></a>May 15th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/536/week-3-may-15th-may-21st/3330/">Maximum Sum Circular Subarray</a></h2><p>Given a <strong>circular array C</strong> of integers represented by <code>A</code>, find the maximum possible sum of a non-empty subarray of <strong>C</strong>.</p><p>Here, a <em>circular array</em> means the end of the array connects to the beginning of the array. (Formally, <code>C[i] = A[i]</code> when <code>0 &lt;= i &lt; A.length</code>, and <code>C[i+A.length] = C[i]</code> when <code>i &gt;= 0</code>.)</p><p>Also, a subarray may only include each element of the fixed buffer <code>A</code> at most once. (Formally, for a subarray <code>C[i], C[i+1], ..., C[j]</code>, there does not exist <code>i &lt;= k1, k2 &lt;= j</code> with <code>k1 % A.length = k2 % A.length</code>.)</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,-2,3,-2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarray [3] has maximum sum 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [5,-3,5]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: Subarray [5,5] has maximum sum 5 + 5 &#x3D; 10</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,-1,2,-1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 &#x3D; 4</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,-2,2,-3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-2,-3,-1]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: Subarray [-1] has maximum sum -1</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p><code>-30000 &lt;= A[i] &lt;= 30000</code></p></li><li><p><code>1 &lt;= A.length &lt;= 30000</code></p></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://www.cnblogs.com/grandyang/p/11716314.html">[LeetCode] 918. Maximum Sum Circular Subarray 环形子数组的最大和 - 刷尽天下</a></p><p>考虑到环形数组，子数组的和实际上包含两种情况：</p><ul><li><p><strong>一种是正常的，即 <code>A</code> 的某一子数组。</strong></p><p>对于这种情况，可以这样处理：在遍历过程中，**<code>curMx = max(curMx+num, num);</code> 语句表示 <code>curMx</code> 要么延续之前的子数组，要么放弃之前的子数组，<strong>即是否重新组织子数组，然后</strong>使用 <code>mx = max(mx, curMx);</code> 语句寻找子数组和的最大值。**</p></li><li><p><strong>另一种是两段的，即 <code>A</code> 的开头一段和结束一段组合而成的某一子数组。</strong></p><p>对于这种情况，可以这样处理：仿照第一种情况的方法，<strong>寻找子数组和的最小值 <code>mn</code>，使用 <code>A</code> 的总和 <code>sum</code> 减去 <code>mn</code> 就可以得到子数组和的最大值。</strong></p></li></ul><p>最后，上述两种情况取较大值即可。</p><p>另外，如果 <code>sum</code> 与 <code>mn</code> 相等，说明 <code>A</code> 中全为负数，结果应该是 <code>A</code> 中最大的负数，此时直接返回 <code>mx</code> 即可。</p><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, mn = INT_MAX, mx = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> curMn = <span class="number">0</span>, curMx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : A) &#123;</span><br><span class="line">            curMn = <span class="built_in">min</span>(curMn+num, num);</span><br><span class="line">            mn = <span class="built_in">min</span>(mn, curMn);</span><br><span class="line">            curMx = <span class="built_in">max</span>(curMx+num, num);</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, curMx);</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sum == mn) ? mx : <span class="built_in">max</span>(mx, sum-mn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-16th-Odd-Even-Linked-List"><a href="#May-16th-Odd-Even-Linked-List" class="headerlink" title="May 16th: Odd Even Linked List"></a>May 16th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/536/week-3-may-15th-may-21st/3331/">Odd Even Linked List</a></h2><p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p><p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL</span><br><span class="line">Output: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p>The relative order inside both the even and odd groups should remain as it was in the input.</p></li><li><p>The first node is considered odd, the second node even and so on …</p></li></ul><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://www.cnblogs.com/grandyang/p/5138936.html">[LeetCode] Odd Even Linked List 奇偶链表 - 刷尽天下</a></p><p>其实比着代码画个图就能明白了。</p><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *pre = head, *cur = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;next) &#123;</span><br><span class="line">            ListNode *tmp = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            pre-&gt;next-&gt;next = tmp;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-17th-Find-All-Anagrams-in-a-String"><a href="#May-17th-Find-All-Anagrams-in-a-String" class="headerlink" title="May 17th: Find All Anagrams in a String"></a>May 17th: <a href="https://leetcode.com/explore/featured/card/may-leetcoding-challenge/536/week-3-may-15th-may-21st/3332/">Find All Anagrams in a String</a></h2><p>Given a string <strong>s</strong> and a <strong>non-empty</strong> string <strong>p</strong>, find all the start indices of <strong>p</strong>‘s anagrams in <strong>s</strong>.</p><p>Strings consists of lowercase English letters only and the length of both strings <strong>s</strong> and <strong>p</strong> will not be larger than 20,100.</p><p>The order of output does not matter.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index &#x3D; 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.</span><br><span class="line">The substring with start index &#x3D; 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s: &quot;abab&quot; p: &quot;ab&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[0, 1, 2]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index &#x3D; 0 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class="line">The substring with start index &#x3D; 1 is &quot;ba&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class="line">The substring with start index &#x3D; 2 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br></pre></td></tr></table></figure><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p><strong>使用 <code>array&lt;int, 256&gt;</code> 的 <code>arr1</code> 和 <code>arr2</code> 分别记录 <code>s</code> 的滑动窗口中和 <code>p</code> 中字符出现的次数，</strong>通过比较 <code>arr1</code> 和 <code>arr2</code> 是否相等，就可以知道滑动窗口中的字符串是否为 <code>p</code> 的变型。</p><p>P.S. 一开始还使用 <code>multiset&lt;char&gt;</code> 做记录，然后就超时了。</p><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = s.<span class="built_in">size</span>(), n2 = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n1 &lt; n2) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        array&lt;<span class="keyword">int</span>, 256&gt; arr1&#123;&#125;, arr2&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n2; ++i) &#123;</span><br><span class="line">            ++arr1[s[i]];</span><br><span class="line">            ++arr2[p[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr1 == arr2) res.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n2; i &lt; n1; ++i) &#123;</span><br><span class="line">            ++arr1[s[i]];</span><br><span class="line">            --arr1[s[i-n2]];</span><br><span class="line">            <span class="keyword">if</span> (arr1 == arr2) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i-n2+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-18th-Permutation-in-String"><a href="#May-18th-Permutation-in-String" class="headerlink" title="May 18th: Permutation in String"></a>May 18th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/536/week-3-may-15th-may-21st/3333/">Permutation in String</a></h2><p>Given two strings <strong>s1</strong> and <strong>s2</strong>, write a function to return true if <strong>s2</strong> contains the permutation of <strong>s1</strong>. In other words, one of the first string’s permutations is the <strong>substring</strong> of the second string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidbaooo&quot;</span><br><span class="line">Output: True</span><br><span class="line">Explanation: s2 contains one permutation of s1 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1&#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidboaoo&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p>The input strings only contain lower case letters.</p></li><li><p>The length of both given strings is in range [1, 10,000].</p></li></ul><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>梅开二度，这不就是昨天的题嘛，不解释了。</p><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = s1.<span class="built_in">size</span>(), n2 = s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n1 &gt; n2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        array&lt;<span class="keyword">int</span>, 256&gt; arr1&#123;&#125;, arr2&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; ++i) &#123;</span><br><span class="line">            ++arr1[s1[i]];</span><br><span class="line">            ++arr2[s2[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr1 == arr2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n1; i &lt; n2; ++i) &#123;</span><br><span class="line">            ++arr2[s2[i]];</span><br><span class="line">            --arr2[s2[i-n1]];</span><br><span class="line">            <span class="keyword">if</span> (arr1 == arr2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-19th-Online-Stock-Span"><a href="#May-19th-Online-Stock-Span" class="headerlink" title="May 19th: Online Stock Span"></a>May 19th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/536/week-3-may-15th-may-21st/3334/">Online Stock Span</a></h2><p>Write a class <code>StockSpanner</code> which collects daily price quotes for some stock, and returns the <em>span</em> of that stock’s price for the current day.</p><p>The span of the stock’s price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today’s price.</p><p>For example, if the price of a stock over the next 7 days were <code>[100, 80, 60, 70, 60, 75, 85]</code>, then the stock spans would be <code>[1, 1, 1, 2, 1, 4, 6]</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;StockSpanner&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[],[100],[80],[60],[70],[60],[75],[85]]</span><br><span class="line">Output: [null,1,1,1,2,1,4,6]</span><br><span class="line">Explanation:</span><br><span class="line">First, S &#x3D; StockSpanner() is initialized. Then:</span><br><span class="line">S.next(100) is called and returns 1,</span><br><span class="line">S.next(80) is called and returns 1,</span><br><span class="line">S.next(60) is called and returns 1,</span><br><span class="line">S.next(70) is called and returns 2,</span><br><span class="line">S.next(60) is called and returns 1,</span><br><span class="line">S.next(75) is called and returns 4,</span><br><span class="line">S.next(85) is called and returns 6.</span><br><span class="line"></span><br><span class="line">Note that (for example) S.next(75) returned 4, because the last 4 prices</span><br><span class="line">(including today&#39;s price of 75) were less than or equal to today&#39;s price.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p>Calls to <code>StockSpanner.next(int price)</code> will have <code>1 &lt;= price &lt;= 10^5</code>.</p></li><li><p>There will be at most <code>10000</code> calls to <code>StockSpanner.next</code> per test case.</p></li><li><p>There will be at most <code>150000</code> calls to <code>StockSpanner.next</code> across all test cases.</p></li><li><p>The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages.</p></li></ul><h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://www.cnblogs.com/grandyang/p/11029306.html">[LeetCode] 901. Online Stock Span 股票价格跨度 - 刷尽天下</a></p><p>使用 <code>stack&lt;pair&lt;int, int&gt;&gt; st</code> 中的 <code>pair&lt;int, int&gt;</code> 存放当前股价和之前股价不比其高的连续天数。</p><p>每次调用 <code>next</code> 方法，循环遍历堆顶元素，如果其股价不比当前股价 <code>price</code> 高，则累加其连续天数至 <code>cnt</code>，直到其股价比当前股价 <code>price</code> 高。</p><p>结束遍历后，将当前股价 <code>price</code> 和之前股价不比其高的连续天数 <code>cnt</code> 添加至 <code>st</code> 的堆顶，返回 <code>cnt</code> 即可。</p><h4 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StockSpanner</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>().first &lt;= price) &#123;</span><br><span class="line">            cnt += st.<span class="built_in">top</span>().second; st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(&#123;price, cnt&#125;);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StockSpanner* obj = new StockSpanner();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next(price);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="May-20th-Kth-Smallest-Element-in-a-BST"><a href="#May-20th-Kth-Smallest-Element-in-a-BST" class="headerlink" title="May 20th: Kth Smallest Element in a BST"></a>May 20th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/536/week-3-may-15th-may-21st/3335/">Kth Smallest Element in a BST</a></h2><p>Given a binary search tree, write a function <code>kthSmallest</code> to find the <strong>k</strong>th smallest element in it.</p><p><strong>Note:</strong></p><p>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><div class="note info"><p>众所周知，对二叉搜索树 BST 进行<strong>中序遍历</strong>，其结果即为从小到大排序的序列。</p></div><p>对二叉搜索树 BST 进行中序遍历的过程中，累减 <code>k</code> 直至 <code>k</code> 变为 <code>0</code>，返回节点的值即可。</p><h4 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(root, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(TreeNode *node, <span class="keyword">int</span> &amp;k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="built_in">func</span>(node-&gt;left, k);</span><br><span class="line">            <span class="keyword">if</span> (t != INT_MIN) <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="built_in">func</span>(node-&gt;right, k);</span><br><span class="line">            <span class="keyword">if</span> (t != INT_MIN) <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-21st-Count-Square-Submatrices-with-All-Ones"><a href="#May-21st-Count-Square-Submatrices-with-All-Ones" class="headerlink" title="May 21st: Count Square Submatrices with All Ones"></a>May 21st: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/536/week-3-may-15th-may-21st/3336/">Count Square Submatrices with All Ones</a></h2><p>Given a <code>m * n</code> matrix of ones and zeros, return how many <strong>square</strong> submatrices have all ones.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [0,1,1,1],</span><br><span class="line">  [1,1,1,1],</span><br><span class="line">  [0,1,1,1]</span><br><span class="line">]</span><br><span class="line">Output: 15</span><br><span class="line">Explanation:</span><br><span class="line">There are 10 squares of side 1.</span><br><span class="line">There are 4 squares of side 2.</span><br><span class="line">There is  1 square of side 3.</span><br><span class="line">Total number of squares &#x3D; 10 + 4 + 1 &#x3D; 15.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [1,1,0],</span><br><span class="line">  [1,1,0]</span><br><span class="line">]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation:</span><br><span class="line">There are 6 squares of side 1.</span><br><span class="line">There is 1 square of side 2.</span><br><span class="line">Total number of squares &#x3D; 6 + 1 &#x3D; 7.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><p><code>1 &lt;= matrix.length &lt;= 300</code></p></li><li><p><code>1 &lt;= matrix[0].length &lt;= 300</code></p></li><li><p><code>0 &lt;= matrix[i][j] &lt;= 1</code></p></li></ul><h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>P.S. 印象中碰到过这道题，那次没做出来，看了别人的解法之后，这次就记着了。</p><p>使用 <code>vec</code> 记录<strong>以当前位置 <code>[i][j]</code> 为右下角的全 <code>1</code> 矩阵的最大尺寸</strong>，也就是<strong>以当前位置 <code>[i][j]</code> 为右下角的全 <code>1</code> 矩阵的个数</strong>。</p><p>如果当前位置在 <code>matrix</code> 中的值 <code>matrix[i-1][j-1]</code> 为 <code>1</code>，那么可以<strong>通过左上 <code>vec[i-1][j-1]</code>、左侧 <code>vec[i][j-1]</code> 和上方 <code>vec[i-1][j]</code> 中的最小值加 <code>1</code> 得到 <code>vec[i][j]</code>。</strong></p><div class="note info"><p>需要注意的是，为了在动态规划算法中使用统一的递推公式，一般将矩阵扩增一行和一列，所以 <code>vec[i][j]</code> 对应的是 <code>matrix[i-1][j-1]</code>。</p></div><p>最后，在遍历过程中，使用 <code>res</code> 累加 <code>vec[i][j]</code> 即可。</p><h4 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">vec</span>(m+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                    vec[i][j] = <span class="built_in">min</span>(vec[i<span class="number">-1</span>][j<span class="number">-1</span>],</span><br><span class="line">                                    <span class="built_in">min</span>(vec[i][j<span class="number">-1</span>], vec[i<span class="number">-1</span>][j])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res += vec[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 五月挑战专题每日随缘更新，点击类别 &lt;a href=&quot;/categories/2020-May-LeetCoding-Challenge/&quot;&gt;2020 May LeetCoding Challenge&lt;/a&gt; 查看更多。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="2020 LeetCoding Challenge" scheme="https://progcz.com/categories/A03-LeetCode/2020-LeetCoding-Challenge/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Data Structure and Algorithm" scheme="https://progcz.com/tags/Data-Structure-and-Algorithm/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Challenge" scheme="https://progcz.com/tags/Challenge/"/>
    
  </entry>
  
  <entry>
    <title>记录一次「卖」微信公众号的经历</title>
    <link href="https://progcz.com/posts/record-for-sell-wechat-official-account/"/>
    <id>https://progcz.com/posts/record-for-sell-wechat-official-account/</id>
    <published>2020-05-14T08:44:03.000Z</published>
    <updated>2021-04-29T15:10:53.048Z</updated>
    
    <content type="html"><![CDATA[<p><strong>因为腾讯在两年前关闭了新注册微信公众号的「留言」功能，所以新注册微信公众号必须通过一些特殊方法才能拥有「留言」功能，「账号迁移」便是其中之一。</strong></p><p>刚好，我有一个闲置已久的微信公众号，于是联系到经办人将自己的微信公众号「卖」了出去。<strong>两个工作日</strong>的时间就把整个流程走完了，大部分手续都是经办人的事情，需要我来配合的地方并不多。</p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/03.png" style="zoom:100%"/><span id="more"></span><h2 id="0-事情起因"><a href="#0-事情起因" class="headerlink" title="0 事情起因"></a>0 事情起因</h2><p>几天前，在逛 V2EX 的时候，看到一个<a href="https://www.v2ex.com/t/668420">帖子</a>，里面讲到：</p><blockquote><p>做公众号，特别是近期注册的都想要留言功能。但是 2018 年 3 月 12 日之后注册的微信公众号默认没有留言功能。</p><p>新号想要留言功能，基本上就一条路花几千找人做迁移有留言功能的老号才行。</p></blockquote><p>巧合的是，在此之前的几天，我想起自己有个闲置已久的微信公众号，当时觉得没什么用了，于是申请了账号注销，七天后再次确认即可彻底注销。看到这个帖子之后，我立马终止了注销流程，开始琢磨怎么把它卖掉。</p><h2 id="1-迁移过程"><a href="#1-迁移过程" class="headerlink" title="1 迁移过程"></a>1 迁移过程</h2><p>简单搜索之后，我了解到腾讯关闭了新注册微信公众号的「留言」功能，想要开通的话需要一些特殊方法，具体可以参考<a href="https://zhuanlan.zhihu.com/p/63996356">微信公众号留言开通最全攻略</a>。</p><p>同时，我联系到一个专业的经办人，可以帮忙「卖」掉带有「留言」功能的微信公众号。</p><div class="note info"><p>接下来，从我的角度来描述一下大概的流程：</p><ol><li><p>第一天，经办人登录我的微信公众号，确认微信公众号的基本信息及违规记录。</p></li><li><p>随后，经办人要求我提供身份证正反面的照片，照片需要带有「公众号迁移」字样的水印。<strong>提供照片之后，经办人付给了我一半的费用。</strong></p></li><li><p>三个小时后，经办人要求我进行电子公证，此处需要进行人脸识别。</p></li><li><p>第二天，经办人再次登录我的微信公众号。</p></li><li><p>随后，经办人要求我扫码对「账号迁移」进行确认，此时微信需要对迁移申请进行审核。</p></li><li><p>四个小时后，微信对迁移申请的审核通过，经办人要求再次对「账号迁移」进行确认。<strong>最终确认之后，经办人付给了我另外一半的费用。</strong></p></li></ol></div><p>以上就是我需要做的事情，总体来说不算麻烦，何乐而不为。</p><h2 id="2-推广"><a href="#2-推广" class="headerlink" title="2 推广"></a>2 推广</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/04.png" style="zoom:100%"/><p><strong>如果你也有一个在 2018 年 03 月 12 日之前注册而又闲置的微信公众号，可以通过「下方的评论区」或「<a href="/about/">关于</a>页面的其他联系方式」联系到我，</strong>我可以把这个比较靠谱的经办人推荐给你。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;因为腾讯在两年前关闭了新注册微信公众号的「留言」功能，所以新注册微信公众号必须通过一些特殊方法才能拥有「留言」功能，「账号迁移」便是其中之一。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;刚好，我有一个闲置已久的微信公众号，于是联系到经办人将自己的微信公众号「卖」了出去。&lt;strong&gt;两个工作日&lt;/strong&gt;的时间就把整个流程走完了，大部分手续都是经办人的事情，需要我来配合的地方并不多。&lt;/p&gt;
&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/03.png&quot; style=&quot;zoom:100%&quot;/&gt;</summary>
    
    
    
    <category term="A01 - 生活随笔" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="经历" scheme="https://progcz.com/categories/A01-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="WeChat" scheme="https://progcz.com/tags/WeChat/"/>
    
    <category term="Life" scheme="https://progcz.com/tags/Life/"/>
    
    <category term="Promotion" scheme="https://progcz.com/tags/Promotion/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Weekly Contest 188 (1441 - 1444)</title>
    <link href="https://progcz.com/posts/leetcode-weekly-contest-188-1441-1444/"/>
    <id>https://progcz.com/posts/leetcode-weekly-contest-188-1441-1444/</id>
    <published>2020-05-10T07:14:53.000Z</published>
    <updated>2021-04-29T15:10:53.048Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 周赛专题每周随缘更新，点击类别 <a href="/categories/LeetCode-Weekly-Contest/">LeetCode Weekly Contest</a> 查看更多。</p><p>本次比赛通过 <code>3</code> 题，时间为 <code>1:14:56</code>，排名为 <code>2375/12715</code>。</p><span id="more"></span><h2 id="1441-Build-an-Array-With-Stack-Operations-Easy"><a href="#1441-Build-an-Array-With-Stack-Operations-Easy" class="headerlink" title="1441. Build an Array With Stack Operations #Easy"></a><a href="https://leetcode.com/contest/weekly-contest-188/problems/build-an-array-with-stack-operations/">1441. Build an Array With Stack Operations</a> #Easy</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，遍历 <code>target</code>，在 <code>res</code> 中添加 <code>&quot;Push&quot;</code>。</p><p>其次，累加 <code>num</code>，如果遍历到的数字与 <code>num</code> 不同，那么在 <code>res</code> 中添加 <code>&quot;Pop&quot;</code>，同时将遍历下标 <code>i</code> 停在当前位置。</p><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">buildArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="string">&quot;Push&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (num != target[i]) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&quot;Pop&quot;</span>);</span><br><span class="line">                --i;</span><br><span class="line">            &#125;</span><br><span class="line">            ++num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR-Medium"><a href="#1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR-Medium" class="headerlink" title="1442. Count Triplets That Can Form Two Arrays of Equal XOR #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-188/problems/count-triplets-that-can-form-two-arrays-of-equal-xor">1442. Count Triplets That Can Form Two Arrays of Equal XOR</a> #Medium</h2><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><div class="note info"><p>需要明白的是，异或运算具备一个重要性质：如果　<code>a ^ b ^ c ^ d = e</code>，那么　<code>c ^ d = e ^ (a ^ b)</code>。</p></div><p>首先，使用 <code>vec</code> 存放每个数字与之前所有数字异或运算的结果。</p><p>其次，根据异或运算的性质，计算 <code>[i, j-1]</code> 之间数字异或运算的结果，只需计算 <code>vec[j-1] ^ vec[i-1]</code>。</p><p>同理，计算 <code>[j, k]</code> 之间数字异或运算的结果，只需计算 <code>vec[k] ^ vec[j-1]</code>。</p><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(vec.<span class="built_in">back</span>() ^ arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; vec.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; vec.<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((vec[j<span class="number">-1</span>] ^ vec[i<span class="number">-1</span>]) == (vec[k] ^ vec[j<span class="number">-1</span>])) &#123;</span><br><span class="line">                        ++res;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree-Medium"><a href="#1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree-Medium" class="headerlink" title="1443. Minimum Time to Collect All Apples in a Tree #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-188/problems/minimum-time-to-collect-all-apples-in-a-tree/">1443. Minimum Time to Collect All Apples in a Tree</a> #Medium</h2><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，使用 <code>map&lt;int, vector&lt;int&gt;&gt; m</code> 记录每个节点的所有子节点。</p><p>其次，使用深度优先搜索算法遍历所有的节点，返回到达某个节点及其之后节点所需要的时间步。其边界条件是遍历到叶子节点，如果叶子节点包含苹果，因为往返这个节点需要 <code>2</code> 个时间步，所以返回 <code>2</code>，否则返回 <code>0</code>。</p><p>然后，对于遍历到的节点，需要遍历其所有子节点，同时使用 <code>sum</code> 累加子节点返回的值，如果该节点不为根节点，而且其子节点之和不为 <code>0</code>（表明其子树包含苹果）或者节点本身包含苹果，那么必然需要往返该节点，<code>sum</code> 累加 <code>2</code>。</p><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTime</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="keyword">bool</span>&gt;&amp; hasApple)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> vi : edges) m[vi[<span class="number">0</span>]].<span class="built_in">push_back</span>(vi[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(<span class="number">0</span>, m, hasApple);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> idx, map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;m, vector&lt;<span class="keyword">bool</span>&gt; &amp;hasApple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m.<span class="built_in">count</span>(idx)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasApple[idx]) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : m[idx]) sum += <span class="built_in">func</span>(i, m, hasApple);</span><br><span class="line">        <span class="keyword">if</span> (idx != <span class="number">0</span> &amp;&amp; (sum != <span class="number">0</span> || hasApple[idx])) sum += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1444-Number-of-Ways-of-Cutting-a-Pizza-Hard"><a href="#1444-Number-of-Ways-of-Cutting-a-Pizza-Hard" class="headerlink" title="1444. Number of Ways of Cutting a Pizza #Hard"></a><a href="https://leetcode.com/contest/weekly-contest-188/problems/number-of-ways-of-cutting-a-pizza/">1444. Number of Ways of Cutting a Pizza</a> #Hard</h2><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza/discuss/623732/JavaC%2B%2B-DP-%2B-PrefixSum-in-Matrix-Clean-code">[Java/C++] DP + PrefixSum in Matrix - Clean code</a></p><p>放弃治疗系列，直接看大佬的解法吧。</p><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ways</span><span class="params">(vector&lt;string&gt;&amp; pizza, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = pizza.<span class="built_in">size</span>(), n = pizza[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(k, <span class="built_in">vector</span>(m, <span class="built_in">vector</span>(n, <span class="number">-1</span>)));</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">preSum</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = m - <span class="number">1</span>; r &gt;= <span class="number">0</span>; --r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = n - <span class="number">1</span>; c &gt;= <span class="number">0</span>; --c) &#123;</span><br><span class="line">                preSum[r][c] = preSum[r][c+<span class="number">1</span>] + preSum[r+<span class="number">1</span>][c] - preSum[r+<span class="number">1</span>][c+<span class="number">1</span>];</span><br><span class="line">                preSum[r][c] += (pizza[r][c] == <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(m, n, k<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, dp, preSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> r, <span class="keyword">int</span> c,</span></span></span><br><span class="line"><span class="function"><span class="params">            vector&lt;vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt; &amp;dp, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;preSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preSum[r][c] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp[k][r][c] != <span class="number">-1</span>) <span class="keyword">return</span> dp[k][r][c];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nr = r + <span class="number">1</span>; nr &lt; m; ++nr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (preSum[r][c] - preSum[nr][c] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans = (ans + <span class="built_in">dfs</span>(m, n, k<span class="number">-1</span>, nr, c, dp, preSum)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nc = c + <span class="number">1</span>; nc &lt; n; ++nc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (preSum[r][c] - preSum[r][nc] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans = (ans + <span class="built_in">dfs</span>(m, n, k<span class="number">-1</span>, r, nc, dp, preSum)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][r][c] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 周赛专题每周随缘更新，点击类别 &lt;a href=&quot;/categories/LeetCode-Weekly-Contest/&quot;&gt;LeetCode Weekly Contest&lt;/a&gt; 查看更多。&lt;/p&gt;
&lt;p&gt;本次比赛通过 &lt;code&gt;3&lt;/code&gt; 题，时间为 &lt;code&gt;1:14:56&lt;/code&gt;，排名为 &lt;code&gt;2375/12715&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="LeetCode Weekly Contest" scheme="https://progcz.com/categories/A03-LeetCode/LeetCode-Weekly-Contest/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Data Structure and Algorithm" scheme="https://progcz.com/tags/Data-Structure-and-Algorithm/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 May LeetCoding Challenge - Week 2</title>
    <link href="https://progcz.com/posts/2020-may-leetcoding-challenge-week-2/"/>
    <id>https://progcz.com/posts/2020-may-leetcoding-challenge-week-2/</id>
    <published>2020-05-08T08:07:28.000Z</published>
    <updated>2020-05-14T09:26:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 五月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-May-LeetCoding-Challenge/">2020 May LeetCoding Challenge</a> 查看更多。</p><span id="more"></span><h2 id="May-8th-Check-If-It-Is-a-Straight-Line"><a href="#May-8th-Check-If-It-Is-a-Straight-Line" class="headerlink" title="May 8th: Check If It Is a Straight Line"></a>May 8th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/535/week-2-may-8th-may-14th/3323/">Check If It Is a Straight Line</a></h2><p>You are given an array <code>coordinates</code>, <code>coordinates[i] = [x, y]</code>, where <code>[x, y]</code> represents the coordinate of a point. Check if these points make a straight line in the XY plane.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: coordinates &#x3D; [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: coordinates &#x3D; [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><p><code>2 &lt;= coordinates.length &lt;= 1000</code></p></li><li><p><code>coordinates[i].length == 2</code></p></li><li><p><code>-10^4 &lt;= coordinates[i][0], coordinates[i][1] &lt;= 10^4</code></p></li><li><p><code>coordinates</code> contains no duplicate point.</p></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>遍历所有点，每两点 <code>[x1, y1]</code> 和 <code>[x2, y2]</code> 之间计算斜率 <code>k</code>，判断其是否在遍历过程中保持不变。</p><p>实际上就是首先计算开头两点的斜率，然后判断后面的斜率是否与其相等。</p><div class="note warning"><p>需要注意的是，如果 <code>x1</code> 和 <code>x2</code> 相等，则无法通过除法计算斜率 <code>k</code>，此时将 <code>k</code> 赋值为 <code>DBL_MAX</code>，用来表示无穷大的斜率。</p></div><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkStraightLine</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = coordinates.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">double</span> k = DBL_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">double</span> x1 = coordinates[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">double</span> y1 = coordinates[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">double</span> x2 = coordinates[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">double</span> y2 = coordinates[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (k == DBL_MIN) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x1 == x2) k = DBL_MAX;</span><br><span class="line">                <span class="keyword">else</span> k = (y2 - y1) / (x2 - x1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((x1 == x2 &amp;&amp; k != DBL_MAX) ||</span><br><span class="line">                (x1 != x2 &amp;&amp; (y2 - y1) / (x2 - x1) != k)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-9th-Valid-Perfect-Square"><a href="#May-9th-Valid-Perfect-Square" class="headerlink" title="May 9th: Valid Perfect Square"></a>May 9th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/535/week-2-may-8th-may-14th/3324/">Valid Perfect Square</a></h2><p>Given a positive integer <code>num</code>, write a function which returns True if <code>num</code> is a perfect square else False.</p><p><strong>Note:</strong> Do not use any built-in library function such as <code>sqrt</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 16</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 14</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>侮辱智商，不解释了。</p><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (t * t &lt; num) ++t;</span><br><span class="line">        <span class="keyword">return</span> t * t == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-10th-Find-the-Town-Judge"><a href="#May-10th-Find-the-Town-Judge" class="headerlink" title="May 10th: Find the Town Judge"></a>May 10th: <a href="https://leetcode.com/explore/featured/card/may-leetcoding-challenge/535/week-2-may-8th-may-14th/3325/">Find the Town Judge</a></h2><p>In a town, there are <code>N</code> people labelled from <code>1</code> to <code>N</code>. There is a rumor that one of these people is secretly the town judge.</p><p>If the town judge exists, then:</p><ol><li><p>The town judge trusts nobody.</p></li><li><p>Everybody (except for the town judge) trusts the town judge.</p></li><li><p>There is exactly one person that satisfies properties 1 and 2.</p></li></ol><p>You are given <code>trust</code>, an array of pairs <code>trust[i] = [a, b]</code> representing that the person labelled <code>a</code> trusts the person labelled <code>b</code>.</p><p>If the town judge exists and can be identified, return the label of the town judge. Otherwise, return <code>-1</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 2, trust &#x3D; [[1,2]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 3, trust &#x3D; [[1,3],[2,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 3, trust &#x3D; [[1,3],[2,3],[3,1]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 3, trust &#x3D; [[1,2],[2,3]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 4, trust &#x3D; [[1,3],[1,4],[2,3],[2,4],[4,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p><code>1 &lt;= N &lt;= 1000</code></p></li><li><p><code>trust.length &lt;= 10000</code></p></li><li><p><code>trust[i]</code> are all different</p></li><li><p><code>trust[i][0] != trust[i][1]</code></p></li><li><p><code>1 &lt;= trust[i][0], trust[i][1] &lt;= N</code></p></li></ul><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，使用 <code>map&lt;int, set&lt;int&gt;&gt; m</code> 存放某个人的受信任列表，即信任某个人的所有人。</p><p>其次，遍历 <code>m</code>，<strong>如果信任这个人 <code>p.first</code> 的所有人 <code>p.second</code> 共有 <code>N-1</code> 个，那么说明 <code>p.first</code> 受其他所有人的信任。</strong></p><p>然后，对于这个人 <code>p.first</code>，遍历其他人 <code>p.second</code>，<strong>如果 <code>p.first</code> 不存在于任何人的受信任列表 <code>m[t]</code> 中，那么说明 <code>p.first</code> 不信任其他所有人。</strong></p><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findJudge</span><span class="params">(<span class="keyword">int</span> N, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; trust)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, set&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> vi : trust) m[vi[<span class="number">1</span>]].<span class="built_in">insert</span>(vi[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second.<span class="built_in">size</span>() == N<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">bool</span> b = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> t : p.second) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (m[t].<span class="built_in">count</span>(p.first)) &#123;</span><br><span class="line">                        b = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (b) <span class="keyword">return</span> p.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-11th-Flood-Fill"><a href="#May-11th-Flood-Fill" class="headerlink" title="May 11th: Flood Fill"></a>May 11th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/535/week-2-may-8th-may-14th/3326/">Flood Fill</a></h2><p>An <code>image</code> is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).</p><p>Given a coordinate <code>(sr, sc)</code> representing the starting pixel (row and column) of the flood fill, and a pixel value <code>newColor</code>, “flood fill” the image.</p><p>To perform a “flood fill”, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.</p><p>At the end, return the modified image.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">image &#x3D; [[1,1,1],[1,1,0],[1,0,1]]</span><br><span class="line">sr &#x3D; 1, sc &#x3D; 1, newColor &#x3D; 2</span><br><span class="line">Output: [[2,2,2],[2,2,0],[2,0,1]]</span><br><span class="line">Explanation: </span><br><span class="line">From the center of the image (with position (sr, sc) &#x3D; (1, 1)), all pixels connected</span><br><span class="line">by a path of the same color as the starting pixel are colored with the new color.</span><br><span class="line">Note the bottom corner is not colored 2, because it is not 4-directionally connected</span><br><span class="line">to the starting pixel.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p>The length of <code>image</code> and <code>image[0]</code> will be in the range <code>[1, 50]</code>.</p></li><li><p>The given starting pixel will satisfy <code>0 &lt;= sr &lt; image.length</code> and <code>0 &lt;= sc &lt; image[0].length</code>.</p></li><li><p>The value of each color in <code>image[i][j]</code> and <code>newColor</code> will be an integer in <code>[0, 65535]</code>.</p></li></ul><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>典型的深度优先搜索算法就可以解决。</p><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">floodFill</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = image.<span class="built_in">size</span>(), n = image[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">func</span>(image, visited, sr, sc, image[sr][sc], newColor);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;image, vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; &amp;visited,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> startColor, <span class="keyword">int</span> newColor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = image.<span class="built_in">size</span>(), n = image[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n ||</span><br><span class="line">            visited[x][y] || image[x][y] != startColor) <span class="keyword">return</span>;</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        image[x][y] = newColor;</span><br><span class="line">        <span class="built_in">func</span>(image, visited, x<span class="number">-1</span>, y, startColor, newColor);</span><br><span class="line">        <span class="built_in">func</span>(image, visited, x+<span class="number">1</span>, y, startColor, newColor);</span><br><span class="line">        <span class="built_in">func</span>(image, visited, x, y<span class="number">-1</span>, startColor, newColor);</span><br><span class="line">        <span class="built_in">func</span>(image, visited, x, y+<span class="number">1</span>, startColor, newColor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-12th-Single-Element-in-a-Sorted-Array"><a href="#May-12th-Single-Element-in-a-Sorted-Array" class="headerlink" title="May 12th: Single Element in a Sorted Array"></a>May 12th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/535/week-2-may-8th-may-14th/3327/">Single Element in a Sorted Array</a></h2><p>You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Find this single element that appears only once.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,1,2,3,3,4,4,8,8]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,3,7,7,10,11,11]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> Your solution should run in O(log n) time and O(1) space.</p><h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><div class="note info"><p>需要明白的是，异或运算具备两个重要性质：</p><ul><li><p>对于数字 <code>num</code> 来说，<code>num ^ num == 0</code>。</p></li><li><p>对于数字 <code>num</code> 来说，<code>num ^ 0 == num</code>。</p></li></ul></div><p>对于出现两次的数字来说，遍历过程中的异或运算必然使其自身抵消，最终剩下出现一次的数字作为计算结果。</p><h4 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) res ^= num;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-13th-Remove-K-Digits"><a href="#May-13th-Remove-K-Digits" class="headerlink" title="May 13th: Remove K Digits"></a>May 13th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/535/week-2-may-8th-may-14th/3328/">Remove K Digits</a></h2><p>Given a non-negative integer <code>num</code> represented as a string, remove <code>k</code> digits from the number so that the new number is the smallest possible.</p><p><strong>Note:</strong></p><ul><li><p>The length of <code>num</code> is less than 10002 and will be ≥ <code>k</code>.</p></li><li><p>The given <code>num</code> does not contain any leading zero.</p></li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num &#x3D; &quot;1432219&quot;, k &#x3D; 3</span><br><span class="line">Output: &quot;1219&quot;</span><br><span class="line">Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num &#x3D; &quot;10200&quot;, k &#x3D; 1</span><br><span class="line">Output: &quot;200&quot;</span><br><span class="line">Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num &#x3D; &quot;10&quot;, k &#x3D; 2</span><br><span class="line">Output: &quot;0&quot;</span><br><span class="line">Explanation: Remove all the digits from the number and it is left with nothing which is 0.</span><br></pre></td></tr></table></figure><h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://www.cnblogs.com/grandyang/p/5883736.html">[LeetCode] 402. Remove K Digits 去掉 K 位数字 - 刷尽天下</a></p><p>将 <code>num</code> 中的字符逐个添加到 <code>res</code> 中，为了保证高位上的数字尽可能地小，在添加过程中需要去除 <code>res</code> 中比当前字符大的字符，从而保证 <code>res</code> 是非递减的。</p><h4 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeKdigits</span><span class="params">(string num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> n = num.<span class="built_in">size</span>(), keep = n - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : num) &#123;</span><br><span class="line">            <span class="keyword">while</span> (k &amp;&amp; res.<span class="built_in">size</span>() &amp;&amp; res.<span class="built_in">back</span>() &gt; c) &#123;</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">resize</span>(keep);</span><br><span class="line">        <span class="keyword">while</span> (!res.<span class="built_in">empty</span>() &amp;&amp; res[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            res.<span class="built_in">erase</span>(res.<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">empty</span>() ? <span class="string">&quot;0&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-14th-Implement-Trie-Prefix-Tree"><a href="#May-14th-Implement-Trie-Prefix-Tree" class="headerlink" title="May 14th: Implement Trie (Prefix Tree)"></a>May 14th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/535/week-2-may-8th-may-14th/3329/">Implement Trie (Prefix Tree)</a></h2><p>Implement a trie with <code>insert</code>, <code>search</code>, and <code>startsWith</code> methods.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; returns true</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; returns false</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; returns true</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; returns true</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p>You may assume that all inputs are consist of lowercase letters <code>a-z</code>.</p></li><li><p>All inputs are guaranteed to be non-empty strings.</p></li></ul><h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>对于 <code>insert</code> 和 <code>search</code> 方法，可以使用 <code>set&lt;string&gt; s</code> 的 <code>insert</code> 和 <code>count</code> 方法实现。</p><p>对于 <code>startsWith</code> 方法，因为 <code>set</code> 自动对元素（此处为字符串）进行排序，所以可以遍历找到<strong>第一个大于等于 <code>prefix</code> 的字符串</strong>，如果该字符串是以 <code>prefix</code> 开头的，那么返回 <code>true</code>，否则返回 <code>false</code>。</p><h4 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    set&lt;string&gt; s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">Trie</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        s.<span class="built_in">insert</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">count</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = s.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (iter != s.<span class="built_in">end</span>() &amp;&amp; *iter &lt; prefix) ++iter;</span><br><span class="line">        <span class="keyword">return</span> iter != s.<span class="built_in">end</span>() &amp;&amp; prefix == iter-&gt;<span class="built_in">substr</span>(<span class="number">0</span>, prefix.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 五月挑战专题每日随缘更新，点击类别 &lt;a href=&quot;/categories/2020-May-LeetCoding-Challenge/&quot;&gt;2020 May LeetCoding Challenge&lt;/a&gt; 查看更多。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="2020 LeetCoding Challenge" scheme="https://progcz.com/categories/A03-LeetCode/2020-LeetCoding-Challenge/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Data Structure and Algorithm" scheme="https://progcz.com/tags/Data-Structure-and-Algorithm/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Challenge" scheme="https://progcz.com/tags/Challenge/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Biweekly Contest 25 (1431 - 1434)</title>
    <link href="https://progcz.com/posts/leetcode-biweekly-contest-25-1431-1434/"/>
    <id>https://progcz.com/posts/leetcode-biweekly-contest-25-1431-1434/</id>
    <published>2020-05-08T03:34:43.000Z</published>
    <updated>2021-04-29T15:10:53.048Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 双周赛专题每双周随缘更新，点击类别 <a href="/categories/LeetCode-Biweekly-Contest/">LeetCode Biweekly Contest</a> 查看更多。</p><span id="more"></span><h2 id="1431-Kids-With-the-Greatest-Number-of-Candies-Easy"><a href="#1431-Kids-With-the-Greatest-Number-of-Candies-Easy" class="headerlink" title="1431. Kids With the Greatest Number of Candies #Easy"></a><a href="https://leetcode.com/contest/biweekly-contest-25/problems/kids-with-the-greatest-number-of-candies/">1431. Kids With the Greatest Number of Candies</a> #Easy</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>侮辱智商，不解释了。</p><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">kidsWithCandies</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_num = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> candy : candies) &#123;</span><br><span class="line">            max_num = <span class="built_in">max</span>(max_num, candy);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">bool</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> candy : candies) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(candy + extraCandies &gt;= max_num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1432-Max-Difference-You-Can-Get-From-Changing-an-Integer-Medium"><a href="#1432-Max-Difference-You-Can-Get-From-Changing-an-Integer-Medium" class="headerlink" title="1432. Max Difference You Can Get From Changing an Integer #Medium"></a><a href="https://leetcode.com/contest/biweekly-contest-25/problems/max-difference-you-can-get-from-changing-an-integer/">1432. Max Difference You Can Get From Changing an Integer</a> #Medium</h2><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，对于 <code>a</code> 来说，从高位开始遍历，如果发现某位数字不为 <code>9</code>，那么将 <code>a</code> 中的所有该位数字替换为 <code>9</code>。</p><p>其次，对于 <code>b</code> 来说，如果发现第一位数字不为 <code>1</code>，那么将 <code>b</code> 中的所有该位数字替换为 <code>1</code>，否则从高位开始遍历，如果发现某位数字不为 <code>1</code> 且不为 <code>0</code>，那么将 <code>b</code> 中的所有该位数字替换为 <code>0</code>。</p><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDiff</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = num, b = num, div = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (num /= <span class="number">10</span>) div *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> rep = <span class="number">-1</span>, tdiv = div;</span><br><span class="line">        <span class="keyword">while</span> (tdiv) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rep == <span class="number">-1</span> &amp;&amp; a / tdiv % <span class="number">10</span> != <span class="number">9</span>) &#123;</span><br><span class="line">                rep = a / tdiv % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a / tdiv % <span class="number">10</span> == rep) &#123;</span><br><span class="line">                a = a + (<span class="number">9</span> - rep) * tdiv;</span><br><span class="line">            &#125;</span><br><span class="line">            tdiv /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rep = <span class="number">-1</span>, tdiv = div;</span><br><span class="line">        <span class="keyword">bool</span> f = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (b / div % <span class="number">10</span> != <span class="number">1</span>) &#123;</span><br><span class="line">            rep = b / div % <span class="number">10</span>;</span><br><span class="line">            f = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (tdiv) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rep == <span class="number">-1</span> &amp;&amp; b / tdiv % <span class="number">10</span> != <span class="number">1</span> &amp;&amp; b / tdiv % <span class="number">10</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                rep = b / tdiv % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b / tdiv % <span class="number">10</span> == rep) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f) b = b + (<span class="number">1</span> - rep) * tdiv;</span><br><span class="line">                <span class="keyword">else</span> b = b + (<span class="number">0</span> - rep) * tdiv;</span><br><span class="line">            &#125;</span><br><span class="line">            tdiv /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1433-Check-If-a-String-Can-Break-Another-String-Medium"><a href="#1433-Check-If-a-String-Can-Break-Another-String-Medium" class="headerlink" title="1433. Check If a String Can Break Another String #Medium"></a><a href="https://leetcode.com/contest/biweekly-contest-25/problems/check-if-a-string-can-break-another-string/">1433. Check If a String Can Break Another String</a> #Medium</h2><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>再次侮辱智商，不解释了。</p><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkIfCanBreak</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">const</span> string &amp;s3 = <span class="built_in">min</span>(s1, s2);</span><br><span class="line">        <span class="keyword">const</span> string &amp;s4 = <span class="built_in">max</span>(s1, s2);</span><br><span class="line">        <span class="keyword">int</span> n = s3.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s3[i] &gt; s4[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1434-Number-of-Ways-to-Wear-Different-Hats-to-Each-Other-Hard"><a href="#1434-Number-of-Ways-to-Wear-Different-Hats-to-Each-Other-Hard" class="headerlink" title="1434. Number of Ways to Wear Different Hats to Each Other #Hard"></a><a href="https://leetcode.com/contest/biweekly-contest-25/problems/number-of-ways-to-wear-different-hats-to-each-other/">1434. Number of Ways to Wear Different Hats to Each Other</a> #Hard</h2><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://leetcode.com/problems/number-of-ways-to-wear-different-hats-to-each-other/discuss/608686/C%2B%2B-Bit-masks-and-Bottom-Up-DP">[C++] Bit-masks and Bottom-Up DP</a></p><p>这种题目我已经放弃治疗了，直接看大佬的解法吧。</p><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberWays</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; hats)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">persons</span>(<span class="number">40</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = hats.<span class="built_in">size</span>(), mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">masks</span><span class="params">(<span class="number">1</span> &lt;&lt; n)</span></span>;</span><br><span class="line">        masks[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;h: hats[i]) &#123;</span><br><span class="line">                persons[h - <span class="number">1</span>].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;p: persons[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((j &amp; (<span class="number">1</span> &lt;&lt; p)) == <span class="number">0</span>) &#123;</span><br><span class="line">                        masks[j | (<span class="number">1</span> &lt;&lt; p)] += masks[j];</span><br><span class="line">                        masks[j | (<span class="number">1</span> &lt;&lt; p)] %= mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> masks[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 双周赛专题每双周随缘更新，点击类别 &lt;a href=&quot;/categories/LeetCode-Biweekly-Contest/&quot;&gt;LeetCode Biweekly Contest&lt;/a&gt; 查看更多。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="LeetCode Biweekly Contest" scheme="https://progcz.com/categories/A03-LeetCode/LeetCode-Biweekly-Contest/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Data Structure and Algorithm" scheme="https://progcz.com/tags/Data-Structure-and-Algorithm/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Weekly Contest 187 (1436 - 1439)</title>
    <link href="https://progcz.com/posts/leetcode-weekly-contest-187-1436-1439/"/>
    <id>https://progcz.com/posts/leetcode-weekly-contest-187-1436-1439/</id>
    <published>2020-05-03T07:23:13.000Z</published>
    <updated>2021-04-29T15:10:53.048Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 周赛专题每周随缘更新，点击类别 <a href="/categories/LeetCode-Weekly-Contest/">LeetCode Weekly Contest</a> 查看更多。</p><p>本次比赛通过 <code>3</code> 题，时间为 <code>1:01:42</code>，排名为 <code>2281/12350</code>。</p><span id="more"></span><h2 id="1436-Destination-City-Easy"><a href="#1436-Destination-City-Easy" class="headerlink" title="1436. Destination City #Easy"></a><a href="https://leetcode.com/contest/weekly-contest-187/problems/destination-city/">1436. Destination City</a> #Easy</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><div class="note info"><p>问题转化：**在所有成对城市 <code>[cityA_i, cityB_i]</code> 中寻找只出现了一次的目的城市 <code>cityB_i</code>**。</p></div><p>使用 <code>map&lt;string, int&gt; m</code> 对城市进行标记，遍历所有的成对城市 <code>[cityA_i, cityB_i]</code>，出发城市 <code>cityA_i</code> 的标记值累加 <code>1</code>，目的城市 <code>cityB_i</code> 的标记值累加 <code>2</code>，那么在遍历结束之后，<strong>标记值为 <code>1</code> 的为最初的城市，标记值为 <code>3</code> 的为路过的城市，标记值为 <code>2</code> 的为最后的城市。</strong></p><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">destCity</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        map&lt;string, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> vs : paths) &#123;</span><br><span class="line">            m[vs[<span class="number">0</span>]] += <span class="number">1</span>;</span><br><span class="line">            m[vs[<span class="number">1</span>]] += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second == <span class="number">2</span>) <span class="keyword">return</span> p.first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1437-Check-If-All-1’s-Are-at-Least-Length-K-Places-Away-Medium"><a href="#1437-Check-If-All-1’s-Are-at-Least-Length-K-Places-Away-Medium" class="headerlink" title="1437. Check If All 1’s Are at Least Length K Places Away #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-187/problems/check-if-all-1s-are-at-least-length-k-places-away/">1437. Check If All 1’s Are at Least Length K Places Away</a> #Medium</h2><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>实际上就是对 <code>1</code> 之间的 <code>0</code> 进行计数。</p><div class="note warning"><p>需要注意的是，开头和结尾出现的 <code>0</code> 没有夹在 <code>1</code> 之间，应该避开这些情况。</p></div><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">kLengthApart</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (idx &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[idx] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (++idx &lt; n &amp;&amp; nums[idx] == <span class="number">0</span>) ++cnt;</span><br><span class="line">                <span class="keyword">if</span> (idx &lt; n &amp;&amp; nums[idx] == <span class="number">1</span> &amp;&amp; cnt &lt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit-Medium"><a href="#1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit-Medium" class="headerlink" title="1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-187/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit">1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</a> #Medium</h2><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>滑动窗口算法就可以解决。</p><p>使用 <code>map&lt;int, int&gt; m</code> 记录滑动窗口内出现的数字，<strong>因为 <code>map</code> 是自动从小到大排序的，所以 <code>m.begin()</code> 指向的数字最小，<code>m.rbegin()</code> 指向的数字最大，</strong>可以用函数 <code>bool func(int limit)</code> 检查滑动窗口内的数字是否满足题目要求，寻找滑动窗口的最大长度即可。</p><div class="note info"><p>滑动窗口算法可以参考这篇文章：<a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/hua-dong-chuang-kou-ji-qiao">滑动窗口技巧</a>。</p></div><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, beg = <span class="number">0</span>, end = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (beg &lt;= end &amp;&amp; end &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; <span class="built_in">func</span>(limit)) &#123;</span><br><span class="line">                ++m[nums[end]];</span><br><span class="line">                ++end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (end == n &amp;&amp; <span class="built_in">func</span>(limit)) res = <span class="built_in">max</span>(res, end-beg);</span><br><span class="line">            <span class="keyword">else</span> res = <span class="built_in">max</span>(res, end-beg<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">while</span> (beg &lt;= end &amp;&amp; !<span class="built_in">func</span>(limit)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--m[nums[beg]] == <span class="number">0</span>) m.<span class="built_in">erase</span>(nums[beg]);</span><br><span class="line">                ++beg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> m.<span class="built_in">rbegin</span>()-&gt;first - m.<span class="built_in">begin</span>()-&gt;first &lt;= limit;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1439-Find-the-Kth-Smallest-Sum-of-a-Matrix-With-Sorted-Rows-Hard"><a href="#1439-Find-the-Kth-Smallest-Sum-of-a-Matrix-With-Sorted-Rows-Hard" class="headerlink" title="1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows #Hard"></a><a href="https://leetcode.com/contest/weekly-contest-187/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/">1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows</a> #Hard</h2><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://leetcode.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/discuss/609707/simple-solution-with-explanation-c%2B%2B-code-example">simple solution with explanation [c++ code example]</a></p><p>其实就是暴力累加，但是<strong>在累加每一行之后，从小到大进行排序，只保留最多前 <code>k</code> 个数字，</strong>因为后面的数字不可能参与到第 <code>k</code> 个最终数字的运算中。</p><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mat[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; vec.<span class="built_in">size</span>(); ++t) &#123;</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(mat[i][j]+vec[t]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">int</span> limit = <span class="built_in">min</span>(k, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(tmp.<span class="built_in">size</span>()));</span><br><span class="line">            vec = vector&lt;<span class="keyword">int</span>&gt;(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">begin</span>()+limit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 周赛专题每周随缘更新，点击类别 &lt;a href=&quot;/categories/LeetCode-Weekly-Contest/&quot;&gt;LeetCode Weekly Contest&lt;/a&gt; 查看更多。&lt;/p&gt;
&lt;p&gt;本次比赛通过 &lt;code&gt;3&lt;/code&gt; 题，时间为 &lt;code&gt;1:01:42&lt;/code&gt;，排名为 &lt;code&gt;2281/12350&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="LeetCode Weekly Contest" scheme="https://progcz.com/categories/A03-LeetCode/LeetCode-Weekly-Contest/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Data Structure and Algorithm" scheme="https://progcz.com/tags/Data-Structure-and-Algorithm/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 May LeetCoding Challenge - Week 1</title>
    <link href="https://progcz.com/posts/2020-may-leetcoding-challenge-week-1/"/>
    <id>https://progcz.com/posts/2020-may-leetcoding-challenge-week-1/</id>
    <published>2020-05-01T08:06:40.000Z</published>
    <updated>2020-05-07T08:08:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 五月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-May-LeetCoding-Challenge/">2020 May LeetCoding Challenge</a> 查看更多。</p><span id="more"></span><p>P.S. 四月挑战因为错过了开头，不想从半路开始，所以干脆没做，现在五月挑战出现了，希望自己能坚持做完。</p><h2 id="May-1st-First-Bad-Version"><a href="#May-1st-First-Bad-Version" class="headerlink" title="May 1st: First Bad Version"></a>May 1st: <a href="https://leetcode.com/explore/featured/card/may-leetcoding-challenge/534/week-1-may-1st-may-7th/3316/">First Bad Version</a></h2><p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p><p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p><p>You are given an API <code>bool isBadVersion(version)</code> which will return whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given n &#x3D; 5, and version &#x3D; 4 is the first bad version.</span><br><span class="line"></span><br><span class="line">call isBadVersion(3) -&gt; false</span><br><span class="line">call isBadVersion(5) -&gt; true</span><br><span class="line">call isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">Then 4 is the first bad version.</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>二分查找算法就可以解决，注意 <code>beg</code> 和 <code>end</code> 两个边界值应该如何变化即可。</p><div class="note info"><p>二分查找算法可以参考这篇文章：<a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/er-fen-cha-zhao-xiang-jie">二分查找详解</a>。</p></div><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The API isBadVersion is defined for you.</span></span><br><span class="line"><span class="comment">// bool isBadVersion(int version);</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beg &gt;= end) <span class="keyword">return</span> beg;</span><br><span class="line">        <span class="keyword">int</span> mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isBadVersion</span>(mid)) end = mid;</span><br><span class="line">        <span class="keyword">else</span> beg = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(beg, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-2nd-Jewels-and-Stones"><a href="#May-2nd-Jewels-and-Stones" class="headerlink" title="May 2nd: Jewels and Stones"></a>May 2nd: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/534/week-1-may-1st-may-7th/3317/">Jewels and Stones</a></h2><p>You’re given strings <code>J</code> representing the types of stones that are jewels, and <code>S</code> representing the stones you have. Each character in <code>S</code> is a type of stone you have. You want to know how many of the stones you have are also jewels.</p><p>The letters in <code>J</code> are guaranteed distinct, and all characters in <code>J</code> and <code>S</code> are letters. Letters are case sensitive, so <code>&quot;a&quot;</code> is considered a different type of stone from <code>&quot;A&quot;</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: J &#x3D; &quot;aA&quot;, S &#x3D; &quot;aAAbbbb&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: J &#x3D; &quot;z&quot;, S &#x3D; &quot;ZZ&quot;</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p><code>S</code> and <code>J</code> will consist of letters and have length at most 50.</p></li><li><p>The characters in <code>J</code> are distinct.</p></li></ul><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>侮辱智商，不解释了。</p><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(string J, string S)</span> </span>&#123;</span><br><span class="line">        array&lt;<span class="keyword">bool</span>, 52&gt; arr = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : J) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">                arr[ch-<span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                arr[ch-<span class="string">&#x27;A&#x27;</span>+<span class="number">26</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span> &amp;&amp; arr[ch-<span class="string">&#x27;a&#x27;</span>]) ||</span><br><span class="line">                (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span> &amp;&amp; arr[ch-<span class="string">&#x27;A&#x27;</span>+<span class="number">26</span>])) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-3rd-Ransom-Note"><a href="#May-3rd-Ransom-Note" class="headerlink" title="May 3rd: Ransom Note"></a>May 3rd: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/534/week-1-may-1st-may-7th/3318/">Ransom Note</a></h2><p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines; otherwise, it will return false.</p><p>Each letter in the magazine string can only be used once in your ransom note.</p><p><strong>Note:</strong></p><p>You may assume that both strings contain only lowercase letters.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; false</span><br><span class="line">canConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; false</span><br><span class="line">canConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true</span><br></pre></td></tr></table></figure><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用 <code>map&lt;char, int&gt; m</code> 统计 <code>magazine</code> 中每个字符出现的个数，在遍历 <code>ransomNote</code> 的过程中消耗对应字符的个数，如果发现某个字符的个数为负，则说明无法用 <code>magazine</code> 中的字符构造 <code>ransomNote</code>，返回 <code>false</code> 即可。</p><h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : magazine) ++m[ch];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : ransomNote) --m[ch];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-4th-Number-Complement"><a href="#May-4th-Number-Complement" class="headerlink" title="May 4th: Number Complement"></a>May 4th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/534/week-1-may-1st-may-7th/3319/">Number Complement</a></h2><p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p>The given integer is guaranteed to fit within the range of a 32-bit signed integer.</p></li><li><p>You could assume no leading zero bit in the integer’s binary representation.</p></li><li><p>This question is the same as 1009: <a href="https://leetcode.com/problems/complement-of-base-10-integer/">https://leetcode.com/problems/complement-of-base-10-integer/</a></p></li></ul><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>因为需要忽略二进制形式中开头的 <code>0</code>，所以首先从末尾起遍历一遍 <code>num</code>，使用 <code>cnt</code> 记录最后一个 <code>1</code> 出现的位置，然后使用异或运算 <code>^</code> 反转末尾的 <code>cnt</code> 个数字即可。</p><h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, tmp = <span class="number">0x1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &amp; tmp) cnt = i;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">31</span>) tmp = tmp &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = <span class="number">0x1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt+<span class="number">1</span>; ++i) &#123;</span><br><span class="line">            num = num ^ tmp;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">31</span>) tmp = tmp &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-5th-First-Unique-Character-in-a-String"><a href="#May-5th-First-Unique-Character-in-a-String" class="headerlink" title="May 5th: First Unique Character in a String"></a>May 5th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/534/week-1-may-1st-may-7th/3320/">First Unique Character in a String</a></h2><p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p><p><strong>Examples:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;leetcode&quot;,</span><br><span class="line">return 0.</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;loveleetcode&quot;,</span><br><span class="line">return 2.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> You may assume the string contain only lowercase letters.</p><h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，遍历 <code>s</code>，使用 <code>map&lt;char, int&gt; m</code> 记录 <code>s</code> 中每个字符的出现次数。</p><p>然后，遍历 <code>s</code>，找到出现次数为 <code>1</code> 的字符，返回其下标即可。</p><h4 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : s) ++m[ch];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[s[i]] == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-6th-Majority-Element"><a href="#May-6th-Majority-Element" class="headerlink" title="May 6th: Majority Element"></a>May 6th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/534/week-1-may-1st-may-7th/3321/">Majority Element</a></h2><p>Given an array of size <code>n</code>, find the majority element. The majority element is the element that appears <strong>more than</strong> <code>n/2</code> times.</p><p>You may assume that the array is non-empty and the majority element always exist in the array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,2,1,1,1,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>将 <code>nums</code> 进行排序，出现次数大于 <code>n/2</code> 的数字必然出现在下标为 <code>n/2</code> 的位置。</p><h4 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>()/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="May-7th-Cousins-in-Binary-Tree"><a href="#May-7th-Cousins-in-Binary-Tree" class="headerlink" title="May 7th: Cousins in Binary Tree"></a>May 7th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/534/week-1-may-1st-may-7th/3322/">Cousins in Binary Tree</a></h2><p>In a binary tree, the root node is at depth <code>0</code>, and children of each depth <code>k</code> node are at depth <code>k+1</code>.</p><p>Two nodes of a binary tree are <em>cousins</em> if they have the same depth, but have <strong>different parents</strong>.</p><p>We are given the <code>root</code> of a binary tree with unique values, and the values <code>x</code> and <code>y</code> of two different nodes in the tree.</p><p>Return <code>true</code> if and only if the nodes corresponding to the values <code>x</code> and <code>y</code> are cousins.</p><p><strong>Example 1:</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/00.png" style="zoom:80%"/><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,4], x &#x3D; 4, y &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/01.png" style="zoom:80%"/><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,null,4,null,5], x &#x3D; 5, y &#x3D; 4</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/02.png" style="zoom:80%"/><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,null,4], x &#x3D; 2, y &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p>The number of nodes in the tree will be between <code>2</code> and <code>100</code>.</p></li><li><p>Each node has a unique integer value from <code>1</code> to <code>100</code>.</p></li></ul><h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，使用 <code>queue&lt;TreeNode*&gt;</code> 对二叉树进行<strong>层级遍历</strong>。</p><p>其次，对于每一层，<strong>使用 <code>map&lt;int, int&gt; m</code> 记录节点的值与其在该层中的下标 <code>idx</code>，</strong>即使遇到 <code>nullptr</code> 的话 <code>idx</code> 也会自增，只是不做记录而已。</p><p>然后，<strong>如果 <code>x</code> 和 <code>y</code> 同时存在于 <code>m</code> 中，那么说明两者在同一层，</strong>继而判断两者是否属于同一父节点：</p><ul><li><p><strong>如果两者在该层的下标相差不为 <code>1</code>，那么不可能属于同一父节点。</strong></p></li><li><p><strong>如果两者在该层的下标相差为 <code>1</code>，但是两者下标中的较小者不是奇数，那么说明两者虽然相邻但属于不同父节点。</strong></p></li></ul><h4 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCousins</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; t;</span><br><span class="line">            map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">            <span class="keyword">int</span> idx = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                    t.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                    m[node-&gt;left-&gt;val] = idx;</span><br><span class="line">                &#125;</span><br><span class="line">                ++idx;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                    t.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                    m[node-&gt;right-&gt;val] = idx;</span><br><span class="line">                &#125;</span><br><span class="line">                ++idx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">find</span>(x) != m.<span class="built_in">end</span>() &amp;&amp; m.<span class="built_in">find</span>(y) != m.<span class="built_in">end</span>() &amp;&amp;</span><br><span class="line">                (<span class="built_in">abs</span>(m[x]-m[y]) != <span class="number">1</span> || <span class="built_in">min</span>(m[x],m[y]) % <span class="number">2</span> != <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode 五月挑战专题每日随缘更新，点击类别 &lt;a href=&quot;/categories/2020-May-LeetCoding-Challenge/&quot;&gt;2020 May LeetCoding Challenge&lt;/a&gt; 查看更多。&lt;/p&gt;</summary>
    
    
    
    <category term="A03 - LeetCode" scheme="https://progcz.com/categories/A03-LeetCode/"/>
    
    <category term="2020 LeetCoding Challenge" scheme="https://progcz.com/categories/A03-LeetCode/2020-LeetCoding-Challenge/"/>
    
    
    <category term="CPP" scheme="https://progcz.com/tags/CPP/"/>
    
    <category term="Data Structure and Algorithm" scheme="https://progcz.com/tags/Data-Structure-and-Algorithm/"/>
    
    <category term="LeetCode" scheme="https://progcz.com/tags/LeetCode/"/>
    
    <category term="Challenge" scheme="https://progcz.com/tags/Challenge/"/>
    
  </entry>
  
</feed>
