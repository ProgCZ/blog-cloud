---
title:   2021 August LeetCoding Challenge - Week 2
date:    2021-08-09 08:57:37
updated: 2021-08-10 08:48:27
categories:
    - A3 - LeetCode
    - B4 - LeetCoding Challenge
tags:
    - LeetCode
    - CPP
---

LeetCode 八月挑战专题，第二周，每日随缘更新。

<!-- more -->

## August 8th: [Rank Transform of a Matrix](https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/614/week-2-august-8th-august-14th/3874/)

### 大意

给定 `m*n` 的矩阵 `matrix`，返回矩阵中每个元素的 `rank`。

其中，`rank` 遵循以下规则：

- `rank` 从 `1` 开始。

- 对于在同一行或同一列的 `p` 和 `q`，

  - 如果 `p < q`，那么 `rank(p) < rank(q)`。

  - 如果 `p == q`，那么 `rank(p) == rank(q)`。

  - 如果 `p > q`，那么 `rank(p) > rank(q)`。

- `rank` 应该尽可能地小。

### 解法

> 参考：[[C++/Python] HashMap & Sort & UnionFind - Visualize picture - Clean & Concise](https://leetcode.com/problems/rank-transform-of-a-matrix/discuss/1391380/C%2B%2BPython-HashMap-and-Sort-and-UnionFind-Visualize-picture-Clean-and-Concise)

首先，找到同一数字的所有位置。

其次，在某个数字的所有位置中，找到在同一行和同一列的位置，以是否为同一 `rank` 聚合起来。

最后，找到同一行和同一列中目前的最大值，`+1` 即可。

#### 复杂度分析

- 空间：`O(m*n*log(m*n))`

- 时间：`O(m*n)`

#### C++ 实现

```cpp
class UnionFind {
public:
    unordered_map<int, int> parent;
    int Find(int u) {
        if (u == parent[u]) return u;
        return parent[u] = Find(parent[u]);
    }
    void Union(int u, int v) {
        if (parent.count(u) == 0) parent[u] = u;
        if (parent.count(v) == 0) parent[v] = v;
        int pu = Find(u), pv = Find(v);
        if (pu != pv) parent[pu] = pv;
    }
};

class Solution {
public:
    vector<vector<int>> matrixRankTransform(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        map<int, vector<pair<int, int>>> groupByValue;
        for (int r = 0; r < m; ++r)
            for (int c = 0; c < n; ++c)
                groupByValue[matrix[r][c]].push_back({r, c});

        vector<int> rank(m+n, 0);
        for (auto const& [_, cells]  : groupByValue) {
            UnionFind uf;
            for (auto const& [r, c] : cells)
                uf.Union(r, c + m);

            unordered_map<int, vector<int>> groups;
            for (auto const& [u, _] : uf.parent) {
                groups[uf.Find(u)].push_back(u);
            }

            for (auto const& [_, group] : groups) {
                int maxRank = 0;
                for (int i : group) maxRank = max(maxRank, rank[i]);
                for (int i : group) rank[i] = maxRank + 1;
            }
            for (auto const& [r, c] : cells) matrix[r][c] = rank[r];
        }
        return matrix;
    }
};
```

## August 9th: [Add Strings](https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/614/week-2-august-8th-august-14th/3875/)

### 大意

以字符串的形式，给定两个非负整数 `num1` 和 `num2`，同样以字符串的形式，返回这两个数字之和。

### 解法

按位转换成数字，相加进位即可。

#### 复杂度分析

- 空间：`O(n)`

- 时间：`O(n)`

#### C++ 实现

```cpp
class Solution {
public:
    string addStrings(string num1, string num2) {
        string res;
        int n = max(num1.size(), num2.size()), next = 0;
        reverse(num1.begin(), num1.end());
        reverse(num2.begin(), num2.end());
        for (int i = 0; i < n; ++i) {
            char c1 = i < num1.size() ? num1[i] : '0';
            char c2 = i < num2.size() ? num2[i] : '0';
            int sum = c1 - '0' + c2 - '0' + next;
            res.push_back(sum % 10 + '0');
            next = sum / 10;
        }
        if (next > 0) {
            res.push_back(next + '0');
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```
