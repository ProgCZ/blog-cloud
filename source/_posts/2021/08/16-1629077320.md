---
title:   2021 August LeetCoding Challenge - Week 3
date:    2021-08-16 09:29:05
updated: 2021-08-17 09:25:45
categories:
    - A3 - LeetCode
    - B4 - LeetCoding Challenge
tags:
    - LeetCode
    - CPP
---

LeetCode 八月挑战专题，第三周，每日随缘更新。

<!-- more -->

## August 15th: [Minimum Window Substring](https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/615/week-3-august-15th-august-21st/3891/)

### 大意

给定字符串 `s` 和 `t`，返回 `s` 中的最短子串，使得该子串包含 `t` 中的所有字符，如果不存在，那么返回 `""`。题目保证答案唯一。

### 解法

> 参考：[[LeetCode] 76. Minimum Window Substring 最小窗口子串 - 刷尽天下](https://www.cnblogs.com/grandyang/p/4340948.html)

#### 复杂度分析

- 空间：`O(1)`

- 时间：`O(m*n)`，不确定

#### C++ 实现

```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        vector<int> letterCnt(128, 0);
        int left = 0, cnt = 0, minLeft = -1, minLen = INT_MAX;
        for (char c : t) ++letterCnt[c];
        for (int i = 0; i < s.size(); ++i) {
            if (--letterCnt[s[i]] >= 0) ++cnt;
            while (cnt == t.size()) {
                if (minLen > i - left + 1) {
                    minLen = i - left + 1;
                    minLeft = left;
                }
                if (++letterCnt[s[left]] > 0) --cnt;
                ++left;
            }
        }
        return minLeft == -1 ? "" : s.substr(minLeft, minLen);
    }
};
```

## August 16th: [Range Sum Query - Immutable](https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/615/week-3-august-15th-august-21st/3892/)

### 大意

给定数组 `nums`、多组索引 `left` 和 `right`，返回 `left` 和 `right` 之间（包含两端）数字的和。

### 解法

遍历 `nums`，记录当前数字 `num`，以及从索引 `0` 和当前索引之间（包含两端）数字的和 `sum`。

在进行计算的时候，索引 `left` 和 `right` 记录的值相减，加上 `left` 所在数字即可。

#### 复杂度分析

- 空间：`O(n)`

- 时间：`O(n)`

#### C++ 实现

```cpp
class NumArray {
public:
    vector<pair<int, int>> sums;
    NumArray(vector<int>& nums) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
            sums.emplace_back(num, sum);
        }
    }

    int sumRange(int left, int right) {
        return sums[right].second - sums[left].second + sums[left].first;
    }
};

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray* obj = new NumArray(nums);
 * int param_1 = obj->sumRange(left,right);
 */
```
