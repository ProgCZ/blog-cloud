---
title:   2021 August LeetCoding Challenge - Week 3
date:    2021-08-16 09:29:05
updated: 2021-08-18 22:11:23
categories:
    - A3 - LeetCode
    - B4 - LeetCoding Challenge
tags:
    - LeetCode
    - CPP
---

LeetCode 八月挑战专题，第三周，每日随缘更新。

<!-- more -->

## August 15th: [Minimum Window Substring](https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/615/week-3-august-15th-august-21st/3891/)

### 大意

给定字符串 `s` 和 `t`，返回 `s` 中的最短子串，使得该子串包含 `t` 中的所有字符，如果不存在，那么返回 `""`。题目保证答案唯一。

### 解法

> 参考：[[LeetCode] 76. Minimum Window Substring 最小窗口子串 - 刷尽天下](https://www.cnblogs.com/grandyang/p/4340948.html)

#### 复杂度分析

- 空间：`O(1)`

- 时间：`O(m*n)`，不确定

#### C++ 实现

```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        vector<int> letterCnt(128, 0);
        int left = 0, cnt = 0, minLeft = -1, minLen = INT_MAX;
        for (char c : t) ++letterCnt[c];
        for (int i = 0; i < s.size(); ++i) {
            if (--letterCnt[s[i]] >= 0) ++cnt;
            while (cnt == t.size()) {
                if (minLen > i - left + 1) {
                    minLen = i - left + 1;
                    minLeft = left;
                }
                if (++letterCnt[s[left]] > 0) --cnt;
                ++left;
            }
        }
        return minLeft == -1 ? "" : s.substr(minLeft, minLen);
    }
};
```

## August 16th: [Range Sum Query - Immutable](https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/615/week-3-august-15th-august-21st/3892/)

### 大意

给定数组 `nums`、多组索引 `left` 和 `right`，返回 `left` 和 `right` 之间（包含两端）数字的和。

### 解法

遍历 `nums`，记录当前数字 `num`，以及从索引 `0` 和当前索引之间（包含两端）数字的和 `sum`。

在进行计算的时候，索引 `left` 和 `right` 记录的值相减，加上 `left` 所在数字即可。

#### 复杂度分析

- 空间：`O(n)`

- 时间：`O(n)`

#### C++ 实现

```cpp
class NumArray {
public:
    vector<pair<int, int>> sums;
    NumArray(vector<int>& nums) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
            sums.emplace_back(num, sum);
        }
    }

    int sumRange(int left, int right) {
        return sums[right].second - sums[left].second + sums[left].first;
    }
};

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray* obj = new NumArray(nums);
 * int param_1 = obj->sumRange(left,right);
 */
```

## August 17th: [Count Good Nodes in Binary Tree](https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/615/week-3-august-15th-august-21st/3899/)

### 大意

给定二叉树，其根节点为 `root`。对于某个节点 `node`，如果从 `root` 到 `node` 的路径上，没有比 `node` 值更大的节点，那么 `node` 为好节点。返回该树中好节点的数量。

### 解法

在 DFS 的过程中，维护当前路径下的最大值 `max_num` 即可。

#### 复杂度分析

- 空间：`O(1)`

- 时间：`O(n)`

#### C++ 实现

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int goodNodes(TreeNode* root) {
        int cnt = 0, max_num = INT_MIN;
        dfs(root, cnt, max_num);
        return cnt;
    }
    void dfs(TreeNode* node, int& cnt, int max_num) {
        if (!node) return;
        if (node->val >= max_num) {
            ++cnt;
            max_num = node->val;
        }
        dfs(node->left, cnt, max_num);
        dfs(node->right, cnt, max_num);
    }
};
```

## August 18th: [Decode Ways](https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/615/week-3-august-15th-august-21st/3902/)

### 大意

给定字符均为数字的字符串，按照以下解码规则：

```text
'A' <- "1"
'B' <- "2"
...
'Z' <- "26"
```

可以对字符串进行解码。然而，同一字符串，根据不同数字的组合方式，可能有不同的解码字符串，比如 `11106` 可以对应 `AAJF` 或 `KJF`。要求返回可能的解码字符串的数量。

### 解法

> 参考：[[LeetCode] 91. Decode Ways 解码方法 - 刷尽天下](https://www.cnblogs.com/grandyang/p/4313384.html)

#### 复杂度分析

- 空间：`O(n)`

- 时间：`O(n)`

#### C++ 实现

```cpp
class Solution {
public:
    int numDecodings(string s) {
        if (s.empty() || s[0] == '0') return 0;
        vector<int> dp(s.size() + 1, 0);
        dp[0] = 1;
        for (int i = 1; i < dp.size(); ++i) {
            dp[i] = (s[i - 1] == '0') ? 0 : dp[i - 1];
            if (i > 1 && (s[i - 2] == '1' || (s[i - 2] == '2' && s[i - 1] <= '6'))) {
                dp[i] += dp[i - 2];
            }
        }
        return dp.back();
    }
};
```
