---
title:   2021 August LeetCoding Challenge - Week 1
date:    2021-08-01 23:28:02
updated: 2021-08-02 00:30:35
categories:
    - A3 - LeetCode
    - B5 - 2021 LeetCoding Challenge
tags:
    - LeetCode
    - CPP
---

LeetCode 八月挑战专题，第一周，每日随缘更新。

<!-- more -->

## August 1st: [Making A Large Island](https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/613/week-1-august-1st-august-7th/3835/)

### 大意

给定 `n*n` 的矩阵，每格中的数字为 `0` 或 `1`，可以将其中的 `1` 个格子从 `0` 置为 `1`，求解矩阵中最大「岛屿」的面积。

其中，「岛屿」是指在上、下、左、右四个方向中，连通起来的 `1` 的区域。

### 解法

> 参考：[C++ BFS  O(n^2) 5% :(](https://leetcode.com/problems/making-a-large-island/discuss/1376700/C%2B%2B-BFS-O(n2)-5-%3A()

首先，遍历矩阵，使用 BFS 探索所有的岛屿，标记为不同的 `flag`，并且使用 `record` 记录不同 `flag` 对应的岛屿面积 `cnt`。

其次，遍历矩阵，找出上、下、左、右四个方向所对应的 `flag`，累加其 `cnt` 即可。

#### 复杂度分析

- 空间：`O(n^2)`

- 时间：`O(n^4)`

#### C++ 实现

```cpp
class Solution {
public:
    pair<int, int> dirs[4] = {
        {-1, 0}, {1, 0}, {0, -1}, {0, 1}
    };
    void bfs(vector<vector<int>>& grid, unordered_map<int, int>& record, int i, int j, int flag) {
        int n = grid.size(), cnt = 0;
        queue<pair<int, int>> q;
        q.push({i, j});
        grid[i][j] = flag;
        while (!q.empty()) {
            auto [x, y] = q.front(); q.pop();
            ++cnt;
            for (const auto& dir : dirs) {
                int nx = x + dir.first, ny = y + dir.second;
                if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] == 1) {
                    q.push({nx, ny});
                    grid[nx][ny] = flag;
                }
            }
        }
        record[flag] = cnt;
    }
    int largestIsland(vector<vector<int>>& grid) {
        int n = grid.size(), flag = 2, res = 0;
        unordered_map<int, int> record;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == 1) {
                    bfs(grid, record, i, j, flag++);
                }
            }
        }
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                unordered_set<int> us;
                us.insert(grid[i][j]);
                for (const auto& dir : dirs) {
                    int ni = i + dir.first, nj = j + dir.second;
                    if (ni >= 0 && ni < n && nj >= 0 && nj < n) {
                        us.insert(grid[ni][nj]);
                    }
                }
                int sum = !grid[i][j];
                for (const auto& flag : us) {
                    sum += record[flag];
                }
                res = max(res, sum);
            }
        }
        return res;
    }
};
```

## August 2nd: [Two Sum](https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/613/week-1-august-1st-august-7th/3836/)

### 大意

给定数组 `nums` 和数字 `target`，要求在 `nums` 中找到两个数字，和为 `target`，返回这两个数字的下标。

题目保证有且只有一个解，而且同一个数字不能用两次。

### 解法

以前做过，参见：[LeetCode Problem 1 - Two Sum](/posts/leetcode-problem-two-sum/#%E8%A7%A3%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%80%9F%E5%8A%A9-hash-map%EF%BC%8C%E7%94%A8%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4)

#### 复杂度分析

- 空间：`O(n)`

- 时间：`O(n)`

#### C++ 实现

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> record;
        for (int i = 0; i < nums.size(); ++i) {
            auto iter = record.find(target-nums[i]);
            if (iter != record.end()) {
                return {i, iter->second};
            }
            record[nums[i]] = i;
        }
        return {};
    }
};
```
