---
title:   面试中常见的 C++ 问题汇总
date:    2021-10-18 23:07:20
updated: 2021-10-26 09:54:03
categories:
    - A2 - 学习笔记
    - B2 - 编程语言
    - C1 - CPP
tags:
    - 面试
    - CPP
---

以前秋招，整理过一版 C++ 问题汇总，这次社招，重新梳理一遍。

<!-- more -->

## 1 语法基础

### C++ 和 C 有什么区别？

- C++ 是面向对象的语言，而 C 是面向过程的语言

- C++ 引入类的概念，而 C 中没有

- C++ 引入引用的概念，而 C 中没有

- C++ 引入函数重载的特性，而 C 中没有

- C++ 引入 `new/delete` 运算符，取代 C 中的 `malloc/free` 库函数

### 相比于 C++98，C++11 有哪些新特性？

- 引入 Lambda 表达式用于创建匿名函数

- 引入自动类型推导 `auto` 和 `decltype`

- 引入 `= default` 生成默认构造函数，`= delete` 禁止使用拷贝构造函数

- 引入 `nullptr` 关键字，用于解决 `NULL` 的二义性问题

- 引入范围 `for` 循环

- 引入列表初始化

- 引入 `shared_ptr`、`unique_ptr` 等智能指针

- 引入右值引用，将引用绑定到右值，如临时对象或字面量

- 引入线程库

### `struct` 和 `class` 有什么区别？

- 成员的默认访问权限：`struct` 的成员默认为 `public` 权限，`class` 的成员默认为 `private` 权限

- 默认继承权限：`struct` 的继承按照 `public` 处理，`class` 的继承按照 `private` 处理

### 对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？

应该使用 `inline` 内联函数，即编译器将 `inline` 内联函数内的代码替换到函数被调用的地方。

优点：

- 在内联函数被调用的地方进行代码展开，省去函数调用的时间，从而提高程序运行效率

- 相比于宏函数，内联函数在代码展开时，编译器会进行语法安全检查或数据类型转换，使用更加安全

缺点：

- 代码膨胀，产生更多的开销

- 如果内联函数内代码块的执行时间比调用时间长得多，那么效率的提升并没有那么大

- 如果修改内联函数，那么所有调用该函数的代码文件都需要重新编译

- 内联声明只是建议，是否内联由编译器决定，所以实际并不可控

### `#define` 和 `inline` 有什么区别？

- `#define` 宏函数在预处理阶段展开，而 `inline` 内联函数在编译阶段展开

- `#define` 宏函数不检查参数类型，而 `inline` 内联函数检查参数类型，使用更加安全

### `const` 关键字有什么作用？

- 修饰变量时，表示该变量的值在其生命周期内只读，不能被改变

- 修饰指针：`int * const`

- 修饰指针所指向的对象：`const int *`

- 修饰引用所绑定的对象：`const int &`

- 修饰函数的引用形参时，可以保护实参不被函数修改

- 修饰非静态成员变量时，不能在类定义处初始化，必须通过构造函数初始化列表进行初始化

- 修饰静态成员变量时，不能在类内部初始化，一般在类外部进行初始化

- 修饰成员函数时，表示该函数不应修改非静态成员，但并不可靠，因为指针所指对象可能会被修改

### `#define` 和 `const` 有什么区别？

- 编译器处理方式不同：`#define` 宏是在预处理阶段展开，不能对宏定义进行调试，而 `const` 常量是在编译阶段使用

- 类型和安全检查不同：`#define` 宏没有类型，不做任何类型检查，仅仅是代码展开，可能产生边际效应等错误，而 `const` 常量有具体类型，在编译阶段会执行类型检查

- 存储方式不同：`#define` 宏仅仅是代码展开，在多个地方进行字符串替换，不会分配内存，存储于程序的代码段中，而 `const` 常量会分配内存，但只维持一份拷贝，存储于程序的数据段中

- 定义域不同：`#define` 宏不受定义域限制，而 `const` 常量只在定义域内有效

### `explicit` 关键字有什么作用？

可以用单个实参来调用的构造函数都定义了从形参类型到实参类型的隐式转换，这种转换往往都是非预期的，所以使用 `explicit` 关键字对构造函数进行修饰，从而避免由构造函数定义的隐式转换。

### `extern`关键字有什么作用？

- 当 `extern` 修饰变量或函数时，表示变量或函数的定义在其他文件中，提示编译器在其他模块中寻找其定义

- 当 `extern C` 时，提示编译器在编译函数时按照 C 的规则去翻译相应的函数名，如果按照 C++ 的规则，函数名会被翻译得变得面目全非，因为 C++ 支持函数的重载。

### `static`关键字有什么作用？

- 修饰局部变量时，使得该变量在静态存储区分配内存；只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化；其生命周期与程序相同，但其作用域为局部作用域，并不能一直被访问

- 修饰全局变量时，使得该变量在静态存储区分配内存；在声明该变量的整个文件中都是可见的，而在文件外是不可见的

- 修饰函数时，在声明该函数的整个文件中都是可见的，而在文件外是不可见的，从而可以在多人协作时避免同名的函数冲突

- 修饰成员变量时，所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加 `static`

- 修饰成员函数时，该函数不接受 `this` 指针，只能访问类的静态成员；不需要实例化对象即可访问

### `sizeof` 和 `strlen` 之间有什么区别？

- `sizeof` 属于运算符，不是库函数，其结果在编译时期计算得到，因此不能用来得到动态分配的内存大小，而 `strlen` 属于库函数，其结果在运行期间计算得到

- `sizeof` 参数可以是任何数据或数据类型，而 `strlen` 的参数只能是字符指针，且该指针指向结尾为 `\0` 的字符串

### `assert` 有什么用处？

`assert` 是一种仅在 debug 版本中使用的宏函数，用于检查不该发生的情况，可以看作是一种在任何系统状态下都可以安全使用的无害测试手段；可以通过 `#define NDEBUG` 来关闭 `assert`，放在 `<cassert>` 头文件之前。

### 变量的声明和定义有什么区别？

- 声明仅仅是把变量类型等信息提供给编译器，并不为其分配内存空间，而定义需要为变量分配内存空间

- 变量可以在多处声明，如外部变量 `extern`，但只能在一处定义

### 指针和引用有什么区别？

- 指针是一种对象，用来存放某个对象的地址，占用内存空间，而引用是一种别名，不占用内存空间

- 指针可以声明为空，之后进行初始化，普通指针可以随时更换所指对象，而引用必须在声明的时候初始化，而且初始化后不可改变

- 指针包含指向常量的指针和常量指针，而引用不包含常量引用，但包含对常量的引用

## 3 面向对象

### `public` 成员、`protected` 成员、`private` 成员有什么区别？

- `public` 成员可以被本类及本类对象、友元类及友元类对象、子类及子类对象访问

- `protected` 成员可以被本类、友元类、子类访问，不能被任何对象访问

- `private` 成员只可以被本类访问

### `public` 继承、`protected` 继承、`private` 继承有什么区别？

不管哪类继承，子类都可以访问父类的 `public` 成员、`protected` 成员，但是继承之后，成员属性会发生变化：

| 父类成员 | `public` 继承后子类成员 | `protected` 继承后子类成员 | `private` 继承后子类成员 |
| --- | --- | --- | --- |
| `public` | `public` | `protected` | `private` |
| `protected` | `protected` | `protected` | `private` |
| `private` | 无法继承 | 无法继承 | 无法继承 |
