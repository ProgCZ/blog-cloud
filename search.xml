<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>新年后的学习规划</title>
    <url>/posts/study-plan-after-new-year/</url>
    <content><![CDATA[<p>这是一份不知道能不能实现的学习规划，希望自己能成为更好的自己。</p>
<span id="more"></span>

<h2 id="0-写在最前"><a href="#0-写在最前" class="headerlink" title="0 写在最前"></a>0 写在最前</h2><p>最近几年我感悟最深的就是「生于忧患，死于安乐」，尤其对于我这么一个没有压力不成活的人，没有外界的刺激就开始安于现状。</p>
<p>所以，2017 年的 01 月 01 日，我写了篇文章骂自己，当时的我不知道自己能干什么，不知道自己会干什么，随便翻一眼通讯录就是比自己优秀的人，慌乱、迷茫、不知所往。</p>
<p>现在，2018 年的 01 月 01 日，我依然有点迷茫，但好在自己心里也多少有了点方向，那就也写篇文章，这次不骂自己，只列规划。</p>
<h2 id="1-具体规划"><a href="#1-具体规划" class="headerlink" title="1 具体规划"></a>1 具体规划</h2><h3 id="1-1-代码能力"><a href="#1-1-代码能力" class="headerlink" title="1.1 代码能力"></a>1.1 代码能力</h3><ul>
<li><p>掌握 <strong>C、C++ 和 Python</strong>：大概是以后赖以为生的三门语言吧。</p>
</li>
<li><p>熟悉 <strong>Bash</strong>：Linux 环境下的 Shell 脚本语言。</p>
</li>
<li><p><del>会用 <strong>HTML、CSS 和 JavaScript</strong>：前端三板斧，JS 还可以用于后端。</del></p>
</li>
<li><p><del>会用 <strong>Node.js</strong>：后端。</del></p>
</li>
<li><p><del>可能需要会用 <strong>MySQL</strong>：数据库。</del></p>
</li>
</ul>
<h3 id="1-2-算法知识"><a href="#1-2-算法知识" class="headerlink" title="1.2 算法知识"></a>1.2 算法知识</h3><ul>
<li><p>掌握重要的数据结构与算法，通关 LeetCode 等算法题库，为工作面试做准备。</p>
</li>
<li><p>掌握<strong>机器学习、深度学习和强化学习</strong>的算法。</p>
</li>
</ul>
<h3 id="1-3-环境框架"><a href="#1-3-环境框架" class="headerlink" title="1.3 环境框架"></a>1.3 环境框架</h3><ul>
<li><p><del><strong>(C++) TensorFlow</strong>：Google 的深度学习开发框架。</del></p>
</li>
<li><p><strong>(Python) Scikit-Learn</strong>：机器学习开发框架。</p>
</li>
<li><p><strong>(Python) PyTorch</strong>：Facebook 的深度学习开发框架。</p>
</li>
<li><p><del><strong>Gym</strong>：OpenAI 的强化学习环境库。</del></p>
</li>
<li><p><strong>ROS</strong>：机器人操作系统。</p>
</li>
</ul>
<h3 id="1-4-程序开发"><a href="#1-4-程序开发" class="headerlink" title="1.4 程序开发"></a>1.4 程序开发</h3><ul>
<li><p><del><strong>微信小程序</strong>：简单小应用、小游戏。</del></p>
</li>
<li><p><strong>Kaggle or 天池大赛</strong>：机器学习、深度学习和强化学习的比赛。</p>
</li>
</ul>
<h3 id="1-5-平台维护"><a href="#1-5-平台维护" class="headerlink" title="1.5 平台维护"></a>1.5 平台维护</h3><ul>
<li><p><strong>个人博客</strong>：主要写<strong>学习 or 随笔性质的文章</strong>，争取能做到一日 or 两日一更。</p>
</li>
<li><p><del><strong>知乎</strong>：不定期回答问题。</del></p>
</li>
<li><p><del><strong>知乎专栏</strong>：主要写<strong>总结 or 理解性质的文章</strong>，争取能做到一周一更。</del></p>
</li>
<li><p><del><strong>微信公众号</strong>：搬运知乎专栏的文章。</del></p>
</li>
</ul>
]]></content>
      <categories>
        <category>A0 - 总结与计划</category>
      </categories>
      <tags>
        <tag>Plan</tag>
        <tag>CPP</tag>
        <tag>Python</tag>
        <tag>Linux</tag>
        <tag>Machine Learning</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Cookbook</title>
    <url>/posts/git-cookbook/</url>
    <content><![CDATA[<p>本文介绍一些使用 <code>Git</code> 的过程中经常遇到的问题及解决方法。</p>
<span id="more"></span>

<h2 id="1-如何在新设备上配置-Git"><a href="#1-如何在新设备上配置-Git" class="headerlink" title="1 如何在新设备上配置 Git"></a>1 如何在新设备上配置 Git</h2><h3 id="1-1-本地配置"><a href="#1-1-本地配置" class="headerlink" title="1.1 本地配置"></a>1.1 本地配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;ProgCZ&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;zhaozengzhi1995@163.com&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-GitHub-远程配置"><a href="#1-2-GitHub-远程配置" class="headerlink" title="1.2 GitHub 远程配置"></a>1.2 GitHub 远程配置</h3><p>生成公钥和私钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;zhaozengzhi1995@163.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>查看公钥的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat .ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>将公钥的内容复制到 GitHub 的<a href="https://github.com/settings/keys">设置</a>中即可。</p>
<h3 id="1-3-下拉-Repo"><a href="#1-3-下拉-Repo" class="headerlink" title="1.3 下拉 Repo"></a>1.3 下拉 Repo</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git remote add origin git@github.com:ProgCZ/xxx.git</span><br><span class="line">$ git pull origin master</span><br></pre></td></tr></table></figure>

<h3 id="1-4-上推-Repo"><a href="#1-4-上推-Repo" class="headerlink" title="1.4 上推 Repo"></a>1.4 上推 Repo</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add -A</span><br><span class="line">$ git commit -m <span class="string">&quot;xxx&quot;</span></span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<h2 id="2-如何查看和丢弃某一文件未-commit-的修改"><a href="#2-如何查看和丢弃某一文件未-commit-的修改" class="headerlink" title="2 如何查看和丢弃某一文件未 commit 的修改"></a>2 如何查看和丢弃某一文件未 <code>commit</code> 的修改</h2><p>查看 <code>README.md</code> 文件未 <code>commit</code> 的修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff README.md</span><br></pre></td></tr></table></figure>

<p>丢弃暂存区的修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git restore --staged README.md</span><br></pre></td></tr></table></figure>

<p>丢弃工作区的修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git restore README.md</span><br></pre></td></tr></table></figure>

<h2 id="3-如何查看、合并和删除分支"><a href="#3-如何查看、合并和删除分支" class="headerlink" title="3 如何查看、合并和删除分支"></a>3 如何查看、合并和删除分支</h2><p>查看本地的所有分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure>

<p>查看本地和远程的所有分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -a</span><br></pre></td></tr></table></figure>

<p>创建分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch dev</span><br></pre></td></tr></table></figure>

<p>切换分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Pre code</span></span><br><span class="line">$ git checkout dev</span><br><span class="line"><span class="comment"># New code</span></span><br><span class="line">$ git switch dev</span><br></pre></td></tr></table></figure>

<p>创建并切换分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Pre code</span></span><br><span class="line">$ git checkout -b dev</span><br><span class="line"><span class="comment"># New code</span></span><br><span class="line">$ git switch -c dev</span><br></pre></td></tr></table></figure>

<p>使用 Fast forward 模式合并某分支到当前分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span><br></pre></td></tr></table></figure>

<p>效果如图：</p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/03/00.png" style="zoom:80%"/>

<p>禁用 Fast forward 模式合并某分支到当前分支，提交一次新的 <code>commit</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge --no-ff -m <span class="string">&quot;merge with no-ff&quot;</span> dev</span><br></pre></td></tr></table></figure>

<p>效果如图：</p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/03/01.png" style="zoom:80%"/>

<p>查看分支的合并情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure>

<p>删除已合并的分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -d dev</span><br></pre></td></tr></table></figure>

<p>删除未合并的分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -D dev</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A2 - 学习笔记</category>
        <category>B3 - 开发基础</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Cookbook</tag>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>使用马拉车算法解决最长回文子串问题</title>
    <url>/posts/apply-manacher-s-algorithm-to-solve-longest-palindromic-substring-problem/</url>
    <content><![CDATA[<p>使用马拉车算法（即 Manacher’s Algorithm）可以将解决最长回文子串（即 Longest Palindromic Substring）问题的时间复杂度降至 <code>O(n)</code>。</p>
<span id="more"></span>

<p>参考：<a href="https://www.cnblogs.com/grandyang/p/4475985.html">Manacher’s Algorithm 马拉车算法 - 刷尽天下</a></p>
<h2 id="1-最长回文子串问题"><a href="#1-最长回文子串问题" class="headerlink" title="1 最长回文子串问题"></a>1 最长回文子串问题</h2><p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<h2 id="2-马拉车算法"><a href="#2-马拉车算法" class="headerlink" title="2 马拉车算法"></a>2 马拉车算法</h2><h3 id="2-1-添加字符-用以解决回文子串中的奇偶性问题"><a href="#2-1-添加字符-用以解决回文子串中的奇偶性问题" class="headerlink" title="2.1 添加字符 # 用以解决回文子串中的奇偶性问题"></a>2.1 添加字符 <code>#</code> 用以解决回文子串中的奇偶性问题</h3><p><strong>添加字符 <code>#</code>，使得字符串 <code>s</code> 中每个字符的左右两侧都有一个 <code>#</code>，</strong>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bob  -&gt; #b#o#b#</span><br><span class="line">noon -&gt; #n#o#o#n#</span><br></pre></td></tr></table></figure>

<p>目的在于，<strong>不管原回文子串的长度是奇是偶，处理后的新回文子串的长度永远为奇数，</strong>便于处理。</p>
<h3 id="2-2-定义数组-radius-用以表示各元素的最长回文子串半径"><a href="#2-2-定义数组-radius-用以表示各元素的最长回文子串半径" class="headerlink" title="2.2 定义数组 radius 用以表示各元素的最长回文子串半径"></a>2.2 定义数组 <code>radius</code> 用以表示各元素的最长回文子串半径</h3><p>定义数组 <code>radius</code>，其长度与处理后的新字符串 <code>ns</code> 的长度保持一致，**<code>radius</code> 中每个位置的值表示以 <code>ns</code> 对应位置的字符为中心的最长回文子串的半径，**维护结束的 <code>radius</code> 大概是这个样子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ns:     # a # b # b # a # b # b #</span><br><span class="line">radius: 1 2 1 2 5 2 1 6 1 2 3 2 1</span><br></pre></td></tr></table></figure>

<p>目的在于，**<code>radius</code> 中某个位置的值减一之后刚好等于原字符串 <code>s</code> 中回文子串的长度，**举个例子：下图中的 <code>radius[4] == 5</code>，也就是说以 <code>ns[4] == &#39;#&#39;</code> 为中心的最长回文子串 <code>#a#b#b#a#</code> 的半径为<code>5</code>，<code>5 - 1 == 4</code>，对应原字符串中的最长回文子串为 <code>abba</code>，其长度刚好是 <code>4</code>，符合规律且数学上也很容易证明。</p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/01/00.png" style="zoom:80%"/>

<p>只知道长度无法确定子串，还需要知道子串的起始位置。为了便于计算，我们<strong>在新字符串 <code>ns</code> 开头加入字符 <code>$</code>，此时 <code>radius</code> 中某个位置的下标减去其值，再除以 <code>2</code> 刚好等于原字符串 <code>s</code> 中回文子串的起始位置，</strong>举个例子：下图中的 <code>radius[8] == 6</code>，也就是说以 <code>ns[8] == &#39;a&#39;</code> 为中心的最长回文子串 <code>#b#b#a#b#b#</code> 的半径为 <code>6</code>，<code>(8 - 6) / 2 == 1</code>，对应原字符串中的最长回文子串为 <code>bbabb</code>，其起始位置刚好是 <code>1</code>，符合规律且数学上也很容易证明。</p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/01/01.png" style="zoom:80%"/>

<h3 id="2-3-核心：如何维护数组-radius"><a href="#2-3-核心：如何维护数组-radius" class="headerlink" title="2.3 核心：如何维护数组 radius"></a>2.3 核心：如何维护数组 <code>radius</code></h3><p>定义四个变量，分别为：</p>
<ul>
<li><p><code>idx</code> 和 <code>rad</code>：<strong>在所有已遍历过的位置中，必然存在某个最长回文子串能够向右到达最远位置，那么这个子串的中心就是 <code>idx</code>，半径就是 <code>rad</code>。</strong></p>
</li>
<li><p><code>res_idx</code> 和 <code>res_rad</code>：<strong>在所有已遍历过的位置中，必然存在某个位置上的最长回文子串的长度最长，那么这个子串的中心就是 <code>res_idx</code>，半径就是 <code>res_rad</code>。</strong></p>
</li>
</ul>
<p>结合下面这句代码来理解具体的维护过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ns.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    radius[i] = idx + rad &gt; i ? <span class="built_in">min</span>(radius[<span class="number">2</span>*idx-i], idx+rad-i) : <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>对于在新字符串 <code>ns</code> 中遍历到的下标 <code>i</code>，我们想知道<strong>以 <code>i</code> 为中心的最长回文子串的半径，</strong>从半径为 <code>1</code> 开始遍历自然就不能体现这个算法的精妙了，为此我们考虑以下两种情况：</p>
<ul>
<li><p><strong>如果 <code>idx + rad &gt; i</code>，说明 <code>i</code> 没有超出 <code>idx</code> 和 <code>rad</code> 代表的最长回文子串的范围，那么根据回文性质可以知道，在这个子串中，下标 <code>i</code> 的对称位置为下标 <code>idx-(i-idx)</code>（即 <code>2*idx-i</code>），而 <code>radius</code> 中下标 <code>2*idx-i</code> 的位置必然已经维护过了，也就是说以 <code>2*idx-1</code> 为中心的最长回文子串的半径已经知道了，那么以 <code>i</code> 为中心的最长回文子串的半径可以从 <code>radius[2*idx-1]</code> 开始遍历。</strong></p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/01/02.png" style="zoom:80%"/>

<p>但是，<strong>对称位置 <code>2*idx-1</code> 的最长回文子串的半径可能超出了 <code>idx</code> 和 <code>rad</code> 代表的最长回文子串的范围，其超出部分不可能出现在 <code>i</code> 的右侧，但未超出部分还是可以保证满足回文要求的，那么以 <code>i</code> 为中心的最长回文子串的半径必须从 <code>idx+rad-i</code> 开始遍历。</strong></p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/01/03.png" style="zoom:80%"/>

<p>所以，<strong>以 <code>i</code> 为中心的最长回文子串的半径从 <code>min(radius[2*idx-i], idx+rad-i)</code> 开始遍历。</strong></p>
</li>
<li><p><strong>如果 <code>idx + rad &lt;= i</code>，说明 <code>i</code> 超出 <code>idx</code> 和 <code>rad</code> 代表的最长回文子串的范围，那么不存在对称位置可以参考，所以只能从半径为 <code>1</code> 开始遍历。</strong></p>
</li>
</ul>
<p>然后，维护那四个变量：</p>
<ul>
<li><p><strong>如果以 <code>i</code> 为中心的最长回文子串能够向右到达更远位置，则更新 <code>idx</code> 和 <code>rad</code>。</strong></p>
</li>
<li><p><strong>如果以 <code>i</code> 为中心的最长回文子串的长度更长，则更新 <code>res_idx</code> 和 <code>res_rad</code>。</strong></p>
</li>
</ul>
<p>最后，遍历结束，根据前文提到的两个规律从原字符串 <code>s</code> 中截取子串即可。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3 代码实现"></a>3 代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ns = <span class="string">&quot;$#&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            ns.<span class="built_in">push_back</span>(c);</span><br><span class="line">            ns.<span class="built_in">push_back</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">radius</span><span class="params">(ns.size())</span></span>;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>, rad = <span class="number">0</span>, res_idx = <span class="number">0</span>, res_rad = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ns.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            radius[i] = idx + rad &gt; i ? <span class="built_in">min</span>(radius[<span class="number">2</span>*idx-i], idx+rad-i) : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (ns[i-radius[i]] == ns[i+radius[i]]) ++radius[i];</span><br><span class="line">            <span class="keyword">if</span> (idx + rad &lt; i + radius[i]) &#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                rad = radius[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res_rad &lt; radius[i]) &#123;</span><br><span class="line">                res_idx = i;</span><br><span class="line">                res_rad = radius[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>((res_idx-res_rad)/<span class="number">2</span>, res_rad<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-时间和内存对比"><a href="#4-时间和内存对比" class="headerlink" title="4 时间和内存对比"></a>4 时间和内存对比</h2><ul>
<li><p>使用常规算法，时间和内存分别为 <code>16 ms</code> 和 <code>8.6 MB</code>。</p>
</li>
<li><p>使用马拉车算法，时间和内存分别为 <code>4 ms</code> 和 <code>9.7 MB</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>A2 - 学习笔记</category>
        <category>B1 - 数据结构与算法</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Data Structure and Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Biweekly Contest 21 (1370 - 1373)</title>
    <url>/posts/leetcode-biweekly-contest-21-1370-1373/</url>
    <content><![CDATA[<p>LeetCode 双周赛专题每双周随缘更新，点击类别 <a href="/categories/LeetCode-Biweekly-Contest/">LeetCode Biweekly Contest</a> 查看更多。</p>
<span id="more"></span>

<h2 id="1370-Increasing-Decreasing-String-Easy"><a href="#1370-Increasing-Decreasing-String-Easy" class="headerlink" title="1370. Increasing Decreasing String #Easy"></a><a href="https://leetcode.com/contest/biweekly-contest-21/problems/increasing-decreasing-string/">1370. Increasing Decreasing String</a> #Easy</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，使用 <code>map&lt;char, int&gt; um</code> 记录每个字符出现的次数。</p>
<p>其次，因为 <code>map</code> 在插入过程中自动排序，所以从头到尾遍历可以得到字符的升序序列，同样从尾到头遍历可以得到字符的降序序列，不断循环上述步骤，直到用完所有字符即可。</p>
<h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">sortString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; um;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) ++um[c];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> iter = um.<span class="built_in">begin</span>(); iter != um.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">                <span class="keyword">if</span> (iter-&gt;second &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res += iter-&gt;first;</span><br><span class="line">                    --iter-&gt;second;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> iter = um.<span class="built_in">rbegin</span>(); iter != um.<span class="built_in">rend</span>(); ++iter) &#123;</span><br><span class="line">                <span class="keyword">if</span> (iter-&gt;second &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res += iter-&gt;first;</span><br><span class="line">                    --iter-&gt;second;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1371-Find-the-Longest-Substring-Containing-Vowels-in-Even-Counts-Medium"><a href="#1371-Find-the-Longest-Substring-Containing-Vowels-in-Even-Counts-Medium" class="headerlink" title="1371. Find the Longest Substring Containing Vowels in Even Counts #Medium"></a><a href="https://leetcode.com/contest/biweekly-contest-21/problems/find-the-longest-substring-containing-vowels-in-even-counts/">1371. Find the Longest Substring Containing Vowels in Even Counts</a> #Medium</h2><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，使用掩码 <code>mask</code>，其中的五位分别对应五个字符，位为 <code>0</code> 代表该字符出现次数为偶数，位为 <code>1</code> 代表该字符出现次数为奇数。那么，掩码 <code>mask</code> 可能出现的情况共有 <code>32</code> 种，使用 <code>iarr</code> 记录每种情况第一次出现的位置。</p>
<p>其次，遍历字符串 <code>s</code>，将掩码 <code>mask</code> 与每个字符对应的编码进行异或运算，计算当前的位置与该掩码第一次出现的位置之间子串的长度，比较最大值即可。</p>
<div class="note info"><p>需要明白的是，如果 <code>i</code> 和 <code>j</code> 两个位置具有相同的掩码 <code>mask</code>，那么 <code>[i + 1, j]</code> 之间的子串必然是满足题意的。</p>
</div>

<h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTheLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        array&lt;<span class="keyword">char</span>, 26&gt; carr;</span><br><span class="line">        <span class="built_in">fill</span>(<span class="built_in">begin</span>(carr), <span class="built_in">end</span>(carr), <span class="number">0</span>);</span><br><span class="line">        carr[<span class="string">&#x27;a&#x27;</span>-<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>; carr[<span class="string">&#x27;e&#x27;</span>-<span class="string">&#x27;a&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">        carr[<span class="string">&#x27;i&#x27;</span>-<span class="string">&#x27;a&#x27;</span>] = <span class="number">4</span>; carr[<span class="string">&#x27;o&#x27;</span>-<span class="string">&#x27;a&#x27;</span>] = <span class="number">8</span>;</span><br><span class="line">        carr[<span class="string">&#x27;u&#x27;</span>-<span class="string">&#x27;a&#x27;</span>] = <span class="number">16</span>;</span><br><span class="line">        array&lt;<span class="keyword">int</span>, 32&gt; iarr;</span><br><span class="line">        <span class="built_in">fill</span>(<span class="built_in">begin</span>(iarr), <span class="built_in">end</span>(iarr), <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            mask ^= carr[s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (mask != <span class="number">0</span> &amp;&amp; iarr[mask] == <span class="number">-1</span>) &#123;</span><br><span class="line">                iarr[mask] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i-iarr[mask]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1372-Longest-ZigZag-Path-in-a-Binary-Tree-Medium"><a href="#1372-Longest-ZigZag-Path-in-a-Binary-Tree-Medium" class="headerlink" title="1372. Longest ZigZag Path in a Binary Tree #Medium"></a><a href="https://leetcode.com/contest/biweekly-contest-21/problems/longest-zigzag-path-in-a-binary-tree/">1372. Longest ZigZag Path in a Binary Tree</a> #Medium</h2><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>递归遍历树，使用 <code>is_left</code> 标记是否为左节点。</p>
<div class="note info"><p>需要注意的是，如果当前节点为其父节点的左节点，那么可以在之前深度 <code>depth</code> 的基础上遍历其右节点，也可以从 <code>0</code> 开始遍历其左节点。右节点亦然。</p>
</div>

<h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestZigZag</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">helper1</span>(root, <span class="literal">false</span>, <span class="number">0</span>, res);</span><br><span class="line">        <span class="built_in">helper1</span>(root, <span class="literal">true</span>, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper1</span><span class="params">(TreeNode *node, <span class="keyword">bool</span> is_left, <span class="keyword">int</span> depth, <span class="keyword">int</span> &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        res = <span class="built_in">max</span>(res, depth);</span><br><span class="line">        <span class="keyword">if</span> (is_left) &#123;</span><br><span class="line">            <span class="built_in">helper1</span>(node-&gt;right, <span class="literal">false</span>, depth+<span class="number">1</span>, res);</span><br><span class="line">            <span class="built_in">helper1</span>(node-&gt;left, <span class="literal">false</span>, <span class="number">0</span>, res);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">helper1</span>(node-&gt;left, <span class="literal">true</span>, depth+<span class="number">1</span>, res);</span><br><span class="line">            <span class="built_in">helper1</span>(node-&gt;right, <span class="literal">true</span>, <span class="number">0</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1373-Maximum-Sum-BST-in-Binary-Tree-Hard"><a href="#1373-Maximum-Sum-BST-in-Binary-Tree-Hard" class="headerlink" title="1373. Maximum Sum BST in Binary Tree #Hard"></a><a href="https://leetcode.com/contest/biweekly-contest-21/problems/maximum-sum-bst-in-binary-tree/">1373. Maximum Sum BST in Binary Tree</a> #Hard</h2><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>递归遍历树，使用 <code>array&lt;int, 3&gt;</code> 记录子树的和、最小值和最大值。</p>
<p>如果左子树的最大值小于当前节点的值，而且右子树的最小值大于当前节点的值，那么说明以当前节点为根节点的树为 BST，传递该树的和、最小值和最大值，否则传递 <code>&#123;0, INT_MIN, INT_MAX&#125;</code>。</p>
<h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">helper1</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    array&lt;int, 3&gt; helper1(TreeNode *node, int &amp;res) &#123;</span><br><span class="line">        <span class="keyword">auto</span> l = node-&gt;left ? <span class="built_in">helper1</span>(node-&gt;left, res)</span><br><span class="line">                            : array&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt;&#123;<span class="number">0</span>, node-&gt;val, INT_MIN&#125;;</span><br><span class="line">        <span class="keyword">auto</span> r = node-&gt;right ? <span class="built_in">helper1</span>(node-&gt;right, res)</span><br><span class="line">                             : array&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt;&#123;<span class="number">0</span>, INT_MAX, node-&gt;val&#125;;</span><br><span class="line">        <span class="keyword">if</span> (l[<span class="number">2</span>] &lt; node-&gt;val &amp;&amp; node-&gt;val &lt; r[<span class="number">1</span>]) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, node-&gt;val+l[<span class="number">0</span>]+r[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> &#123;node-&gt;val+l[<span class="number">0</span>]+r[<span class="number">0</span>], l[<span class="number">1</span>], r[<span class="number">2</span>]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>, INT_MIN, INT_MAX&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B3 - LeetCode Biweekly Contest</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Data Structure and Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake 教程：从零开始编写 CMakeLists.txt</title>
    <url>/posts/cmake-tutorial-write-cmakelists-txt-from-the-very-beginning/</url>
    <content><![CDATA[<p>CMake 是跨平台的开源工具，可以用于编译、测试和打包软件，本文从零开始编写一个比较基础的 <code>CMakeLists.txt</code>，记录其特有的语法。</p>
<span id="more"></span>

<p>CMake 官网：<a href="https://cmake.org/">https://cmake.org/</a></p>
<p>CMake 源码地址（镜像）：<a href="https://github.com/Kitware/CMake">https://github.com/Kitware/CMake</a></p>
<p>CMake 英文教程（最新版本）：<a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">https://cmake.org/cmake/help/latest/guide/tutorial/index.html</a></p>
<p>CMake 文档搜索（最新版本）：<a href="https://cmake.org/cmake/help/latest/search.html">https://cmake.org/cmake/help/latest/search.html</a></p>
<div class="note warning"><p>本文使用 Ubuntu 当前版本为 <code>16.04</code>，使用 CMake 当前版本为 <code>3.17.20200315-ga6d95f5</code>，<code>CMakeLists.txt</code> 设置 CMake 最低版本为 <code>3.5</code>。因而，命令和语法可能与读者所用版本有所不同，望周知。</p>
</div>

<h2 id="0-教程源码"><a href="#0-教程源码" class="headerlink" title="0 教程源码"></a>0 教程源码</h2><p>GitHub 地址：<a href="https://github.com/ProgCZ/code-cloud-a/tree/master/2020/03/cmake-tutorial">https://github.com/ProgCZ/code-cloud-a/tree/master/2020/03/cmake-tutorial</a></p>
<p>读者可以下载整个仓库，进入指定目录查看源码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --depth=1 https://github.com/ProgCZ/code-cloud-a.git</span><br><span class="line">$ <span class="built_in">cd</span> code-cloud-a/2020/03/cmake-tutorial</span><br></pre></td></tr></table></figure>

<h2 id="1-创建基础模板"><a href="#1-创建基础模板" class="headerlink" title="1 创建基础模板"></a>1 创建基础模板</h2><p><strong>根目录中的 <code>CMakeLists.txt</code> 文件一览：</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the project name and version</span></span><br><span class="line"><span class="keyword">project</span>(Tutorial VERSION <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify the C++ standard</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># configure a header file to pass some of the CMake settings</span></span><br><span class="line"><span class="comment"># to the source code</span></span><br><span class="line"><span class="keyword">configure_file</span>(TutorialConfig.h.in TutorialConfig.h)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the binary tree to the search path for include files</span></span><br><span class="line"><span class="comment"># so that we will find TutorialConfig.h</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(Tutorial PUBLIC</span><br><span class="line">                           <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="1-1-设置-CMake-最低版本"><a href="#1-1-设置-CMake-最低版本" class="headerlink" title="1.1 设置 CMake 最低版本"></a>1.1 设置 CMake 最低版本</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION &lt;min&gt;[...&lt;max&gt;] [FATAL_ERROR])</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：<a href="https://cmake.org/cmake/help/latest/command/cmake_minimum_required.html">https://cmake.org/cmake/help/latest/command/cmake_minimum_required.html</a></p>
</blockquote>
<h3 id="1-2-设置项目名称和版本"><a href="#1-2-设置项目名称和版本" class="headerlink" title="1.2 设置项目名称和版本"></a>1.2 设置项目名称和版本</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">project</span>(&lt;<span class="keyword">PROJECT</span>-NAME&gt; [&lt;language-name&gt;...])</span><br><span class="line"><span class="keyword">project</span>(&lt;<span class="keyword">PROJECT</span>-NAME&gt;</span><br><span class="line">        [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]</span><br><span class="line">        [DESCRIPTION &lt;<span class="keyword">project</span>-description-<span class="keyword">string</span>&gt;]</span><br><span class="line">        [HOMEPAGE_URL &lt;url-<span class="keyword">string</span>&gt;]</span><br><span class="line">        [LANGUAGES &lt;language-name&gt;...])</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">project</span>(Tutorial VERSION <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述指令设置变量：</p>
<ul>
<li><p><code>PROJECT_NAME</code></p>
</li>
<li><p><code>PROJECT_SOURCE_DIR</code> 和 <code>&lt;PROJECT-NAME&gt;_SOURCE_DIR</code></p>
</li>
<li><p><code>PROJECT_BINARY_DIR</code> 和 <code>&lt;PROJECT-NAME&gt;_BINARY_DIR</code></p>
</li>
</ul>
</li>
<li><p>选项 <code>VERSION</code> 设置变量：</p>
<ul>
<li><p><code>PROJECT_VERSION</code> 和 <code>&lt;PROJECT-NAME&gt;_VERSION</code></p>
</li>
<li><p><code>PROJECT_VERSION_MAJOR</code> 和 <code>&lt;PROJECT-NAME&gt;_VERSION_MAJOR</code></p>
</li>
<li><p><code>PROJECT_VERSION_MINOR</code> 和 <code>&lt;PROJECT-NAME&gt;_VERSION_MINOR</code></p>
</li>
<li><p><code>PROJECT_VERSION_PATCH</code> 和 <code>&lt;PROJECT-NAME&gt;_VERSION_PATCH</code></p>
</li>
<li><p><code>PROJECT_VERSION_TWEAK</code> 和 <code>&lt;PROJECT-NAME&gt;_VERSION_TWEAK</code></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：<a href="https://cmake.org/cmake/help/latest/command/project.html">https://cmake.org/cmake/help/latest/command/project.html</a></p>
</blockquote>
<h3 id="1-3-设置-C-标准"><a href="#1-3-设置-C-标准" class="headerlink" title="1.3 设置 C++ 标准"></a>1.3 设置 C++ 标准</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure>

<h3 id="1-4-传递-CMake-变量"><a href="#1-4-传递-CMake-变量" class="headerlink" title="1.4 传递 CMake 变量"></a>1.4 传递 CMake 变量</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">configure_file</span>(&lt;input&gt; &lt;output&gt;</span><br><span class="line">               [COPYONLY] [ESCAPE_QUOTES] [@ONLY]</span><br><span class="line">               [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ])</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">configure_file</span>(TutorialConfig.h.in TutorialConfig.h)</span><br></pre></td></tr></table></figure>

<p>可以将头文件模板 <code>TutorialConfig.h.in</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TutorialConfig.h.in</span></span><br><span class="line"><span class="comment">// the configured options and settings for Tutorial</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@</span></span><br></pre></td></tr></table></figure>

<p>在预处理阶段改写为头文件 <code>TutorialConfig.h</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TutorialConfig.h</span></span><br><span class="line"><span class="comment">// the configured options and settings for Tutorial</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tutorial_VERSION_MAJOR 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tutorial_VERSION_MINOR 0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：<a href="https://cmake.org/cmake/help/latest/command/configure_file.html">https://cmake.org/cmake/help/latest/command/configure_file.html</a></p>
</blockquote>
<h3 id="1-5-添加可执行文件"><a href="#1-5-添加可执行文件" class="headerlink" title="1.5 添加可执行文件"></a>1.5 添加可执行文件</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">add_executable</span>(&lt;name&gt; [WIN32] [MACOSX_BUNDLE]</span><br><span class="line">               [EXCLUDE_FROM_ALL]</span><br><span class="line">               [source1] [source2 ...])</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial main.cpp)</span><br></pre></td></tr></table></figure>

<p>上述指令从源代码 <code>main.cpp</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TutorialConfig.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; Version: &quot;</span></span><br><span class="line">            &lt;&lt; Tutorial_VERSION_MAJOR &lt;&lt; <span class="string">&quot;.&quot;</span></span><br><span class="line">            &lt;&lt; Tutorial_VERSION_MINOR &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>]</span><br><span class="line">            &lt;&lt; <span class="string">&quot; number&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> inputValue = std::<span class="built_in">stod</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> outputValue = <span class="built_in">sqrt</span>(inputValue);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The square root of &quot;</span> &lt;&lt; inputValue</span><br><span class="line">        &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; outputValue &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译产生可执行文件 <code>Tutorial</code>。</p>
<blockquote>
<p>参考：<a href="https://cmake.org/cmake/help/latest/command/add_executable.html">https://cmake.org/cmake/help/latest/command/add_executable.html</a></p>
</blockquote>
<h3 id="1-6-添加-include-目录"><a href="#1-6-添加-include-目录" class="headerlink" title="1.6 添加 include 目录"></a>1.6 添加 <code>include</code> 目录</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(&lt;<span class="keyword">target</span>&gt; [SYSTEM] [BEFORE]</span><br><span class="line">    &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">    [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(Tutorial PUBLIC</span><br><span class="line">                           <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>上述指令添加 <code>include</code> 目录，使编译器能够找到头文件 <code>TutorialConfig.h</code>。</p>
<blockquote>
<p>参考：<a href="https://cmake.org/cmake/help/latest/command/target_include_directories.html">https://cmake.org/cmake/help/latest/command/target_include_directories.html</a></p>
</blockquote>
<h3 id="1-7-编译项目"><a href="#1-7-编译项目" class="headerlink" title="1.7 编译项目"></a>1.7 编译项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">$ cmake .. &amp;&amp; cmake --build .</span><br><span class="line">-- The C compiler identification is GNU 5.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 5.4.0</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc - works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - <span class="keyword">done</span></span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++ - works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - <span class="keyword">done</span></span><br><span class="line">-- Configuring <span class="keyword">done</span></span><br><span class="line">-- Generating <span class="keyword">done</span></span><br><span class="line">-- Build files have been written to: /home/peter/Projects/test_cmake_ws/build</span><br><span class="line">Scanning dependencies of target Tutorial</span><br><span class="line">[ 50%] Building CXX object CMakeFiles/Tutorial.dir/main.cpp.o</span><br><span class="line">[100%] Linking CXX executable Tutorial</span><br><span class="line">[100%] Built target Tutorial</span><br></pre></td></tr></table></figure>

<h3 id="1-8-运行项目"><a href="#1-8-运行项目" class="headerlink" title="1.8 运行项目"></a>1.8 运行项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./Tutorial 10</span><br><span class="line">The square root of 10 is 3.16228</span><br><span class="line">$ ./Tutorial</span><br><span class="line">./Tutorial Version: 1.0</span><br><span class="line">Usage: ./Tutorial number</span><br></pre></td></tr></table></figure>

<h2 id="2-加入自定义库"><a href="#2-加入自定义库" class="headerlink" title="2 加入自定义库"></a>2 加入自定义库</h2><p>某些情况下，需要添加一个自定义库，比如 <code>MathFunctions</code> 库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── main.cpp</span><br><span class="line">├── MathFunctions</span><br><span class="line">│   ├── MathFunctions.h</span><br><span class="line">│   └── mysqrt.cpp</span><br></pre></td></tr></table></figure>

<hr>
<p><strong><code>MathFunctions</code> 目录中的 <code>CMakeLists.txt</code> 文件一览：</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(MathFunctions mysqrt.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># state that anybody linking to us needs to include the current source dir</span></span><br><span class="line"><span class="comment"># to find MathFunctions.h, while we don&#x27;t.</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(MathFunctions</span><br><span class="line">    INTERFACE <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-1-为库的用户添加库"><a href="#2-1-为库的用户添加库" class="headerlink" title="2.1 为库的用户添加库"></a>2.1 为库的用户添加库</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">add_library</span>(&lt;name&gt; [STATIC | SHARED | MODULE]</span><br><span class="line">            [EXCLUDE_FROM_ALL]</span><br><span class="line">            [source1] [source2 ...])</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">add_library</span>(MathFunctions mysqrt.cpp)</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://cmake.org/cmake/help/latest/command/add_library.html">https://cmake.org/cmake/help/latest/command/add_library.html</a></p>
<h3 id="2-2-为库的用户添加-include-目录"><a href="#2-2-为库的用户添加-include-目录" class="headerlink" title="2.2 为库的用户添加 include 目录"></a>2.2 为库的用户添加 <code>include</code> 目录</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(MathFunctions</span><br><span class="line">    INTERFACE <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>上述指令<strong>为库的用户</strong>添加 <code>include</code> 目录，使编译器能够找到头文件 <code>MathFunctions.h</code>。</p>
<hr>
<p><strong>根目录中的<code>CMakeLists.txt</code> 文件一览：</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the project name and version</span></span><br><span class="line"><span class="keyword">project</span>(Tutorial VERSION <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify the C++ standard</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># should we use our own math functions</span></span><br><span class="line"><span class="keyword">option</span>(USE_MYMATH <span class="string">&quot;Use tutorial provided math implementation&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># configure a header file to pass some of the CMake settings</span></span><br><span class="line"><span class="comment"># to the source code</span></span><br><span class="line"><span class="keyword">configure_file</span>(TutorialConfig.h.in TutorialConfig.h)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the MathFunctions library</span></span><br><span class="line"><span class="keyword">if</span>(USE_MYMATH)</span><br><span class="line">    <span class="keyword">add_subdirectory</span>(MathFunctions)</span><br><span class="line">    <span class="keyword">list</span>(APPEND EXTRA_LIBS MathFunctions)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Tutorial PUBLIC <span class="variable">$&#123;EXTRA_LIBS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the binary tree to the search path for include files</span></span><br><span class="line"><span class="comment"># so that we will find TutorialConfig.h</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(Tutorial PUBLIC</span><br><span class="line">                           <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-传递-USE-MYMATH-选项"><a href="#2-3-传递-USE-MYMATH-选项" class="headerlink" title="2.3 传递 USE_MYMATH 选项"></a>2.3 传递 <code>USE_MYMATH</code> 选项</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">option</span>(&lt;variable&gt; <span class="string">&quot;&lt;help_text&gt;&quot;</span> [value])</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">option</span>(USE_MYMATH <span class="string">&quot;Use tutorial provided math implementation&quot;</span> <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure>

<p>修改头文件模板 <code>TutorialConfig.h.in</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the configured options and settings for Tutorial</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@</span></span><br><span class="line"><span class="meta">#cmakedefine USE_MYMATH</span></span><br></pre></td></tr></table></figure>

<p>根据 <code>USE_MYMATH</code> 选项判断使用哪个函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MathFunctions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">double</span> outputValue = <span class="built_in">mysqrt</span>(inputValue);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">double</span> outputValue = <span class="built_in">sqrt</span>(inputValue);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The square root of &quot;</span> &lt;&lt; inputValue</span><br><span class="line">        &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; outputValue &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-添加-MathFunctions-目录"><a href="#2-4-添加-MathFunctions-目录" class="headerlink" title="2.4 添加 MathFunctions 目录"></a>2.4 添加 <code>MathFunctions</code> 目录</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(MathFunctions)</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://cmake.org/cmake/help/latest/command/add_subdirectory.html">https://cmake.org/cmake/help/latest/command/add_subdirectory.html</a></p>
<h3 id="2-5-添加链接库"><a href="#2-5-添加链接库" class="headerlink" title="2.5 添加链接库"></a>2.5 添加链接库</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">list</span>(APPEND &lt;<span class="keyword">list</span>&gt; [&lt;element&gt;...])</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">list</span>(APPEND EXTRA_LIBS MathFunctions)</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://cmake.org/cmake/help/latest/command/list.html">https://cmake.org/cmake/help/latest/command/list.html</a></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(&lt;<span class="keyword">target</span>&gt;</span><br><span class="line">                      &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...</span><br><span class="line">                      [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Tutorial PUBLIC <span class="variable">$&#123;EXTRA_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://cmake.org/cmake/help/latest/command/target_link_libraries.html">https://cmake.org/cmake/help/latest/command/target_link_libraries.html</a></p>
<h3 id="2-6-编译项目"><a href="#2-6-编译项目" class="headerlink" title="2.6 编译项目"></a>2.6 编译项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake -DUSE_MYMATH=ON .. &amp;&amp; cmake --build .</span><br><span class="line">$ cmake -DUSE_MYMATH=OFF .. &amp;&amp; cmake --build .</span><br></pre></td></tr></table></figure>

<h2 id="3-安装和测试"><a href="#3-安装和测试" class="headerlink" title="3 安装和测试"></a>3 安装和测试</h2><h3 id="3-1-设置安装目录"><a href="#3-1-设置安装目录" class="headerlink" title="3.1 设置安装目录"></a>3.1 设置安装目录</h3><p><strong>在 <code>MathFunctions</code> 目录中的 <code>CMakeLists.txt</code> 文件最后添加：</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS MathFunctions DESTINATION lib)</span><br><span class="line"><span class="keyword">install</span>(FILES MathFunctions.h DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>

<p><strong>在根目录中的 <code>CMakeLists.txt</code> 文件最后添加：</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS Tutorial DESTINATION bin)</span><br><span class="line"><span class="keyword">install</span>(FILES <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/TutorialConfig.h&quot;</span></span><br><span class="line">    DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-安装项目"><a href="#3-2-安装项目" class="headerlink" title="3.2 安装项目"></a>3.2 安装项目</h3><p>CMake 的 <code>3.15</code> 以下版本只能使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure>

<p>CMake 的 <code>3.15</code> 及以上版本可以使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ sudo cmake --install .</span><br></pre></td></tr></table></figure>

<p>上述指令默认将项目安装在 <code>/usr/local/</code> 路径下，可以指定安装路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo cmake --install . --prefix /tmp/</span><br></pre></td></tr></table></figure>

<p>安装之后就可以直接调用 <code>Tutorial</code>，而不是 <code>./Tutorial</code>。</p>
<h3 id="3-3-设置测试样例"><a href="#3-3-设置测试样例" class="headerlink" title="3.3 设置测试样例"></a>3.3 设置测试样例</h3><p><strong>在根目录中的 <code>CMakeLists.txt</code> 文件最后添加：</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># does the application run</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME Runs <span class="keyword">COMMAND</span> Tutorial <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># does the usage message work?</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME Usage <span class="keyword">COMMAND</span> Tutorial)</span><br><span class="line"><span class="keyword">set_tests_properties</span>(Usage</span><br><span class="line">    PROPERTIES PASS_REGULAR_EXPRESSION <span class="string">&quot;Usage:.*number&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># define a function to simplify adding tests</span></span><br><span class="line"><span class="keyword">function</span>(do_test <span class="keyword">target</span> arg result)</span><br><span class="line">    <span class="keyword">add_test</span>(NAME Comp<span class="variable">$&#123;arg&#125;</span> <span class="keyword">COMMAND</span> <span class="variable">$&#123;target&#125;</span> <span class="variable">$&#123;arg&#125;</span>)</span><br><span class="line">    <span class="keyword">set_tests_properties</span>(Comp<span class="variable">$&#123;arg&#125;</span></span><br><span class="line">        PROPERTIES PASS_REGULAR_EXPRESSION <span class="variable">$&#123;result&#125;</span>)</span><br><span class="line"><span class="keyword">endfunction</span>(do_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># do a bunch of result based tests</span></span><br><span class="line">do_test(Tutorial <span class="number">5</span> <span class="string">&quot;5 is 2.236&quot;</span>)</span><br><span class="line">do_test(Tutorial -<span class="number">25</span> <span class="string">&quot;-25 is [-nan|nan|0]&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-3-1-简单测试"><a href="#3-3-1-简单测试" class="headerlink" title="3.3.1 简单测试"></a>3.3.1 简单测试</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME &lt;name&gt; <span class="keyword">COMMAND</span> &lt;<span class="keyword">command</span>&gt; [&lt;arg&gt;...]</span><br><span class="line">         [CONFIGURATIONS &lt;config&gt;...]</span><br><span class="line">         [WORKING_DIRECTORY &lt;dir&gt;]</span><br><span class="line">         [COMMAND_EXPAND_LISTS])</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME Runs <span class="keyword">COMMAND</span> Tutorial <span class="number">25</span>)</span><br></pre></td></tr></table></figure>

<p>上述指令简单测试项目是否能够运行，通过则表示未报错、未崩溃、返回 <code>0</code>。</p>
<blockquote>
<p>参考：<a href="https://cmake.org/cmake/help/latest/command/add_test.html">https://cmake.org/cmake/help/latest/command/add_test.html</a></p>
</blockquote>
<h4 id="3-3-2-对比测试"><a href="#3-3-2-对比测试" class="headerlink" title="3.3.2 对比测试"></a>3.3.2 对比测试</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME &lt;name&gt; <span class="keyword">COMMAND</span> &lt;<span class="keyword">command</span>&gt; [&lt;arg&gt;...]</span><br><span class="line">         [CONFIGURATIONS &lt;config&gt;...]</span><br><span class="line">         [WORKING_DIRECTORY &lt;dir&gt;]</span><br><span class="line">         [COMMAND_EXPAND_LISTS])</span><br><span class="line"><span class="keyword">set_tests_properties</span>(test1 [test2...] PROPERTIES prop1 value1 prop2 value2)</span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME Usage <span class="keyword">COMMAND</span> Tutorial)</span><br><span class="line"><span class="keyword">set_tests_properties</span>(Usage</span><br><span class="line">    PROPERTIES PASS_REGULAR_EXPRESSION <span class="string">&quot;Usage:.*number&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>上述指令对比测试项目的输出与正则表达式是否匹配，可以将其封装为函数：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">function</span>(do_test <span class="keyword">target</span> arg result)</span><br><span class="line">    <span class="keyword">add_test</span>(NAME Comp<span class="variable">$&#123;arg&#125;</span> <span class="keyword">COMMAND</span> <span class="variable">$&#123;target&#125;</span> <span class="variable">$&#123;arg&#125;</span>)</span><br><span class="line">    <span class="keyword">set_tests_properties</span>(Comp<span class="variable">$&#123;arg&#125;</span></span><br><span class="line">        PROPERTIES PASS_REGULAR_EXPRESSION <span class="variable">$&#123;result&#125;</span>)</span><br><span class="line"><span class="keyword">endfunction</span>(do_test)</span><br></pre></td></tr></table></figure>

<h3 id="3-4-测试项目"><a href="#3-4-测试项目" class="headerlink" title="3.4 测试项目"></a>3.4 测试项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ ctest -VV</span><br><span class="line">UpdateCTestConfiguration  from :/home/peter/Projects/test_cmake_ws/build/DartConfiguration.tcl</span><br><span class="line">UpdateCTestConfiguration  from :/home/peter/Projects/test_cmake_ws/build/DartConfiguration.tcl</span><br><span class="line">Test project /home/peter/Projects/test_cmake_ws/build</span><br><span class="line">Constructing a list of tests</span><br><span class="line">Done constructing a list of tests</span><br><span class="line">Updating <span class="built_in">test</span> list <span class="keyword">for</span> fixtures</span><br><span class="line">Added 0 tests to meet fixture requirements</span><br><span class="line">Checking <span class="built_in">test</span> dependency graph...</span><br><span class="line">Checking <span class="built_in">test</span> dependency graph end</span><br><span class="line"><span class="built_in">test</span> 1</span><br><span class="line">    Start 1: Runs</span><br><span class="line"></span><br><span class="line">1: Test <span class="built_in">command</span>: /home/peter/Projects/test_cmake_ws/build/Tutorial <span class="string">&quot;25&quot;</span></span><br><span class="line">1: Test timeout computed to be: 10000000</span><br><span class="line">1: The square root of 25 is 5</span><br><span class="line">1/4 Test <span class="comment">#1: Runs .............................   Passed    0.03 sec</span></span><br><span class="line"><span class="built_in">test</span> 2</span><br><span class="line">    Start 2: Usage</span><br><span class="line"></span><br><span class="line">2: Test <span class="built_in">command</span>: /home/peter/Projects/test_cmake_ws/build/Tutorial</span><br><span class="line">2: Test timeout computed to be: 10000000</span><br><span class="line">2: /home/peter/Projects/test_cmake_ws/build/Tutorial Version: 1.0</span><br><span class="line">2: Usage: /home/peter/Projects/test_cmake_ws/build/Tutorial number</span><br><span class="line">2/4 Test <span class="comment">#2: Usage ............................   Passed    0.00 sec</span></span><br><span class="line"><span class="built_in">test</span> 3</span><br><span class="line">    Start 3: Comp5</span><br><span class="line"></span><br><span class="line">3: Test <span class="built_in">command</span>: /home/peter/Projects/test_cmake_ws/build/Tutorial <span class="string">&quot;5&quot;</span></span><br><span class="line">3: Test timeout computed to be: 10000000</span><br><span class="line">3: The square root of 5 is 2.23607</span><br><span class="line">3/4 Test <span class="comment">#3: Comp5 ............................   Passed    0.00 sec</span></span><br><span class="line"><span class="built_in">test</span> 4</span><br><span class="line">    Start 4: Comp-25</span><br><span class="line"></span><br><span class="line">4: Test <span class="built_in">command</span>: /home/peter/Projects/test_cmake_ws/build/Tutorial <span class="string">&quot;-25&quot;</span></span><br><span class="line">4: Test timeout computed to be: 10000000</span><br><span class="line">4: The square root of -25 is -nan</span><br><span class="line">4/4 Test <span class="comment">#4: Comp-25 ..........................   Passed    0.01 sec</span></span><br><span class="line"></span><br><span class="line">100% tests passed, 0 tests failed out of 4</span><br><span class="line"></span><br><span class="line">Total Test time (real) =   0.12 sec</span><br></pre></td></tr></table></figure>

<h2 id="4-写在最后"><a href="#4-写在最后" class="headerlink" title="4 写在最后"></a>4 写在最后</h2><p>未来一段时间可能会找一些优秀的 C++ 项目源码来阅读，学习编码技巧的同时也能进一步了解如何编写项目的 <code>CMakeLists.txt</code>。</p>
]]></content>
      <categories>
        <category>A2 - 学习笔记</category>
        <category>B2 - 编程语言</category>
        <category>C1 - CPP</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Linux</tag>
        <tag>CMake</tag>
        <tag>CMakeLists.txt</tag>
        <tag>Tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Weekly Contest 181 (1389 - 1392)</title>
    <url>/posts/leetcode-weekly-contest-181-1389-1392/</url>
    <content><![CDATA[<p>LeetCode 周赛专题每周随缘更新，点击类别 <a href="/categories/LeetCode-Weekly-Contest/">LeetCode Weekly Contest</a> 查看更多。</p>
<span id="more"></span>

<h2 id="1389-Create-Target-Array-in-the-Given-Order-Easy"><a href="#1389-Create-Target-Array-in-the-Given-Order-Easy" class="headerlink" title="1389. Create Target Array in the Given Order #Easy"></a><a href="https://leetcode.com/contest/weekly-contest-181/problems/create-target-array-in-the-given-order/">1389. Create Target Array in the Given Order</a> #Easy</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>不追求效率的话，直接使用标准库方法，在 <code>vector</code> 的对应下标插入对应元素即可。</p>
<h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">createTargetArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>()+index[i], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1390-Four-Divisors-Medium"><a href="#1390-Four-Divisors-Medium" class="headerlink" title="1390. Four Divisors #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-181/problems/four-divisors/">1390. Four Divisors</a> #Medium</h2><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>寻找 <code>nums</code> 中每个数字的第一个因数，一旦出现第二个因数，则停止寻找并不计入结果。</p>
<p>如果找到的第一个因数刚好是数字的算术平方根，则也不计入结果。</p>
<h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumFourDivisors</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> fac = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= num; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fac == <span class="number">0</span>) &#123;</span><br><span class="line">                        fac = i;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        fac = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fac != <span class="number">0</span> &amp;&amp; fac * fac != num) &#123;</span><br><span class="line">                res += <span class="number">1</span> + fac + num/fac + num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1391-Check-if-There-is-a-Valid-Path-in-a-Grid-Medium"><a href="#1391-Check-if-There-is-a-Valid-Path-in-a-Grid-Medium" class="headerlink" title="1391. Check if There is a Valid Path in a Grid #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-181/problems/check-if-there-is-a-valid-path-in-a-grid/">1391. Check if There is a Valid Path in a Grid</a> #Medium</h2><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>深度优先搜索。</p>
<p>P.S. 搜索的时候用了暴力枚举，感觉可以用个固定的 <code>set</code> 来遍历判断，更优雅一点。</p>
<h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasValidPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper1</span>(grid, visited, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper1</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid,</span></span></span><br><span class="line"><span class="function"><span class="params">                 vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; &amp;visited,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || visited[i][j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == m - <span class="number">1</span> &amp;&amp; j == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> b = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ((grid[i][j] == <span class="number">2</span> || grid[i][j] == <span class="number">5</span> || grid[i][j] == <span class="number">6</span>) &amp;&amp; (i<span class="number">-1</span> &gt;= <span class="number">0</span>) &amp;&amp;</span><br><span class="line">            (grid[i<span class="number">-1</span>][j] == <span class="number">2</span> || grid[i<span class="number">-1</span>][j] == <span class="number">3</span> || grid[i<span class="number">-1</span>][j] == <span class="number">4</span>)) &#123;</span><br><span class="line">            b = b || <span class="built_in">helper1</span>(grid, visited, i<span class="number">-1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((grid[i][j] == <span class="number">2</span> || grid[i][j] == <span class="number">3</span> || grid[i][j] == <span class="number">4</span>) &amp;&amp; (i+<span class="number">1</span> &lt; m) &amp;&amp;</span><br><span class="line">            (grid[i+<span class="number">1</span>][j] == <span class="number">2</span> || grid[i+<span class="number">1</span>][j] == <span class="number">5</span> || grid[i+<span class="number">1</span>][j] == <span class="number">6</span>)) &#123;</span><br><span class="line">            b = b || <span class="built_in">helper1</span>(grid, visited, i+<span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((grid[i][j] == <span class="number">1</span> || grid[i][j] == <span class="number">3</span> || grid[i][j] == <span class="number">5</span>) &amp;&amp; (j<span class="number">-1</span> &gt;= <span class="number">0</span>) &amp;&amp;</span><br><span class="line">            (grid[i][j<span class="number">-1</span>] == <span class="number">1</span> || grid[i][j<span class="number">-1</span>] == <span class="number">4</span> || grid[i][j<span class="number">-1</span>] == <span class="number">6</span>)) &#123;</span><br><span class="line">            b = b || <span class="built_in">helper1</span>(grid, visited, i, j<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((grid[i][j] == <span class="number">1</span> || grid[i][j] == <span class="number">4</span> || grid[i][j] == <span class="number">6</span>) &amp;&amp; (j+<span class="number">1</span> &lt; n) &amp;&amp;</span><br><span class="line">            (grid[i][j+<span class="number">1</span>] == <span class="number">1</span> || grid[i][j+<span class="number">1</span>] == <span class="number">3</span> || grid[i][j+<span class="number">1</span>] == <span class="number">5</span>)) &#123;</span><br><span class="line">            b = b || <span class="built_in">helper1</span>(grid, visited, i, j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1392-Longest-Happy-Prefix-Hard"><a href="#1392-Longest-Happy-Prefix-Hard" class="headerlink" title="1392. Longest Happy Prefix #Hard"></a><a href="https://leetcode.com/contest/weekly-contest-181/problems/longest-happy-prefix/">1392. Longest Happy Prefix</a> #Hard</h2><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>分别从头和尾遍历字符串的前缀和后缀，把遍历到的字符串看作是二十六进制的数字，将其转化为十进制的长整型，判断前缀和后缀是否相等，相等则记录当前下标。</p>
<div class="note warning"><p>需要注意的是，因为转化过程中可能产生较大的数字，所以应该对 <code>1e9+7</code> 取余。</p>
</div>

<h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPrefix</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> h1 = <span class="number">0</span>, h2 = <span class="number">0</span>, mul = <span class="number">1</span>, len = <span class="number">0</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>()<span class="number">-1</span>; j &gt; <span class="number">0</span>; ++i, --j) &#123;</span><br><span class="line">            <span class="keyword">int</span> first = s[i] - <span class="string">&#x27;a&#x27;</span>, last = s[j] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            h1 = (h1 * <span class="number">26</span> + first) % mod;</span><br><span class="line">            h2 = (h2 + last * mul) % mod;</span><br><span class="line">            mul = mul * <span class="number">26</span> % mod;</span><br><span class="line">            <span class="keyword">if</span> (h1 == h2) len = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(<span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B2 - LeetCode Weekly Contest</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Data Structure and Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Biweekly Contest 22 (1385 - 1388)</title>
    <url>/posts/leetcode-biweekly-contest-22-1385-1388/</url>
    <content><![CDATA[<p>LeetCode 双周赛专题每双周随缘更新，点击类别 <a href="/categories/LeetCode-Biweekly-Contest/">LeetCode Biweekly Contest</a> 查看更多。</p>
<span id="more"></span>

<h2 id="1385-Find-the-Distance-Value-Between-Two-Arrays-Easy"><a href="#1385-Find-the-Distance-Value-Between-Two-Arrays-Easy" class="headerlink" title="1385. Find the Distance Value Between Two Arrays #Easy"></a><a href="https://leetcode.com/contest/biweekly-contest-22/problems/find-the-distance-value-between-two-arrays/">1385. Find the Distance Value Between Two Arrays</a> #Easy</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>没啥好说的，暴力遍历判断即可。</p>
<h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTheDistanceValue</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr1, vector&lt;<span class="keyword">int</span>&gt;&amp; arr2, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = arr1.<span class="built_in">size</span>(), n2 = arr2.<span class="built_in">size</span>(), cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; ++i) &#123;</span><br><span class="line">            <span class="keyword">bool</span> b = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n2; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(arr1[i]-arr2[j]) &lt;= d) &#123;</span><br><span class="line">                    b = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b) ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1386-Cinema-Seat-Allocation-Medium"><a href="#1386-Cinema-Seat-Allocation-Medium" class="headerlink" title="1386. Cinema Seat Allocation #Medium"></a><a href="https://leetcode.com/contest/biweekly-contest-22/problems/cinema-seat-allocation/">1386. Cinema Seat Allocation</a> #Medium</h2><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，假定每行都是空的，那么就可以有 <code>n*2</code> 个四连座。</p>
<p>其次，将每一行被占座位记录到 <code>um</code> 中。</p>
<p>然后，判断每一行被占座位的区间：</p>
<ul>
<li><p>如果在 <code>[2, 5]</code> 中，那么说明左侧不存在四连座，标记 <code>le</code>。</p>
</li>
<li><p>如果在 <code>[6, 9]</code> 中，那么说明右侧不存在四连座，标记 <code>ri</code>。</p>
</li>
<li><p>如果在 <code>[4, 7]</code> 中，那么说明中间不存在四连座，标记 <code>mi</code>。</p>
</li>
</ul>
<p>最后，如果左侧和右侧都不存在四连座，则 <code>res</code> 累减，但是如果此时中间存在四连座，则 <code>res</code> 累加。</p>
<h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNumberOfFamilies</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; reservedSeats)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; um;</span><br><span class="line">        <span class="keyword">int</span> res = n * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ivec : reservedSeats) &#123;</span><br><span class="line">            um[ivec[<span class="number">0</span>]].<span class="built_in">push_back</span>(ivec[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : um) &#123;</span><br><span class="line">            <span class="keyword">int</span> le = <span class="literal">false</span>, ri = <span class="literal">false</span>, mi = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : p.second) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &lt; i &amp;&amp; i &lt; <span class="number">6</span>) le = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">5</span> &lt; i &amp;&amp; i &lt; <span class="number">10</span>) ri = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">3</span> &lt; i &amp;&amp; i &lt; <span class="number">8</span>) mi = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (le) --res;</span><br><span class="line">            <span class="keyword">if</span> (ri) --res;</span><br><span class="line">            <span class="keyword">if</span> (le &amp;&amp; ri &amp;&amp; !mi) ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1387-Sort-Integers-by-The-Power-Value-Medium"><a href="#1387-Sort-Integers-by-The-Power-Value-Medium" class="headerlink" title="1387. Sort Integers by The Power Value #Medium"></a><a href="https://leetcode.com/contest/biweekly-contest-22/problems/sort-integers-by-the-power-value">1387. Sort Integers by The Power Value</a> #Medium</h2><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>重点在于需要重写排序规则：根据数字的能量值从小到大进行排序，如果能量值相等，则根据数字本身从小到大进行排序。</p>
<p>而在计算能量值的过程中，显然有大量的重复运算，则采用动态规划思想，将计算过的能量值存入 <code>um</code> 中，如果后续的数字存在于 <code>um</code> 中，则直接返回其对应的结果，避免重复运算。</p>
<h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; um;</span><br><span class="line">        um[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; ++i) &#123;</span><br><span class="line">            ivec.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>(), [&amp;um, <span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">helper1</span>(um, a) &lt; <span class="built_in">helper1</span>(um, b) ||</span><br><span class="line">                (<span class="built_in">helper1</span>(um, a) == <span class="built_in">helper1</span>(um, b) &amp;&amp; a &lt; b);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ivec[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper1</span><span class="params">(unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;um, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (um.<span class="built_in">find</span>(num) != um.<span class="built_in">end</span>()) <span class="keyword">return</span> um[num];</span><br><span class="line">        <span class="keyword">if</span> (num &amp; <span class="number">0x01</span>) um[num] = <span class="built_in">helper1</span>(um, num*<span class="number">3</span>+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> um[num] = <span class="built_in">helper1</span>(um, num/<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> um[num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1388-Pizza-With-3n-Slices-Hard"><a href="#1388-Pizza-With-3n-Slices-Hard" class="headerlink" title="1388. Pizza With 3n Slices #Hard"></a><a href="https://leetcode.com/contest/biweekly-contest-22/problems/pizza-with-3n-slices/">1388. Pizza With 3n Slices</a> #Hard</h2><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><blockquote>
<p>参考：<a href="https://leetcode.com/problems/pizza-with-3n-slices/discuss/546442/PythonC%2B%2B-O(n)-space-Easy-DP-with-explanation">[Python/C++] O(n) space, Easy DP with explanation</a></p>
</blockquote>
<p>说实话，看了半天都没看懂大神的解法，单纯放一下代码吧。</p>
<h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSizeSlices</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; slices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">helper1</span>(slices, <span class="number">0</span>), <span class="built_in">helper1</span>(slices, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; slices, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = slices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">2</span>, vector&lt;<span class="keyword">int</span>&gt;(n/<span class="number">3</span>+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n/<span class="number">3</span>; ++j) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-2</span>][j<span class="number">-1</span>]+slices[i<span class="number">-2</span>+start]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][n/<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B3 - LeetCode Biweekly Contest</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Data Structure and Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Weekly Contest 182 (1394 - 1397)</title>
    <url>/posts/leetcode-weekly-contest-182-1394-1397/</url>
    <content><![CDATA[<p>LeetCode 周赛专题每周随缘更新，点击类别 <a href="/categories/LeetCode-Weekly-Contest/">LeetCode Weekly Contest</a> 查看更多。</p>
<span id="more"></span>

<h2 id="1394-Find-Lucky-Integer-in-an-Array-Easy"><a href="#1394-Find-Lucky-Integer-in-an-Array-Easy" class="headerlink" title="1394. Find Lucky Integer in an Array #Easy"></a><a href="https://leetcode.com/contest/weekly-contest-182/problems/find-lucky-integer-in-an-array/">1394. Find Lucky Integer in an Array</a> #Easy</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，遍历 <code>arr</code>，使用 <code>m</code> 记录每个数字出现的次数，因为 <code>map</code> 的有序特性，所以数字自然从小到大进行排序。</p>
<p>其次，逆向遍历 <code>m</code>，寻找数字与其出现次数相等的情况，直接返回即可。</p>
<h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLucky</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;i : arr) ++m[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = m.<span class="built_in">crbegin</span>(); iter != m.<span class="built_in">crend</span>(); ++iter) &#123;</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;first == iter-&gt;second) <span class="keyword">return</span> iter-&gt;first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1395-Count-Number-of-Teams-Medium"><a href="#1395-Count-Number-of-Teams-Medium" class="headerlink" title="1395. Count Number of Teams #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-182/problems/count-number-of-teams/">1395. Count Number of Teams</a> #Medium</h2><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，遍历 <code>rating</code>，使用 <code>cnt</code> 记录每个数字之后比它大的数字个数 <code>cnt[i][0]</code> 和比它小的数字个数 <code>cnt[i][1]</code>。</p>
<p>其次，遍历 <code>rating</code>，<code>rating[i]</code> 作为队伍的第一个数字，<code>rating[j]</code> 作为队伍的第二个数字：</p>
<ul>
<li><p>如果前者比后者小，则说明为升序序列，<code>res</code> 累加 <code>rating[j]</code> 之后比它大的数字个数。</p>
</li>
<li><p>如果前者比后者大，则说明为降序序列，<code>res</code> 累加 <code>rating[j]</code> 之后比它小的数字个数。</p>
</li>
</ul>
<h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTeams</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; rating)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = rating.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">cnt</span>(n, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rating[i] &lt; rating[j]) ++cnt[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rating[i] &gt; rating[j]) ++cnt[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rating[i] &lt; rating[j]) res += cnt[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rating[i] &gt; rating[j]) res += cnt[j][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1396-Design-Underground-System-Medium"><a href="#1396-Design-Underground-System-Medium" class="headerlink" title="1396. Design Underground System #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-182/problems/design-underground-system/">1396. Design Underground System</a> #Medium</h2><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>没啥好说的，理清题目逻辑之后用 <code>unordered_map</code> 来记录信息即可。</p>
<h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndergroundSystem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UndergroundSystem</span>() &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkIn</span><span class="params">(<span class="keyword">int</span> id, string stationName, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        um2[id] = &#123;stationName, t&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkOut</span><span class="params">(<span class="keyword">int</span> id, string stationName, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        um1[um2[id].first+stationName].first += <span class="number">1</span>;</span><br><span class="line">        um1[um2[id].first+stationName].second += t - um2[id].second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getAverageTime</span><span class="params">(string startStation, string endStation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> um1[startStation+endStation].second /</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(um1[startStation+endStation].first);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string, pair&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; um1;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, pair&lt;string, <span class="keyword">int</span>&gt;&gt; um2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your UndergroundSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * UndergroundSystem* obj = new UndergroundSystem();</span></span><br><span class="line"><span class="comment"> * obj-&gt;checkIn(id,stationName,t);</span></span><br><span class="line"><span class="comment"> * obj-&gt;checkOut(id,stationName,t);</span></span><br><span class="line"><span class="comment"> * double param_3 = obj-&gt;getAverageTime(startStation,endStation);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="1397-Find-All-Good-Strings-Hard"><a href="#1397-Find-All-Good-Strings-Hard" class="headerlink" title="1397. Find All Good Strings #Hard"></a><a href="https://leetcode.com/contest/weekly-contest-182/problems/find-all-good-strings/">1397. Find All Good Strings</a> #Hard</h2><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><blockquote>
<p>参考：<a href="https://leetcode.com/problems/find-all-good-strings/discuss/555591/JavaC%2B%2B-Memoization-DFS-and-KMP-with-Picture-Clean-code">[Java/C++] Memoization DFS &amp; KMP - with Picture - Clean code</a></p>
</blockquote>
<p>说实话，我觉得这不是我目前能够理解的解法（涉及 KMP 算法），单纯放一下代码吧。</p>
<h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findGoodStrings</span><span class="params">(<span class="keyword">int</span> n, string s1, string s2, string evil)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt;&gt; memo = <span class="built_in">vector</span>(n+<span class="number">1</span>, <span class="built_in">vector</span>(evil.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="built_in">vector</span>(<span class="number">2</span>, <span class="built_in">vector</span>(<span class="number">2</span>, <span class="number">-1</span>)))); </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">true</span>,</span><br><span class="line">            n, s1, s2, evil, <span class="built_in">computeLPS</span>(evil), memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> matchEvilLen, <span class="keyword">bool</span> useBoundS1, <span class="keyword">bool</span> useBoundS2,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> n, string&amp; s1, string&amp; s2, string&amp; evil, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; lps, vector&lt;vector&lt;vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matchEvilLen == evil.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][matchEvilLen][useBoundS1][useBoundS2] != <span class="number">-1</span>) <span class="keyword">return</span> memo[i][matchEvilLen][useBoundS1][useBoundS2];</span><br><span class="line">        <span class="keyword">char</span> from = useBoundS1 ? s1[i] : <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">char</span> to = useBoundS2 ? s2[i] : <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c = from; c &lt;= to; c++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = matchEvilLen;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; evil[j] != c) j = lps[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (c == evil[j]) j++;</span><br><span class="line">            res += <span class="built_in">dfs</span>(i + <span class="number">1</span>, j, useBoundS1 &amp;&amp; (c == from), useBoundS2 &amp;&amp; (c == to),</span><br><span class="line">                    n, s1, s2, evil, lps, memo);</span><br><span class="line">            res %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][matchEvilLen][useBoundS1][useBoundS2] = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">computeLPS</span><span class="params">(<span class="keyword">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; lps = vector&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str[i] != str[j]) j = lps[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (str[i] == str[j]) lps[i] = ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B2 - LeetCode Weekly Contest</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Data Structure and Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Biweekly Contest 23 (1399 - 1402)</title>
    <url>/posts/leetcode-biweekly-contest-23-1399-1402/</url>
    <content><![CDATA[<p>LeetCode 双周赛专题每双周随缘更新，点击类别 <a href="/categories/LeetCode-Biweekly-Contest/">LeetCode Biweekly Contest</a> 查看更多。</p>
<span id="more"></span>

<h2 id="1399-Count-Largest-Group-Easy"><a href="#1399-Count-Largest-Group-Easy" class="headerlink" title="1399. Count Largest Group #Easy"></a><a href="https://leetcode.com/contest/biweekly-contest-23/problems/count-largest-group/">1399. Count Largest Group</a> #Easy</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>根据给出的数据范围 <code>1 &lt;= n &lt;= 10^4</code>，可以判断数字的每位之和一定不超过 <code>36</code>，所以可以用 <code>arr</code> 记录每种情况出现的次数，排序后找出并列最多的次数有多少即可。</p>
<h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countLargestGroup</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        array&lt;<span class="keyword">int</span>, 37&gt; arr = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = i, sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (t) &#123;</span><br><span class="line">                sum += t % <span class="number">10</span>;</span><br><span class="line">                t /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++arr[sum];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">rbegin</span>(), arr.<span class="built_in">rend</span>());</span><br><span class="line">        <span class="keyword">int</span> m = arr[<span class="number">0</span>], idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt; <span class="number">37</span> &amp;&amp; arr[idx] == m) &#123;</span><br><span class="line">            ++idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1400-Construct-K-Palindrome-Strings-Medium"><a href="#1400-Construct-K-Palindrome-Strings-Medium" class="headerlink" title="1400. Construct K Palindrome Strings #Medium"></a><a href="https://leetcode.com/contest/biweekly-contest-23/problems/construct-k-palindrome-strings/">1400. Construct K Palindrome Strings</a> #Medium</h2><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>其实，只有两种情况不能将 <code>s</code> 拆分为 <code>k</code> 个回文子串：</p>
<ul>
<li><p><code>s</code> 中字符不足 <code>k</code> 个。</p>
<p>显而易见，不需要多加说明。</p>
</li>
<li><p><code>s</code> 中出现次数为奇数的字符超过 <code>k</code> 个。</p>
<p>出现次数为奇数的字符如果出现在回文子串中，那么必然出现在最中间的位置，所以这样的字符有多少个，拆分的子串也至少有多少个。</p>
</li>
</ul>
<h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(string s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        array&lt;<span class="keyword">int</span>, 26&gt; arr = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : s) ++arr[ch-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">0x1</span>) ++odd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> odd &lt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1401-Circle-and-Rectangle-Overlapping-Medium"><a href="#1401-Circle-and-Rectangle-Overlapping-Medium" class="headerlink" title="1401. Circle and Rectangle Overlapping #Medium"></a><a href="https://leetcode.com/contest/biweekly-contest-23/problems/circle-and-rectangle-overlapping/">1401. Circle and Rectangle Overlapping</a> #Medium</h2><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，判断圆心是否在矩形内，是则必然重叠。</p>
<p>其次，遍历矩形四条边上的点，判断其与圆心的距离是否小于半径，是则必然重叠。</p>
<h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkOverlap</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x_center, <span class="keyword">int</span> y_center, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x_center &gt;= x1 &amp;&amp; x_center &lt;= x2 &amp;&amp; y_center &gt;= y1 &amp;&amp; y_center &lt;= y2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = x1; x &lt;= x2; ++x) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> dx = (x - x_center) * (x - x_center);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> dy1 = (y1 - y_center) * (y1 - y_center);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> dy2 = (y2 - y_center) * (y2 - y_center);</span><br><span class="line">            <span class="keyword">if</span> (dx + dy1 &lt;= radius * radius || dx + dy2 &lt;= radius * radius) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = y1; y &lt;= y2; ++y) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> dx1 = (x1 - x_center) * (x1 - x_center);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> dx2 = (x2 - x_center) * (x2 - x_center);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> dy = (y - y_center) * (y - y_center);</span><br><span class="line">            <span class="keyword">if</span> (dx1 + dy &lt;= radius * radius || dx2 + dy &lt;= radius * radius) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1402-Reducing-Dishes-Hard"><a href="#1402-Reducing-Dishes-Hard" class="headerlink" title="1402. Reducing Dishes #Hard"></a><a href="https://leetcode.com/contest/biweekly-contest-23/problems/reducing-dishes/">1402. Reducing Dishes</a> #Hard</h2><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，将 <code>satisfaction</code> 从大到小进行排序，优先处理满意度高的菜品。</p>
<p>其次，声明 <code>res</code> 用于表示总体满意度，声明 <code>total</code> 用于表示累加满意度，也就是随着时间增加，之前处理菜品的满意度不断增长的部分。</p>
<p>然后，如果某个菜品的满意度为负，不一定需要放弃这个菜品，因为之前处理菜品增长的满意度可能可以覆盖这个菜品的满意度，从而使得总体满意度还是增长的，所以需要满足某个菜品的满意度将累加满意度拖累为负，那么就需要放弃这个菜品。</p>
<h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSatisfaction</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; satisfaction)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(satisfaction.<span class="built_in">rbegin</span>(), satisfaction.<span class="built_in">rend</span>());</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; satisfaction.<span class="built_in">size</span>() &amp;&amp; satisfaction[i] &gt; -total; ++i) &#123;</span><br><span class="line">            total += satisfaction[i];</span><br><span class="line">            res += total;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B3 - LeetCode Biweekly Contest</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Data Structure and Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Weekly Contest 183 (1403 - 1406)</title>
    <url>/posts/leetcode-weekly-contest-183-1403-1406/</url>
    <content><![CDATA[<p>LeetCode 周赛专题每周随缘更新，点击类别 <a href="/categories/LeetCode-Weekly-Contest/">LeetCode Weekly Contest</a> 查看更多。</p>
<span id="more"></span>

<h2 id="1403-Minimum-Subsequence-in-Non-Increasing-Order-Easy"><a href="#1403-Minimum-Subsequence-in-Non-Increasing-Order-Easy" class="headerlink" title="1403. Minimum Subsequence in Non-Increasing Order #Easy"></a><a href="https://leetcode.com/contest/weekly-contest-183/problems/minimum-subsequence-in-non-increasing-order/">1403. Minimum Subsequence in Non-Increasing Order</a> #Easy</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>将 <code>nums</code> 从大到小进行排序，遍历求和直到 <code>sum</code> 达到总和 <code>total</code> 的一半即可。</p>
<h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">minSubsequence</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">rbegin</span>(), nums.<span class="built_in">rend</span>());</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) total += num;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() &amp;&amp; sum &lt; total/<span class="number">2</span>+<span class="number">1</span>; ++i) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1404-Number-of-Steps-to-Reduce-a-Number-in-Binary-Representation-to-One-Medium"><a href="#1404-Number-of-Steps-to-Reduce-a-Number-in-Binary-Representation-to-One-Medium" class="headerlink" title="1404. Number of Steps to Reduce a Number in Binary Representation to One #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-183/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/">1404. Number of Steps to Reduce a Number in Binary Representation to One</a> #Medium</h2><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>不断弹出字符串的末尾字符：</p>
<ul>
<li><p>如果末尾字符为 <code>&#39;0&#39;</code>，则原数直接除 <code>2</code>，<code>res</code> 累加 <code>1</code>。</p>
</li>
<li><p>如果末尾字符为 <code>&#39;1&#39;</code>，则原数需要加 <code>1</code> 后除 <code>2</code>，<code>res</code> 累加 <code>2</code>。</p>
<p>关于如何实现进位：向前遍历其紧邻的所有 <code>&#39;1&#39;</code>，修改为 <code>&#39;0&#39;</code>；遍历结束后判断下标是否在字符串内，是则说明遍历到了 <code>&#39;0&#39;</code>，修改为 <code>&#39;1&#39;</code>，否则说明遍历到了字符串开头，添加上 <code>&#39;1&#39;</code>。</p>
</li>
</ul>
<h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSteps</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="string">&quot;1&quot;</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> j = i<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; s[j] == <span class="string">&#x27;1&#x27;</span>; --j) &#123;</span><br><span class="line">                    s[j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    s[j] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s = <span class="string">&#x27;1&#x27;</span> + s;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1405-Longest-Happy-String-Medium"><a href="#1405-Longest-Happy-String-Medium" class="headerlink" title="1405. Longest Happy String #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-183/problems/longest-happy-string/">1405. Longest Happy String</a> #Medium</h2><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，使用最小堆 <code>pq</code> 对三个字符的剩余个数进行排序。</p>
<p>其次，迭代取出堆顶即剩余个数最多的字符，判断当前 <code>res</code> 的末尾字符与其是否相同，是则说明该字符为上次迭代过程中的「间隔字符」，为了不出现 <code>3</code> 个重复的字符，<code>res</code> 累加 <code>1</code> 个该字符，否则 <code>res</code> 累加 <code>2</code> 个该字符。</p>
<div class="note warning"><p>需要注意的是，如果此时 <code>pq</code> 为空，说明没有字符能够作为「间隔字符」了，跳出循环即可。</p>
</div>

<p>然后，迭代取出堆顶即剩余个数次多的字符，将其作为「间隔字符」累加至 <code>res</code> 的末尾。</p>
<p>最后，如果字符还有剩余，则将其重新添加至 <code>pq</code> 即可。</p>
<h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestDiverseString</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">if</span> (a) pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(a, <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">        <span class="keyword">if</span> (b) pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(b, <span class="string">&#x27;b&#x27;</span>));</span><br><span class="line">        <span class="keyword">if</span> (c) pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(c, <span class="string">&#x27;c&#x27;</span>));</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = pq.<span class="built_in">top</span>().first;</span><br><span class="line">            <span class="keyword">char</span> mc = pq.<span class="built_in">top</span>().second;</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> add = (!res.<span class="built_in">empty</span>() &amp;&amp; res.<span class="built_in">back</span>() == mc) ? <span class="number">1</span> : <span class="built_in">min</span>(<span class="number">2</span>, mi);</span><br><span class="line">            res += <span class="built_in">string</span>(add, mc);</span><br><span class="line">            mi -= add;</span><br><span class="line">            <span class="keyword">if</span> (pq.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> smi = pq.<span class="built_in">top</span>().first;</span><br><span class="line">            <span class="keyword">char</span> smc = pq.<span class="built_in">top</span>().second;</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            res += smc;</span><br><span class="line">            smi -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (mi) pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(mi, mc));</span><br><span class="line">            <span class="keyword">if</span> (smi) pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(smi, smc));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1406-Stone-Game-III-Hard"><a href="#1406-Stone-Game-III-Hard" class="headerlink" title="1406. Stone Game III #Hard"></a><a href="https://leetcode.com/contest/weekly-contest-183/problems/stone-game-iii/">1406. Stone Game III</a> #Hard</h2><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><blockquote>
<p>参考：<a href="https://leetcode.com/problems/stone-game-iii/discuss/564260/JavaC%2B%2BPython-DP-O(1)-Space">[Java/C++/Python] DP, O(1) Space</a></p>
</blockquote>
<p>不想班门弄斧，直接看大佬的解法吧。</p>
<h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">stoneGameIII</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; stoneValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stoneValue.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, INT_MIN)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, take = <span class="number">0</span>; j &lt; <span class="number">3</span> &amp;&amp; i + j &lt; n; ++j) &#123;</span><br><span class="line">                take += stoneValue[i + j];</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], take - (i + j + <span class="number">1</span> &lt; n ? dp[i + j + <span class="number">1</span>] : <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">0</span>] &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">0</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Tie&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B2 - LeetCode Weekly Contest</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Data Structure and Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Weekly Contest 186 (1422 - 1425)</title>
    <url>/posts/leetcode-weekly-contest-186-1422-1425/</url>
    <content><![CDATA[<p>LeetCode 周赛专题每周随缘更新，点击类别 <a href="/categories/LeetCode-Weekly-Contest/">LeetCode Weekly Contest</a> 查看更多。</p>
<p>本次比赛通过 <code>3</code> 题，时间为 <code>1:03:11</code>，排名为 <code>1553/11684</code>。</p>
<span id="more"></span>

<h2 id="1422-Maximum-Score-After-Splitting-a-String-Easy"><a href="#1422-Maximum-Score-After-Splitting-a-String-Easy" class="headerlink" title="1422. Maximum Score After Splitting a String #Easy"></a><a href="https://leetcode.com/contest/weekly-contest-186/problems/maximum-score-after-splitting-a-string/">1422. Maximum Score After Splitting a String</a> #Easy</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p><code>cnt_zero</code> 和 <code>cnt_one</code> 分别用于统计左子串中 <code>0</code> 的个数和右子串中 <code>1</code> 的个数。</p>
<p>统计字符串 <code>s</code> 中共有多少个 <code>1</code> 之后，从左向右遍历的同时累加 <code>cnt_zero</code> 和 <code>cnt_one</code>，寻找遍历过程中两者和的最大值即可。</p>
<h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt_zero = <span class="number">0</span>, cnt_one = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;1&#x27;</span>) ++cnt_one;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>()<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) ++cnt_zero;</span><br><span class="line">            <span class="keyword">else</span> --cnt_one;</span><br><span class="line">            res = <span class="built_in">max</span>(res, cnt_zero+cnt_one);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1423-Maximum-Points-You-Can-Obtain-from-Cards-Medium"><a href="#1423-Maximum-Points-You-Can-Obtain-from-Cards-Medium" class="headerlink" title="1423. Maximum Points You Can Obtain from Cards #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-186/problems/maximum-points-you-can-obtain-from-cards/">1423. Maximum Points You Can Obtain from Cards</a> #Medium</h2><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>实际上就是从左抽取 <code>x</code> 张牌，从右抽取 <code>k-x</code> 张牌，遍历寻找和的最大值即可。</p>
<h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; cardPoints, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, n = cardPoints.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            sum += cardPoints[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = sum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            sum += cardPoints[n-i<span class="number">-1</span>] - cardPoints[k-i<span class="number">-1</span>];</span><br><span class="line">            res = <span class="built_in">max</span>(res, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1424-Diagonal-Traverse-II-Medium"><a href="#1424-Diagonal-Traverse-II-Medium" class="headerlink" title="1424. Diagonal Traverse II #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-186/problems/diagonal-traverse-ii/">1424. Diagonal Traverse II</a> #Medium</h2><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>P.S. 一开始还使用了遍历整个矩阵（包括空白区域）的方法，但是题目提醒行、列都可能是 <code>10^5</code> 的量级，<code>O(n^2)</code> 的时间复杂度必然超时，还好题目提醒 <code>nums</code> 中元素个数不可能超过 <code>10^5</code>，那么就可以放心地遍历整个矩阵（不包括空白区域）。</p>
<div class="note info"><p>需要明白的是，同一斜线上的元素，其行号与列号的和是不变的，而且行号较大的元素排在前面。</p>
</div>

<p>首先，使用 <code>vec</code> 存放 <code>nums</code> 中每个元素的行号、列号和值。</p>
<p>其次，将 <code>vec</code> 进行自定义规则的排序，使得行号与列号的和较小的元素排在前面（也就是不同斜线之间的排序），如果和相等，则使得行号较大的元素排在前面（也就是同一斜线内部的排序）。</p>
<p>最后，按序提取出元素的值即可。</p>
<h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;array&lt;<span class="keyword">int</span>, 3&gt;&gt; vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                vec.<span class="built_in">push_back</span>(&#123;i, j, nums[i][j]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123;</span><br><span class="line">            <span class="keyword">int</span> sa = a[<span class="number">0</span>] + a[<span class="number">1</span>], sb = b[<span class="number">0</span>] + b[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (sa != sb) <span class="keyword">return</span> sa &lt; sb;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> arr : vec) res.<span class="built_in">push_back</span>(arr[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1425-Constrained-Subset-Sum-Hard"><a href="#1425-Constrained-Subset-Sum-Hard" class="headerlink" title="1425. Constrained Subset Sum #Hard"></a><a href="https://leetcode.com/contest/weekly-contest-186/problems/constrained-subset-sum/">1425. Constrained Subset Sum</a> #Hard</h2><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://leetcode.com/problems/constrained-subset-sum/discuss/597751/JavaC%2B%2BPython-O(N)-Decreasing-Deque">[Java/C++/Python] O(N) Decreasing Deque</a></p>
<p>首先，维护一个非上升队列 <code>q</code>（即保证 <code>q</code> 的队首元素是 <code>q</code> 中最大的元素），其中每个元素表示 <code>nums</code> 中以当前位置为结尾的子数组按照题目要求所能达到的最大值。</p>
<p>其次，遍历 <code>nums</code>，累加队首元素，寻找遍历过程中的最大值。</p>
<p>然后，如果 <code>nums[i]</code> 大于 <code>0</code>，那么舍弃 <code>q</code> 的队尾中比 <code>nums[i]</code> 小的元素（这些元素不可能再参与到运算当中了），并将 <code>nums[i]</code> 添加至队尾。</p>
<p>最后，如果 <code>q</code> 的队首元素刚好是 <code>nums[i]</code> 往前数第 <code>k</code> 个元素，那么根据题目要求舍弃 <code>q</code> 的队首元素。</p>
<h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">constrainedSubsetSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            nums[i] += q.<span class="built_in">size</span>() ? q.<span class="built_in">front</span>() : <span class="number">0</span>;</span><br><span class="line">            res = <span class="built_in">max</span>(res, nums[i]);</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; nums[i] &gt; q.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                q.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) q.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k &amp;&amp; q.<span class="built_in">size</span>() &amp;&amp; q.<span class="built_in">front</span>() == nums[i-k]) &#123;</span><br><span class="line">                q.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B2 - LeetCode Weekly Contest</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Data Structure and Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 GitHub Actions 实现 Hexo 博客的自动部署</title>
    <url>/posts/apply-github-actions-to-deploy-hexo-blog/</url>
    <content><![CDATA[<p>GitHub Actions 是 GitHub 推出的持续集成服务，可以用于自动执行「代码测试」、「项目部署」等重复劳动，自然也可以用于 Hexo 等静态博客的生成、部署过程，从而不依赖于本地环境，便于迁移。</p>
<span id="more"></span>

<p>GitHub Actions 官方介绍：<a href="https://github.com/features/actions">https://github.com/features/actions</a></p>
<p>GitHub Actions 入门教程：<a href="https://p3terx.com/archives/github-actions-started-tutorial.html">https://p3terx.com/archives/github-actions-started-tutorial.html</a></p>
<h2 id="1-分支设计"><a href="#1-分支设计" class="headerlink" title="1 分支设计"></a>1 分支设计</h2><p><a href="https://github.com/ProgCZ/progcz.github.io">ProgCZ/progcz.github.io</a> 包含两个分支：</p>
<ul>
<li><p><code>master</code> 分支：用于存放<strong>解析后的静态文件</strong>，也就是托管于 GitHub Pages 的静态网页，无需在本地保存。</p>
</li>
<li><p><code>source</code> 分支：用于存放<strong>解析前的源文件</strong>，需要与本地同步。</p>
</li>
</ul>
<p>也就是说，我们希望达成的效果如下：<strong>在本地撰写文章后，将其手动提交至 <code>source</code> 分支，从而触发 GitHub Actions 生成静态文件，将其自动部署至 <code>master</code> 分支。</strong></p>
<h2 id="2-工作流设计"><a href="#2-工作流设计" class="headerlink" title="2 工作流设计"></a>2 工作流设计</h2><h3 id="2-1-详细描述"><a href="#2-1-详细描述" class="headerlink" title="2.1 详细描述"></a>2.1 详细描述</h3><ol>
<li><strong>工作流由 <code>source</code> 分支的 <code>push</code> 操作触发。</strong></li>
</ol>
  <div class="note warning"><p>之前我把工作流文件放在 <code>master</code> 分支下，希望通过</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">source</span></span><br></pre></td></tr></table></figure>

<p>来触发工作流，但是一直没能成功，所以这里建议将工作流文件放在 <code>source</code> 分支下。</p>
</div>

<ol start="2">
<li><p><strong>配置工作流环境（与本地保持一致）：系统为 Ubuntu 16.04，Node.js 版本为 12.x。</strong></p>
</li>
<li><p><strong>下拉 <code>source</code> 分支至 <code>blog-source-ws</code> 文件夹中。</strong></p>
</li>
<li><p><strong>安装 <code>hexo-cli</code> 工具，版本为 3.1.0（与本地保持一致）。</strong></p>
</li>
<li><p><strong>安装插件，依赖文件为 <code>blog-source-ws/package.json</code>。</strong></p>
</li>
</ol>
  <div class="note warning"><p>为了使插件保持稳定，我把所有版本号前的 <code>^</code> 全部删除，因为 <code>^</code> 表示将插件更新到当前 major version（也就是第一位数字）中的最新版本。</p>
<p>完整依赖文件如下所示：</p>
<figure class="highlight json"><figcaption><span>code</span><a href="https://github.com/ProgCZ/progcz.github.io/blob/source/package.json">package.json</a></figcaption><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;hexo-site&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;private&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;hexo generate&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;clean&quot;</span>: <span class="string">&quot;hexo clean&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;deploy&quot;</span>: <span class="string">&quot;hexo deploy&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;server&quot;</span>: <span class="string">&quot;hexo server&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hexo&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;4.2.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hexo&quot;</span>: <span class="string">&quot;4.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-generator-archive&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-generator-category&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-generator-index&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-generator-feed&quot;</span>: <span class="string">&quot;2.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-generator-sitemap&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-generator-searchdb&quot;</span>: <span class="string">&quot;1.3.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-generator-tag&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-html-minifier&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-renderer-ejs&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-renderer-stylus&quot;</span>: <span class="string">&quot;1.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-renderer-marked&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-server&quot;</span>: <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细心的读者可能看到，除了默认插件以外，我额外添加了四个插件，分别是：</p>
<ul>
<li><p><code>hexo-generator-feed</code> 用于生成 RSS 文件。</p>
</li>
<li><p><code>hexo-generator-sitemap</code> 用于生成站点地图文件，提交给 Google 之后可以提高网页收录效率。</p>
</li>
<li><p><code>hexo-generator-searchdb</code> 用于生成搜索文件。</p>
</li>
<li><p><code>hexo-html-minifier</code> 用于压缩 html 文件（删除大量空白和换行），可以加快网页加载速度。</p>
</li>
</ul>
</div>

<ol start="6">
<li><p><strong>下拉 <code>master</code> 分支至 <code>blog-source-ws/pubic</code> 文件夹中。</strong></p>
</li>
<li><p><strong>配置时区和用户信息后，通过</strong></p>
</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -a | egrep -v <span class="string">&#x27;^\.&#123;1,2&#125;$&#x27;</span> | egrep -v .git | xargs rm -rf</span><br></pre></td></tr></table></figure>

<p>  <strong>清空 <code>blog-source-ws/pubic</code> 文件夹（相当于 <code>hexo clean</code>），再通过</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<p>  <strong>在 <code>blog-source-ws/pubic</code> 文件夹中生成静态文件，再通过</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add -A</span><br><span class="line">$ git commit -m <span class="string">&quot;Update blog: `date &#x27;+%Y-%m-%d %H:%M:%S&#x27;`&quot;</span></span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<p>  <strong>将静态文件手动提交至 <code>master</code> 分支。</strong></p>
<h3 id="2-2-完整代码"><a href="#2-2-完整代码" class="headerlink" title="2.2 完整代码"></a>2.2 完整代码</h3><figure class="highlight yaml"><figcaption><span>code</span><a href="https://github.com/ProgCZ/progcz.github.io/blob/source/.github/workflows/auto-hexo.yml">auto-hexo.yml</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Auto</span> <span class="string">Hexo</span></span><br><span class="line"><span class="attr">on:</span> <span class="string">push</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">Worker:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-16.04</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&#x27;12.x&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">ref:</span> <span class="string">source</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&#x27;blog-source-ws&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Hexo</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli@3.1.0</span></span><br><span class="line">        <span class="string">cd</span> <span class="string">blog-source-ws</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">ref:</span> <span class="string">master</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&#x27;blog-source-ws/public&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Regenerate</span> <span class="string">and</span> <span class="string">Deploy</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">export</span> <span class="string">TZ=&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">        <span class="string">cd</span> <span class="string">blog-source-ws/public</span></span><br><span class="line">        <span class="string">ls</span> <span class="string">-a</span> <span class="string">|</span> <span class="string">egrep</span> <span class="string">-v</span> <span class="string">&#x27;^\.&#123;1,2&#125;$&#x27;</span> <span class="string">|</span> <span class="string">egrep</span> <span class="string">-v</span> <span class="string">.git</span> <span class="string">|</span> <span class="string">xargs</span> <span class="string">rm</span> <span class="string">-rf</span></span><br><span class="line">        <span class="string">cd</span> <span class="string">..</span></span><br><span class="line">        <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line">        <span class="string">cd</span> <span class="string">public</span></span><br><span class="line">        <span class="string">git</span> <span class="string">config</span> <span class="string">--local</span> <span class="string">user.name</span> <span class="string">&quot;ProgCZ&quot;</span></span><br><span class="line">        <span class="string">git</span> <span class="string">config</span> <span class="string">--local</span> <span class="string">user.email</span> <span class="string">&quot;zhaozengzhi1995@163.com&quot;</span></span><br><span class="line">        <span class="string">git</span> <span class="string">add</span> <span class="string">-A</span></span><br><span class="line">        <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">&quot;Update blog: `date &#x27;+%Y-%m-%d %H:%M:%S&#x27;`&quot;</span></span><br><span class="line">        <span class="string">git</span> <span class="string">push</span> <span class="string">origin</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>需要注意以下几点：</p>
<ul>
<li><p><strong><code>ls -a | egrep -v &#39;^\.&#123;1,2&#125;$&#39; | egrep -v .git | xargs rm -rf</code> 相当于 <code>hexo clean</code>，</strong>但是该命令只是删除 <code>blog-source-ws/public</code> 文件夹内除了以 <code>.git</code> 为前缀的文件或文件夹以外的所有文件或文件夹，而 <code>hexo clean</code> 直接删除 <code>blog-source-ws/public</code> 文件夹。</p>
</li>
<li><p>两个分支属于同一仓库，<strong>使用 <code>actions/checkout</code>（相当于 <code>git pull</code>）之后可以直接 <code>git push</code>，</strong>而不需要配置其他教程（比如<a href="https://mystryl.com/2019/10/github-actions/">这篇文章</a>）中出现的秘钥。</p>
</li>
</ul>
<h2 id="3-自动部署效果"><a href="#3-自动部署效果" class="headerlink" title="3 自动部署效果"></a>3 自动部署效果</h2><p>可以在<a href="https://github.com/ProgCZ/progcz.github.io/actions?query=branch:source">这里</a>看到，部署时间大概在 40 秒左右，随着文章数量不断增多，部署时间也会不断增加，但是总不可能超过 6 小时的限制（GitHub Actions 的使用限制可以在<a href="https://help.github.com/en/actions/getting-started-with-github-actions/about-github-actions#usage-limits">这里</a>查看）。</p>
<p>只要 GitHub 没有警告版本过期，上述方案就可以一直使用下去，即使 GitHub 警告版本过期，也可以尝试更改版本号，一般都会向下兼容，所以目测支撑个四五年应该没有问题。</p>
]]></content>
      <categories>
        <category>A1 - 生活随笔</category>
        <category>B2 - 折腾</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>GitHub</tag>
        <tag>Tutorial</tag>
        <tag>GitHub Actions</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 系统中 socket 编程的入门必知</title>
    <url>/posts/basics-about-socket-in-linux/</url>
    <content><![CDATA[<p>在计算机通信领域，socket 被译为「套接字」，是计算机之间进行通信的一种约定，本文介绍 socket 编程的入门必知，可以作为基础手册进行查阅。</p>
<span id="more"></span>

<blockquote>
<p>【迁移】旧文日期：2019-09-05</p>
</blockquote>
<h2 id="1-socket-编程基础"><a href="#1-socket-编程基础" class="headerlink" title="1 socket 编程基础"></a>1 socket 编程基础</h2><h3 id="1-1-socket-的不同类型"><a href="#1-1-socket-的不同类型" class="headerlink" title="1.1 socket 的不同类型"></a>1.1 socket 的不同类型</h3><ul>
<li><p><code>SOCK_STREAM</code>：流格式套接字，使用 TCP 协议进行数据传输。</p>
</li>
<li><p><code>SOCK_DGRAM</code>：数据报格式套接字，使用 UDP 协议进行数据传输。</p>
</li>
</ul>
<h3 id="1-2-socket-的不同函数"><a href="#1-2-socket-的不同函数" class="headerlink" title="1.2 socket 的不同函数"></a>1.2 socket 的不同函数</h3><h4 id="1-2-1-socket"><a href="#1-2-1-socket" class="headerlink" title="1.2.1 socket()"></a>1.2.1 <code>socket()</code></h4><p>用于创建套接字，确定套接字的各项属性：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>af</code> 为地址族，也就是IP地址类型，常用的有 <code>AF_INET</code> 和 <code>AF_INET6</code>，前者表示 IPv4 地址，后者表示 IPv6 地址。</p>
</li>
<li><p><code>type</code> 为数据传输方式，也就是套接字类型，常用的有 <code>SOCK_STREAM</code> 和 <code>SOCK_DGRAM</code>。</p>
</li>
<li><p><code>protocol</code> 为传输协议，常用的有 <code>IPPROTO_TCP</code> 和 <code>IPPTOTO_UDP</code>，前者表示 TCP 传输协议，后者表示 UDP 传输协议。</p>
</li>
</ul>
<h4 id="1-2-2-bind-和-connect"><a href="#1-2-2-bind-和-connect" class="headerlink" title="1.2.2 bind() 和 connect()"></a>1.2.2 <code>bind()</code> 和 <code>connect()</code></h4><p>服务端使用 <code>bind()</code> 将套接字和特定的 IP 地址、端口绑定起来：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sock, struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>客户端使用 <code>connect()</code> 将套接字和特定的 IP 地址、端口绑定起来：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sock, struct sockaddr *serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>sock</code> 为套接字文件描述符。</p>
</li>
<li><p><code>addr</code> 为 <code>sockaddr</code> 结构体变量的指针。</p>
</li>
<li><p><code>addrlen</code> 为 <code>addr</code> 变量的大小，可以由 <code>sizeof()</code> 计算得到。</p>
</li>
</ul>
<h4 id="1-2-3-listen-和-accept"><a href="#1-2-3-listen-和-accept" class="headerlink" title="1.2.3 listen() 和 accept()"></a>1.2.3 <code>listen()</code> 和 <code>accept()</code></h4><p>服务端使用 <code>listen()</code> 使套接字进入被动监听状态：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sock, inr backlog)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>sock</code> 为需要进入监听状态的套接字文件描述符。</p>
</li>
<li><p><code>backlog</code> 为请求队列的最大长度。其中，请求队列也就是请求的接收缓冲区，可以设置为 <code>SOMAXCONN</code>，由系统决定请求队列长度。当请求队列已满时，不再接收新的请求，客户端会收到 <code>ECONNREFUSED</code> 错误。</p>
</li>
</ul>
<p>之后调用 <code>accept()</code> 函数，使进程处于阻塞状态，直到接收到客户端的请求：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sock, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>accept()</code> 返回一个新的套接字用于和客户端通信。</p>
<h4 id="1-2-4-write-和-read"><a href="#1-2-4-write-和-read" class="headerlink" title="1.2.4 write() 和 read()"></a>1.2.4 <code>write()</code> 和 <code>read()</code></h4><p>服务端使用 <code>write()</code> 向套接字写入数据，传送给客户端：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>fd</code> 为需要写入的文件描述符，此处即套接字文件描述符。</p>
</li>
<li><p><code>buf</code> 为需要写入的数据的缓冲区地址。</p>
</li>
<li><p><code>nbytes</code> 为需要写入的数据的字节数。</p>
</li>
</ul>
<p>需要注意的是，写入成功则返回写入的字节数，失败则返回 <code>-1</code>。</p>
<p>客户端使用 <code>read()</code> 从套接字读入数据：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，读取成功则返回读取的字节数（在文件结尾返回 <code>0</code>），失败则返回 <code>-1</code>。</p>
<h2 id="2-socket-编程样例"><a href="#2-socket-编程样例" class="headerlink" title="2 socket 编程样例"></a>2 socket 编程样例</h2><h3 id="2-1-服务端代码-server-cpp"><a href="#2-1-服务端代码-server-cpp" class="headerlink" title="2.1 服务端代码 server.cpp"></a>2.1 服务端代码 <code>server.cpp</code></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> serv_sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将套接字与 IP、端口绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">    <span class="built_in">bind</span>(serv_sock, (struct sockaddr*)&amp;serv_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(serv_addr));</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 进入监听状态，等待用户发起请求</span></span><br><span class="line">    <span class="built_in">listen</span>(serv_sock, <span class="number">20</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 接收客户端请求</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_addr_size = <span class="built_in"><span class="keyword">sizeof</span></span>(clnt_addr);</span><br><span class="line">    <span class="keyword">int</span> clnt_sock = <span class="built_in">accept</span>(serv_sock, (struct sockaddr*)&amp;clnt_addr, &amp;clnt_addr_size);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 向客户端发送数据</span></span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(clnt_sock, str, <span class="built_in"><span class="keyword">sizeof</span></span>(str));</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-客户端代码-client-cpp"><a href="#2-2-客户端代码-client-cpp" class="headerlink" title="2.2 客户端代码 client.cpp"></a>2.2 客户端代码 <code>client.cpp</code></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 向服务端发送请求</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">    <span class="built_in">connect</span>(sock, (struct sockaddr*)&amp;serv_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(serv_addr));</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 读取服务端传回的数据</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">40</span>];</span><br><span class="line">    <span class="built_in">read</span>(sock, buffer, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer)<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Massage: %s\n&quot;</span>, buffer);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A2 - 学习笔记</category>
        <category>B3 - 开发基础</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Linux</tag>
        <tag>Network Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 May LeetCoding Challenge - Week 1</title>
    <url>/posts/2020-may-leetcoding-challenge-week-1/</url>
    <content><![CDATA[<p>LeetCode 五月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-May-LeetCoding-Challenge/">2020 May LeetCoding Challenge</a> 查看更多。</p>
<span id="more"></span>

<p>P.S. 四月挑战因为错过了开头，不想从半路开始，所以干脆没做，现在五月挑战出现了，希望自己能坚持做完。</p>
<h2 id="May-1st-First-Bad-Version"><a href="#May-1st-First-Bad-Version" class="headerlink" title="May 1st: First Bad Version"></a>May 1st: <a href="https://leetcode.com/explore/featured/card/may-leetcoding-challenge/534/week-1-may-1st-may-7th/3316/">First Bad Version</a></h2><p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p>
<p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p>
<p>You are given an API <code>bool isBadVersion(version)</code> which will return whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given n &#x3D; 5, and version &#x3D; 4 is the first bad version.</span><br><span class="line"></span><br><span class="line">call isBadVersion(3) -&gt; false</span><br><span class="line">call isBadVersion(5) -&gt; true</span><br><span class="line">call isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">Then 4 is the first bad version.</span><br></pre></td></tr></table></figure>

<h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>二分查找算法就可以解决，注意 <code>beg</code> 和 <code>end</code> 两个边界值应该如何变化即可。</p>
<div class="note info"><p>二分查找算法可以参考这篇文章：<a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/er-fen-cha-zhao-xiang-jie">二分查找详解</a>。</p>
</div>

<h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The API isBadVersion is defined for you.</span></span><br><span class="line"><span class="comment">// bool isBadVersion(int version);</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beg &gt;= end) <span class="keyword">return</span> beg;</span><br><span class="line">        <span class="keyword">int</span> mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isBadVersion</span>(mid)) end = mid;</span><br><span class="line">        <span class="keyword">else</span> beg = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(beg, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-2nd-Jewels-and-Stones"><a href="#May-2nd-Jewels-and-Stones" class="headerlink" title="May 2nd: Jewels and Stones"></a>May 2nd: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/534/week-1-may-1st-may-7th/3317/">Jewels and Stones</a></h2><p>You’re given strings <code>J</code> representing the types of stones that are jewels, and <code>S</code> representing the stones you have. Each character in <code>S</code> is a type of stone you have. You want to know how many of the stones you have are also jewels.</p>
<p>The letters in <code>J</code> are guaranteed distinct, and all characters in <code>J</code> and <code>S</code> are letters. Letters are case sensitive, so <code>&quot;a&quot;</code> is considered a different type of stone from <code>&quot;A&quot;</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: J &#x3D; &quot;aA&quot;, S &#x3D; &quot;aAAbbbb&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: J &#x3D; &quot;z&quot;, S &#x3D; &quot;ZZ&quot;</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li><p><code>S</code> and <code>J</code> will consist of letters and have length at most 50.</p>
</li>
<li><p>The characters in <code>J</code> are distinct.</p>
</li>
</ul>
<h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>侮辱智商，不解释了。</p>
<h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(string J, string S)</span> </span>&#123;</span><br><span class="line">        array&lt;<span class="keyword">bool</span>, 52&gt; arr = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : J) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">                arr[ch-<span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                arr[ch-<span class="string">&#x27;A&#x27;</span>+<span class="number">26</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span> &amp;&amp; arr[ch-<span class="string">&#x27;a&#x27;</span>]) ||</span><br><span class="line">                (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span> &amp;&amp; arr[ch-<span class="string">&#x27;A&#x27;</span>+<span class="number">26</span>])) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-3rd-Ransom-Note"><a href="#May-3rd-Ransom-Note" class="headerlink" title="May 3rd: Ransom Note"></a>May 3rd: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/534/week-1-may-1st-may-7th/3318/">Ransom Note</a></h2><p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines; otherwise, it will return false.</p>
<p>Each letter in the magazine string can only be used once in your ransom note.</p>
<p><strong>Note:</strong></p>
<p>You may assume that both strings contain only lowercase letters.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; false</span><br><span class="line">canConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; false</span><br><span class="line">canConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true</span><br></pre></td></tr></table></figure>

<h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用 <code>map&lt;char, int&gt; m</code> 统计 <code>magazine</code> 中每个字符出现的个数，在遍历 <code>ransomNote</code> 的过程中消耗对应字符的个数，如果发现某个字符的个数为负，则说明无法用 <code>magazine</code> 中的字符构造 <code>ransomNote</code>，返回 <code>false</code> 即可。</p>
<h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : magazine) ++m[ch];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : ransomNote) --m[ch];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-4th-Number-Complement"><a href="#May-4th-Number-Complement" class="headerlink" title="May 4th: Number Complement"></a>May 4th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/534/week-1-may-1st-may-7th/3319/">Number Complement</a></h2><p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li><p>The given integer is guaranteed to fit within the range of a 32-bit signed integer.</p>
</li>
<li><p>You could assume no leading zero bit in the integer’s binary representation.</p>
</li>
<li><p>This question is the same as 1009: <a href="https://leetcode.com/problems/complement-of-base-10-integer/">https://leetcode.com/problems/complement-of-base-10-integer/</a></p>
</li>
</ul>
<h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>因为需要忽略二进制形式中开头的 <code>0</code>，所以首先从末尾起遍历一遍 <code>num</code>，使用 <code>cnt</code> 记录最后一个 <code>1</code> 出现的位置，然后使用异或运算 <code>^</code> 反转末尾的 <code>cnt</code> 个数字即可。</p>
<h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, tmp = <span class="number">0x1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &amp; tmp) cnt = i;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">31</span>) tmp = tmp &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = <span class="number">0x1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt+<span class="number">1</span>; ++i) &#123;</span><br><span class="line">            num = num ^ tmp;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">31</span>) tmp = tmp &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-5th-First-Unique-Character-in-a-String"><a href="#May-5th-First-Unique-Character-in-a-String" class="headerlink" title="May 5th: First Unique Character in a String"></a>May 5th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/534/week-1-may-1st-may-7th/3320/">First Unique Character in a String</a></h2><p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p>
<p><strong>Examples:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;leetcode&quot;,</span><br><span class="line">return 0.</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;loveleetcode&quot;,</span><br><span class="line">return 2.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong> You may assume the string contain only lowercase letters.</p>
<h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，遍历 <code>s</code>，使用 <code>map&lt;char, int&gt; m</code> 记录 <code>s</code> 中每个字符的出现次数。</p>
<p>然后，遍历 <code>s</code>，找到出现次数为 <code>1</code> 的字符，返回其下标即可。</p>
<h4 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : s) ++m[ch];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[s[i]] == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-6th-Majority-Element"><a href="#May-6th-Majority-Element" class="headerlink" title="May 6th: Majority Element"></a>May 6th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/534/week-1-may-1st-may-7th/3321/">Majority Element</a></h2><p>Given an array of size <code>n</code>, find the majority element. The majority element is the element that appears <strong>more than</strong> <code>n/2</code> times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,2,1,1,1,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>将 <code>nums</code> 进行排序，出现次数大于 <code>n/2</code> 的数字必然出现在下标为 <code>n/2</code> 的位置。</p>
<h4 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>()/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-7th-Cousins-in-Binary-Tree"><a href="#May-7th-Cousins-in-Binary-Tree" class="headerlink" title="May 7th: Cousins in Binary Tree"></a>May 7th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/534/week-1-may-1st-may-7th/3322/">Cousins in Binary Tree</a></h2><p>In a binary tree, the root node is at depth <code>0</code>, and children of each depth <code>k</code> node are at depth <code>k+1</code>.</p>
<p>Two nodes of a binary tree are <em>cousins</em> if they have the same depth, but have <strong>different parents</strong>.</p>
<p>We are given the <code>root</code> of a binary tree with unique values, and the values <code>x</code> and <code>y</code> of two different nodes in the tree.</p>
<p>Return <code>true</code> if and only if the nodes corresponding to the values <code>x</code> and <code>y</code> are cousins.</p>
<p><strong>Example 1:</strong></p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/00.png" style="zoom:80%"/>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,4], x &#x3D; 4, y &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/01.png" style="zoom:80%"/>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,null,4,null,5], x &#x3D; 5, y &#x3D; 4</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/02.png" style="zoom:80%"/>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,null,4], x &#x3D; 2, y &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li><p>The number of nodes in the tree will be between <code>2</code> and <code>100</code>.</p>
</li>
<li><p>Each node has a unique integer value from <code>1</code> to <code>100</code>.</p>
</li>
</ul>
<h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，使用 <code>queue&lt;TreeNode*&gt;</code> 对二叉树进行<strong>层级遍历</strong>。</p>
<p>其次，对于每一层，<strong>使用 <code>map&lt;int, int&gt; m</code> 记录节点的值与其在该层中的下标 <code>idx</code>，</strong>即使遇到 <code>nullptr</code> 的话 <code>idx</code> 也会自增，只是不做记录而已。</p>
<p>然后，<strong>如果 <code>x</code> 和 <code>y</code> 同时存在于 <code>m</code> 中，那么说明两者在同一层，</strong>继而判断两者是否属于同一父节点：</p>
<ul>
<li><p><strong>如果两者在该层的下标相差不为 <code>1</code>，那么不可能属于同一父节点。</strong></p>
</li>
<li><p><strong>如果两者在该层的下标相差为 <code>1</code>，但是两者下标中的较小者不是奇数，那么说明两者虽然相邻但属于不同父节点。</strong></p>
</li>
</ul>
<h4 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCousins</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; t;</span><br><span class="line">            map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">            <span class="keyword">int</span> idx = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                    t.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                    m[node-&gt;left-&gt;val] = idx;</span><br><span class="line">                &#125;</span><br><span class="line">                ++idx;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                    t.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                    m[node-&gt;right-&gt;val] = idx;</span><br><span class="line">                &#125;</span><br><span class="line">                ++idx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">find</span>(x) != m.<span class="built_in">end</span>() &amp;&amp; m.<span class="built_in">find</span>(y) != m.<span class="built_in">end</span>() &amp;&amp;</span><br><span class="line">                (<span class="built_in">abs</span>(m[x]-m[y]) != <span class="number">1</span> || <span class="built_in">min</span>(m[x],m[y]) % <span class="number">2</span> != <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B4 - 2020 LeetCoding Challenge</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Data Structure and Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>Challenge</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Weekly Contest 187 (1436 - 1439)</title>
    <url>/posts/leetcode-weekly-contest-187-1436-1439/</url>
    <content><![CDATA[<p>LeetCode 周赛专题每周随缘更新，点击类别 <a href="/categories/LeetCode-Weekly-Contest/">LeetCode Weekly Contest</a> 查看更多。</p>
<p>本次比赛通过 <code>3</code> 题，时间为 <code>1:01:42</code>，排名为 <code>2281/12350</code>。</p>
<span id="more"></span>

<h2 id="1436-Destination-City-Easy"><a href="#1436-Destination-City-Easy" class="headerlink" title="1436. Destination City #Easy"></a><a href="https://leetcode.com/contest/weekly-contest-187/problems/destination-city/">1436. Destination City</a> #Easy</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><div class="note info"><p>问题转化：**在所有成对城市 <code>[cityA_i, cityB_i]</code> 中寻找只出现了一次的目的城市 <code>cityB_i</code>**。</p>
</div>

<p>使用 <code>map&lt;string, int&gt; m</code> 对城市进行标记，遍历所有的成对城市 <code>[cityA_i, cityB_i]</code>，出发城市 <code>cityA_i</code> 的标记值累加 <code>1</code>，目的城市 <code>cityB_i</code> 的标记值累加 <code>2</code>，那么在遍历结束之后，<strong>标记值为 <code>1</code> 的为最初的城市，标记值为 <code>3</code> 的为路过的城市，标记值为 <code>2</code> 的为最后的城市。</strong></p>
<h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">destCity</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        map&lt;string, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> vs : paths) &#123;</span><br><span class="line">            m[vs[<span class="number">0</span>]] += <span class="number">1</span>;</span><br><span class="line">            m[vs[<span class="number">1</span>]] += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second == <span class="number">2</span>) <span class="keyword">return</span> p.first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1437-Check-If-All-1’s-Are-at-Least-Length-K-Places-Away-Medium"><a href="#1437-Check-If-All-1’s-Are-at-Least-Length-K-Places-Away-Medium" class="headerlink" title="1437. Check If All 1’s Are at Least Length K Places Away #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-187/problems/check-if-all-1s-are-at-least-length-k-places-away/">1437. Check If All 1’s Are at Least Length K Places Away</a> #Medium</h2><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>实际上就是对 <code>1</code> 之间的 <code>0</code> 进行计数。</p>
<div class="note warning"><p>需要注意的是，开头和结尾出现的 <code>0</code> 没有夹在 <code>1</code> 之间，应该避开这些情况。</p>
</div>

<h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">kLengthApart</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (idx &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[idx] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (++idx &lt; n &amp;&amp; nums[idx] == <span class="number">0</span>) ++cnt;</span><br><span class="line">                <span class="keyword">if</span> (idx &lt; n &amp;&amp; nums[idx] == <span class="number">1</span> &amp;&amp; cnt &lt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit-Medium"><a href="#1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit-Medium" class="headerlink" title="1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-187/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit">1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</a> #Medium</h2><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>滑动窗口算法就可以解决。</p>
<p>使用 <code>map&lt;int, int&gt; m</code> 记录滑动窗口内出现的数字，<strong>因为 <code>map</code> 是自动从小到大排序的，所以 <code>m.begin()</code> 指向的数字最小，<code>m.rbegin()</code> 指向的数字最大，</strong>可以用函数 <code>bool func(int limit)</code> 检查滑动窗口内的数字是否满足题目要求，寻找滑动窗口的最大长度即可。</p>
<div class="note info"><p>滑动窗口算法可以参考这篇文章：<a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/hua-dong-chuang-kou-ji-qiao">滑动窗口技巧</a>。</p>
</div>

<h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, beg = <span class="number">0</span>, end = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (beg &lt;= end &amp;&amp; end &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; <span class="built_in">func</span>(limit)) &#123;</span><br><span class="line">                ++m[nums[end]];</span><br><span class="line">                ++end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (end == n &amp;&amp; <span class="built_in">func</span>(limit)) res = <span class="built_in">max</span>(res, end-beg);</span><br><span class="line">            <span class="keyword">else</span> res = <span class="built_in">max</span>(res, end-beg<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">while</span> (beg &lt;= end &amp;&amp; !<span class="built_in">func</span>(limit)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--m[nums[beg]] == <span class="number">0</span>) m.<span class="built_in">erase</span>(nums[beg]);</span><br><span class="line">                ++beg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> m.<span class="built_in">rbegin</span>()-&gt;first - m.<span class="built_in">begin</span>()-&gt;first &lt;= limit;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1439-Find-the-Kth-Smallest-Sum-of-a-Matrix-With-Sorted-Rows-Hard"><a href="#1439-Find-the-Kth-Smallest-Sum-of-a-Matrix-With-Sorted-Rows-Hard" class="headerlink" title="1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows #Hard"></a><a href="https://leetcode.com/contest/weekly-contest-187/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/">1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows</a> #Hard</h2><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://leetcode.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/discuss/609707/simple-solution-with-explanation-c%2B%2B-code-example">simple solution with explanation [c++ code example]</a></p>
<p>其实就是暴力累加，但是<strong>在累加每一行之后，从小到大进行排序，只保留最多前 <code>k</code> 个数字，</strong>因为后面的数字不可能参与到第 <code>k</code> 个最终数字的运算中。</p>
<h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mat[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; vec.<span class="built_in">size</span>(); ++t) &#123;</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(mat[i][j]+vec[t]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">int</span> limit = <span class="built_in">min</span>(k, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(tmp.<span class="built_in">size</span>()));</span><br><span class="line">            vec = vector&lt;<span class="keyword">int</span>&gt;(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">begin</span>()+limit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B2 - LeetCode Weekly Contest</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Data Structure and Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 May LeetCoding Challenge - Week 2</title>
    <url>/posts/2020-may-leetcoding-challenge-week-2/</url>
    <content><![CDATA[<p>LeetCode 五月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-May-LeetCoding-Challenge/">2020 May LeetCoding Challenge</a> 查看更多。</p>
<span id="more"></span>

<h2 id="May-8th-Check-If-It-Is-a-Straight-Line"><a href="#May-8th-Check-If-It-Is-a-Straight-Line" class="headerlink" title="May 8th: Check If It Is a Straight Line"></a>May 8th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/535/week-2-may-8th-may-14th/3323/">Check If It Is a Straight Line</a></h2><p>You are given an array <code>coordinates</code>, <code>coordinates[i] = [x, y]</code>, where <code>[x, y]</code> represents the coordinate of a point. Check if these points make a straight line in the XY plane.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: coordinates &#x3D; [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: coordinates &#x3D; [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><p><code>2 &lt;= coordinates.length &lt;= 1000</code></p>
</li>
<li><p><code>coordinates[i].length == 2</code></p>
</li>
<li><p><code>-10^4 &lt;= coordinates[i][0], coordinates[i][1] &lt;= 10^4</code></p>
</li>
<li><p><code>coordinates</code> contains no duplicate point.</p>
</li>
</ul>
<h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>遍历所有点，每两点 <code>[x1, y1]</code> 和 <code>[x2, y2]</code> 之间计算斜率 <code>k</code>，判断其是否在遍历过程中保持不变。</p>
<p>实际上就是首先计算开头两点的斜率，然后判断后面的斜率是否与其相等。</p>
<div class="note warning"><p>需要注意的是，如果 <code>x1</code> 和 <code>x2</code> 相等，则无法通过除法计算斜率 <code>k</code>，此时将 <code>k</code> 赋值为 <code>DBL_MAX</code>，用来表示无穷大的斜率。</p>
</div>

<h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkStraightLine</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = coordinates.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">double</span> k = DBL_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">double</span> x1 = coordinates[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">double</span> y1 = coordinates[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">double</span> x2 = coordinates[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">double</span> y2 = coordinates[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (k == DBL_MIN) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x1 == x2) k = DBL_MAX;</span><br><span class="line">                <span class="keyword">else</span> k = (y2 - y1) / (x2 - x1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((x1 == x2 &amp;&amp; k != DBL_MAX) ||</span><br><span class="line">                (x1 != x2 &amp;&amp; (y2 - y1) / (x2 - x1) != k)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-9th-Valid-Perfect-Square"><a href="#May-9th-Valid-Perfect-Square" class="headerlink" title="May 9th: Valid Perfect Square"></a>May 9th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/535/week-2-may-8th-may-14th/3324/">Valid Perfect Square</a></h2><p>Given a positive integer <code>num</code>, write a function which returns True if <code>num</code> is a perfect square else False.</p>
<p><strong>Note:</strong> Do not use any built-in library function such as <code>sqrt</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 16</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 14</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>侮辱智商，不解释了。</p>
<h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (t * t &lt; num) ++t;</span><br><span class="line">        <span class="keyword">return</span> t * t == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-10th-Find-the-Town-Judge"><a href="#May-10th-Find-the-Town-Judge" class="headerlink" title="May 10th: Find the Town Judge"></a>May 10th: <a href="https://leetcode.com/explore/featured/card/may-leetcoding-challenge/535/week-2-may-8th-may-14th/3325/">Find the Town Judge</a></h2><p>In a town, there are <code>N</code> people labelled from <code>1</code> to <code>N</code>. There is a rumor that one of these people is secretly the town judge.</p>
<p>If the town judge exists, then:</p>
<ol>
<li><p>The town judge trusts nobody.</p>
</li>
<li><p>Everybody (except for the town judge) trusts the town judge.</p>
</li>
<li><p>There is exactly one person that satisfies properties 1 and 2.</p>
</li>
</ol>
<p>You are given <code>trust</code>, an array of pairs <code>trust[i] = [a, b]</code> representing that the person labelled <code>a</code> trusts the person labelled <code>b</code>.</p>
<p>If the town judge exists and can be identified, return the label of the town judge. Otherwise, return <code>-1</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 2, trust &#x3D; [[1,2]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 3, trust &#x3D; [[1,3],[2,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 3, trust &#x3D; [[1,3],[2,3],[3,1]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 3, trust &#x3D; [[1,2],[2,3]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 4, trust &#x3D; [[1,3],[1,4],[2,3],[2,4],[4,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li><p><code>1 &lt;= N &lt;= 1000</code></p>
</li>
<li><p><code>trust.length &lt;= 10000</code></p>
</li>
<li><p><code>trust[i]</code> are all different</p>
</li>
<li><p><code>trust[i][0] != trust[i][1]</code></p>
</li>
<li><p><code>1 &lt;= trust[i][0], trust[i][1] &lt;= N</code></p>
</li>
</ul>
<h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，使用 <code>map&lt;int, set&lt;int&gt;&gt; m</code> 存放某个人的受信任列表，即信任某个人的所有人。</p>
<p>其次，遍历 <code>m</code>，<strong>如果信任这个人 <code>p.first</code> 的所有人 <code>p.second</code> 共有 <code>N-1</code> 个，那么说明 <code>p.first</code> 受其他所有人的信任。</strong></p>
<p>然后，对于这个人 <code>p.first</code>，遍历其他人 <code>p.second</code>，<strong>如果 <code>p.first</code> 不存在于任何人的受信任列表 <code>m[t]</code> 中，那么说明 <code>p.first</code> 不信任其他所有人。</strong></p>
<h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findJudge</span><span class="params">(<span class="keyword">int</span> N, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; trust)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, set&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> vi : trust) m[vi[<span class="number">1</span>]].<span class="built_in">insert</span>(vi[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second.<span class="built_in">size</span>() == N<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">bool</span> b = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> t : p.second) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (m[t].<span class="built_in">count</span>(p.first)) &#123;</span><br><span class="line">                        b = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (b) <span class="keyword">return</span> p.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-11th-Flood-Fill"><a href="#May-11th-Flood-Fill" class="headerlink" title="May 11th: Flood Fill"></a>May 11th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/535/week-2-may-8th-may-14th/3326/">Flood Fill</a></h2><p>An <code>image</code> is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).</p>
<p>Given a coordinate <code>(sr, sc)</code> representing the starting pixel (row and column) of the flood fill, and a pixel value <code>newColor</code>, “flood fill” the image.</p>
<p>To perform a “flood fill”, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.</p>
<p>At the end, return the modified image.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">image &#x3D; [[1,1,1],[1,1,0],[1,0,1]]</span><br><span class="line">sr &#x3D; 1, sc &#x3D; 1, newColor &#x3D; 2</span><br><span class="line">Output: [[2,2,2],[2,2,0],[2,0,1]]</span><br><span class="line">Explanation: </span><br><span class="line">From the center of the image (with position (sr, sc) &#x3D; (1, 1)), all pixels connected</span><br><span class="line">by a path of the same color as the starting pixel are colored with the new color.</span><br><span class="line">Note the bottom corner is not colored 2, because it is not 4-directionally connected</span><br><span class="line">to the starting pixel.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li><p>The length of <code>image</code> and <code>image[0]</code> will be in the range <code>[1, 50]</code>.</p>
</li>
<li><p>The given starting pixel will satisfy <code>0 &lt;= sr &lt; image.length</code> and <code>0 &lt;= sc &lt; image[0].length</code>.</p>
</li>
<li><p>The value of each color in <code>image[i][j]</code> and <code>newColor</code> will be an integer in <code>[0, 65535]</code>.</p>
</li>
</ul>
<h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>典型的深度优先搜索算法就可以解决。</p>
<h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">floodFill</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = image.<span class="built_in">size</span>(), n = image[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">func</span>(image, visited, sr, sc, image[sr][sc], newColor);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;image, vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; &amp;visited,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> startColor, <span class="keyword">int</span> newColor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = image.<span class="built_in">size</span>(), n = image[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n ||</span><br><span class="line">            visited[x][y] || image[x][y] != startColor) <span class="keyword">return</span>;</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        image[x][y] = newColor;</span><br><span class="line">        <span class="built_in">func</span>(image, visited, x<span class="number">-1</span>, y, startColor, newColor);</span><br><span class="line">        <span class="built_in">func</span>(image, visited, x+<span class="number">1</span>, y, startColor, newColor);</span><br><span class="line">        <span class="built_in">func</span>(image, visited, x, y<span class="number">-1</span>, startColor, newColor);</span><br><span class="line">        <span class="built_in">func</span>(image, visited, x, y+<span class="number">1</span>, startColor, newColor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-12th-Single-Element-in-a-Sorted-Array"><a href="#May-12th-Single-Element-in-a-Sorted-Array" class="headerlink" title="May 12th: Single Element in a Sorted Array"></a>May 12th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/535/week-2-may-8th-may-14th/3327/">Single Element in a Sorted Array</a></h2><p>You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Find this single element that appears only once.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,1,2,3,3,4,4,8,8]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,3,7,7,10,11,11]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong> Your solution should run in O(log n) time and O(1) space.</p>
<h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><div class="note info"><p>需要明白的是，异或运算具备两个重要性质：</p>
<ul>
<li><p>对于数字 <code>num</code> 来说，<code>num ^ num == 0</code>。</p>
</li>
<li><p>对于数字 <code>num</code> 来说，<code>num ^ 0 == num</code>。</p>
</li>
</ul>
</div>

<p>对于出现两次的数字来说，遍历过程中的异或运算必然使其自身抵消，最终剩下出现一次的数字作为计算结果。</p>
<h4 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) res ^= num;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-13th-Remove-K-Digits"><a href="#May-13th-Remove-K-Digits" class="headerlink" title="May 13th: Remove K Digits"></a>May 13th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/535/week-2-may-8th-may-14th/3328/">Remove K Digits</a></h2><p>Given a non-negative integer <code>num</code> represented as a string, remove <code>k</code> digits from the number so that the new number is the smallest possible.</p>
<p><strong>Note:</strong></p>
<ul>
<li><p>The length of <code>num</code> is less than 10002 and will be ≥ <code>k</code>.</p>
</li>
<li><p>The given <code>num</code> does not contain any leading zero.</p>
</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num &#x3D; &quot;1432219&quot;, k &#x3D; 3</span><br><span class="line">Output: &quot;1219&quot;</span><br><span class="line">Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num &#x3D; &quot;10200&quot;, k &#x3D; 1</span><br><span class="line">Output: &quot;200&quot;</span><br><span class="line">Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num &#x3D; &quot;10&quot;, k &#x3D; 2</span><br><span class="line">Output: &quot;0&quot;</span><br><span class="line">Explanation: Remove all the digits from the number and it is left with nothing which is 0.</span><br></pre></td></tr></table></figure>

<h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://www.cnblogs.com/grandyang/p/5883736.html">[LeetCode] 402. Remove K Digits 去掉 K 位数字 - 刷尽天下</a></p>
<p>将 <code>num</code> 中的字符逐个添加到 <code>res</code> 中，为了保证高位上的数字尽可能地小，在添加过程中需要去除 <code>res</code> 中比当前字符大的字符，从而保证 <code>res</code> 是非递减的。</p>
<h4 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeKdigits</span><span class="params">(string num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> n = num.<span class="built_in">size</span>(), keep = n - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : num) &#123;</span><br><span class="line">            <span class="keyword">while</span> (k &amp;&amp; res.<span class="built_in">size</span>() &amp;&amp; res.<span class="built_in">back</span>() &gt; c) &#123;</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">resize</span>(keep);</span><br><span class="line">        <span class="keyword">while</span> (!res.<span class="built_in">empty</span>() &amp;&amp; res[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            res.<span class="built_in">erase</span>(res.<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">empty</span>() ? <span class="string">&quot;0&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-14th-Implement-Trie-Prefix-Tree"><a href="#May-14th-Implement-Trie-Prefix-Tree" class="headerlink" title="May 14th: Implement Trie (Prefix Tree)"></a>May 14th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/535/week-2-may-8th-may-14th/3329/">Implement Trie (Prefix Tree)</a></h2><p>Implement a trie with <code>insert</code>, <code>search</code>, and <code>startsWith</code> methods.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; returns true</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; returns false</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; returns true</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; returns true</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li><p>You may assume that all inputs are consist of lowercase letters <code>a-z</code>.</p>
</li>
<li><p>All inputs are guaranteed to be non-empty strings.</p>
</li>
</ul>
<h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>对于 <code>insert</code> 和 <code>search</code> 方法，可以使用 <code>set&lt;string&gt; s</code> 的 <code>insert</code> 和 <code>count</code> 方法实现。</p>
<p>对于 <code>startsWith</code> 方法，因为 <code>set</code> 自动对元素（此处为字符串）进行排序，所以可以遍历找到<strong>第一个大于等于 <code>prefix</code> 的字符串</strong>，如果该字符串是以 <code>prefix</code> 开头的，那么返回 <code>true</code>，否则返回 <code>false</code>。</p>
<h4 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    set&lt;string&gt; s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">Trie</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        s.<span class="built_in">insert</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">count</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = s.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (iter != s.<span class="built_in">end</span>() &amp;&amp; *iter &lt; prefix) ++iter;</span><br><span class="line">        <span class="keyword">return</span> iter != s.<span class="built_in">end</span>() &amp;&amp; prefix == iter-&gt;<span class="built_in">substr</span>(<span class="number">0</span>, prefix.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B4 - 2020 LeetCoding Challenge</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Data Structure and Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>Challenge</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Biweekly Contest 25 (1431 - 1434)</title>
    <url>/posts/leetcode-biweekly-contest-25-1431-1434/</url>
    <content><![CDATA[<p>LeetCode 双周赛专题每双周随缘更新，点击类别 <a href="/categories/LeetCode-Biweekly-Contest/">LeetCode Biweekly Contest</a> 查看更多。</p>
<span id="more"></span>

<h2 id="1431-Kids-With-the-Greatest-Number-of-Candies-Easy"><a href="#1431-Kids-With-the-Greatest-Number-of-Candies-Easy" class="headerlink" title="1431. Kids With the Greatest Number of Candies #Easy"></a><a href="https://leetcode.com/contest/biweekly-contest-25/problems/kids-with-the-greatest-number-of-candies/">1431. Kids With the Greatest Number of Candies</a> #Easy</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>侮辱智商，不解释了。</p>
<h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">kidsWithCandies</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_num = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> candy : candies) &#123;</span><br><span class="line">            max_num = <span class="built_in">max</span>(max_num, candy);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">bool</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> candy : candies) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(candy + extraCandies &gt;= max_num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1432-Max-Difference-You-Can-Get-From-Changing-an-Integer-Medium"><a href="#1432-Max-Difference-You-Can-Get-From-Changing-an-Integer-Medium" class="headerlink" title="1432. Max Difference You Can Get From Changing an Integer #Medium"></a><a href="https://leetcode.com/contest/biweekly-contest-25/problems/max-difference-you-can-get-from-changing-an-integer/">1432. Max Difference You Can Get From Changing an Integer</a> #Medium</h2><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，对于 <code>a</code> 来说，从高位开始遍历，如果发现某位数字不为 <code>9</code>，那么将 <code>a</code> 中的所有该位数字替换为 <code>9</code>。</p>
<p>其次，对于 <code>b</code> 来说，如果发现第一位数字不为 <code>1</code>，那么将 <code>b</code> 中的所有该位数字替换为 <code>1</code>，否则从高位开始遍历，如果发现某位数字不为 <code>1</code> 且不为 <code>0</code>，那么将 <code>b</code> 中的所有该位数字替换为 <code>0</code>。</p>
<h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDiff</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = num, b = num, div = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (num /= <span class="number">10</span>) div *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> rep = <span class="number">-1</span>, tdiv = div;</span><br><span class="line">        <span class="keyword">while</span> (tdiv) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rep == <span class="number">-1</span> &amp;&amp; a / tdiv % <span class="number">10</span> != <span class="number">9</span>) &#123;</span><br><span class="line">                rep = a / tdiv % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a / tdiv % <span class="number">10</span> == rep) &#123;</span><br><span class="line">                a = a + (<span class="number">9</span> - rep) * tdiv;</span><br><span class="line">            &#125;</span><br><span class="line">            tdiv /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rep = <span class="number">-1</span>, tdiv = div;</span><br><span class="line">        <span class="keyword">bool</span> f = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (b / div % <span class="number">10</span> != <span class="number">1</span>) &#123;</span><br><span class="line">            rep = b / div % <span class="number">10</span>;</span><br><span class="line">            f = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (tdiv) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rep == <span class="number">-1</span> &amp;&amp; b / tdiv % <span class="number">10</span> != <span class="number">1</span> &amp;&amp; b / tdiv % <span class="number">10</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                rep = b / tdiv % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b / tdiv % <span class="number">10</span> == rep) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f) b = b + (<span class="number">1</span> - rep) * tdiv;</span><br><span class="line">                <span class="keyword">else</span> b = b + (<span class="number">0</span> - rep) * tdiv;</span><br><span class="line">            &#125;</span><br><span class="line">            tdiv /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1433-Check-If-a-String-Can-Break-Another-String-Medium"><a href="#1433-Check-If-a-String-Can-Break-Another-String-Medium" class="headerlink" title="1433. Check If a String Can Break Another String #Medium"></a><a href="https://leetcode.com/contest/biweekly-contest-25/problems/check-if-a-string-can-break-another-string/">1433. Check If a String Can Break Another String</a> #Medium</h2><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>再次侮辱智商，不解释了。</p>
<h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkIfCanBreak</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">const</span> string &amp;s3 = <span class="built_in">min</span>(s1, s2);</span><br><span class="line">        <span class="keyword">const</span> string &amp;s4 = <span class="built_in">max</span>(s1, s2);</span><br><span class="line">        <span class="keyword">int</span> n = s3.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s3[i] &gt; s4[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1434-Number-of-Ways-to-Wear-Different-Hats-to-Each-Other-Hard"><a href="#1434-Number-of-Ways-to-Wear-Different-Hats-to-Each-Other-Hard" class="headerlink" title="1434. Number of Ways to Wear Different Hats to Each Other #Hard"></a><a href="https://leetcode.com/contest/biweekly-contest-25/problems/number-of-ways-to-wear-different-hats-to-each-other/">1434. Number of Ways to Wear Different Hats to Each Other</a> #Hard</h2><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://leetcode.com/problems/number-of-ways-to-wear-different-hats-to-each-other/discuss/608686/C%2B%2B-Bit-masks-and-Bottom-Up-DP">[C++] Bit-masks and Bottom-Up DP</a></p>
<p>这种题目我已经放弃治疗了，直接看大佬的解法吧。</p>
<h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberWays</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; hats)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">persons</span>(<span class="number">40</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = hats.<span class="built_in">size</span>(), mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">masks</span><span class="params">(<span class="number">1</span> &lt;&lt; n)</span></span>;</span><br><span class="line">        masks[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;h: hats[i]) &#123;</span><br><span class="line">                persons[h - <span class="number">1</span>].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;p: persons[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((j &amp; (<span class="number">1</span> &lt;&lt; p)) == <span class="number">0</span>) &#123;</span><br><span class="line">                        masks[j | (<span class="number">1</span> &lt;&lt; p)] += masks[j];</span><br><span class="line">                        masks[j | (<span class="number">1</span> &lt;&lt; p)] %= mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> masks[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B3 - LeetCode Biweekly Contest</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Data Structure and Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Weekly Contest 188 (1441 - 1444)</title>
    <url>/posts/leetcode-weekly-contest-188-1441-1444/</url>
    <content><![CDATA[<p>LeetCode 周赛专题每周随缘更新，点击类别 <a href="/categories/LeetCode-Weekly-Contest/">LeetCode Weekly Contest</a> 查看更多。</p>
<p>本次比赛通过 <code>3</code> 题，时间为 <code>1:14:56</code>，排名为 <code>2375/12715</code>。</p>
<span id="more"></span>

<h2 id="1441-Build-an-Array-With-Stack-Operations-Easy"><a href="#1441-Build-an-Array-With-Stack-Operations-Easy" class="headerlink" title="1441. Build an Array With Stack Operations #Easy"></a><a href="https://leetcode.com/contest/weekly-contest-188/problems/build-an-array-with-stack-operations/">1441. Build an Array With Stack Operations</a> #Easy</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，遍历 <code>target</code>，在 <code>res</code> 中添加 <code>&quot;Push&quot;</code>。</p>
<p>其次，累加 <code>num</code>，如果遍历到的数字与 <code>num</code> 不同，那么在 <code>res</code> 中添加 <code>&quot;Pop&quot;</code>，同时将遍历下标 <code>i</code> 停在当前位置。</p>
<h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">buildArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="string">&quot;Push&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (num != target[i]) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&quot;Pop&quot;</span>);</span><br><span class="line">                --i;</span><br><span class="line">            &#125;</span><br><span class="line">            ++num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR-Medium"><a href="#1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR-Medium" class="headerlink" title="1442. Count Triplets That Can Form Two Arrays of Equal XOR #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-188/problems/count-triplets-that-can-form-two-arrays-of-equal-xor">1442. Count Triplets That Can Form Two Arrays of Equal XOR</a> #Medium</h2><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><div class="note info"><p>需要明白的是，异或运算具备一个重要性质：如果　<code>a ^ b ^ c ^ d = e</code>，那么　<code>c ^ d = e ^ (a ^ b)</code>。</p>
</div>

<p>首先，使用 <code>vec</code> 存放每个数字与之前所有数字异或运算的结果。</p>
<p>其次，根据异或运算的性质，计算 <code>[i, j-1]</code> 之间数字异或运算的结果，只需计算 <code>vec[j-1] ^ vec[i-1]</code>。</p>
<p>同理，计算 <code>[j, k]</code> 之间数字异或运算的结果，只需计算 <code>vec[k] ^ vec[j-1]</code>。</p>
<h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(vec.<span class="built_in">back</span>() ^ arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; vec.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; vec.<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((vec[j<span class="number">-1</span>] ^ vec[i<span class="number">-1</span>]) == (vec[k] ^ vec[j<span class="number">-1</span>])) &#123;</span><br><span class="line">                        ++res;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree-Medium"><a href="#1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree-Medium" class="headerlink" title="1443. Minimum Time to Collect All Apples in a Tree #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-188/problems/minimum-time-to-collect-all-apples-in-a-tree/">1443. Minimum Time to Collect All Apples in a Tree</a> #Medium</h2><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，使用 <code>map&lt;int, vector&lt;int&gt;&gt; m</code> 记录每个节点的所有子节点。</p>
<p>其次，使用深度优先搜索算法遍历所有的节点，返回到达某个节点及其之后节点所需要的时间步。其边界条件是遍历到叶子节点，如果叶子节点包含苹果，因为往返这个节点需要 <code>2</code> 个时间步，所以返回 <code>2</code>，否则返回 <code>0</code>。</p>
<p>然后，对于遍历到的节点，需要遍历其所有子节点，同时使用 <code>sum</code> 累加子节点返回的值，如果该节点不为根节点，而且其子节点之和不为 <code>0</code>（表明其子树包含苹果）或者节点本身包含苹果，那么必然需要往返该节点，<code>sum</code> 累加 <code>2</code>。</p>
<h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTime</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="keyword">bool</span>&gt;&amp; hasApple)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> vi : edges) m[vi[<span class="number">0</span>]].<span class="built_in">push_back</span>(vi[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(<span class="number">0</span>, m, hasApple);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> idx, map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;m, vector&lt;<span class="keyword">bool</span>&gt; &amp;hasApple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m.<span class="built_in">count</span>(idx)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasApple[idx]) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : m[idx]) sum += <span class="built_in">func</span>(i, m, hasApple);</span><br><span class="line">        <span class="keyword">if</span> (idx != <span class="number">0</span> &amp;&amp; (sum != <span class="number">0</span> || hasApple[idx])) sum += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1444-Number-of-Ways-of-Cutting-a-Pizza-Hard"><a href="#1444-Number-of-Ways-of-Cutting-a-Pizza-Hard" class="headerlink" title="1444. Number of Ways of Cutting a Pizza #Hard"></a><a href="https://leetcode.com/contest/weekly-contest-188/problems/number-of-ways-of-cutting-a-pizza/">1444. Number of Ways of Cutting a Pizza</a> #Hard</h2><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza/discuss/623732/JavaC%2B%2B-DP-%2B-PrefixSum-in-Matrix-Clean-code">[Java/C++] DP + PrefixSum in Matrix - Clean code</a></p>
<p>放弃治疗系列，直接看大佬的解法吧。</p>
<h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ways</span><span class="params">(vector&lt;string&gt;&amp; pizza, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = pizza.<span class="built_in">size</span>(), n = pizza[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(k, <span class="built_in">vector</span>(m, <span class="built_in">vector</span>(n, <span class="number">-1</span>)));</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">preSum</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = m - <span class="number">1</span>; r &gt;= <span class="number">0</span>; --r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = n - <span class="number">1</span>; c &gt;= <span class="number">0</span>; --c) &#123;</span><br><span class="line">                preSum[r][c] = preSum[r][c+<span class="number">1</span>] + preSum[r+<span class="number">1</span>][c] - preSum[r+<span class="number">1</span>][c+<span class="number">1</span>];</span><br><span class="line">                preSum[r][c] += (pizza[r][c] == <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(m, n, k<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, dp, preSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> r, <span class="keyword">int</span> c,</span></span></span><br><span class="line"><span class="function"><span class="params">            vector&lt;vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt; &amp;dp, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;preSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preSum[r][c] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp[k][r][c] != <span class="number">-1</span>) <span class="keyword">return</span> dp[k][r][c];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nr = r + <span class="number">1</span>; nr &lt; m; ++nr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (preSum[r][c] - preSum[nr][c] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans = (ans + <span class="built_in">dfs</span>(m, n, k<span class="number">-1</span>, nr, c, dp, preSum)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nc = c + <span class="number">1</span>; nc &lt; n; ++nc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (preSum[r][c] - preSum[r][nc] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans = (ans + <span class="built_in">dfs</span>(m, n, k<span class="number">-1</span>, r, nc, dp, preSum)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][r][c] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B2 - LeetCode Weekly Contest</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Data Structure and Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次「卖」微信公众号的经历</title>
    <url>/posts/record-for-sell-wechat-official-account/</url>
    <content><![CDATA[<p><strong>因为腾讯在两年前关闭了新注册微信公众号的「留言」功能，所以新注册微信公众号必须通过一些特殊方法才能拥有「留言」功能，「账号迁移」便是其中之一。</strong></p>
<p>刚好，我有一个闲置已久的微信公众号，于是联系到经办人将自己的微信公众号「卖」了出去。<strong>两个工作日</strong>的时间就把整个流程走完了，大部分手续都是经办人的事情，需要我来配合的地方并不多。</p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/03.png" style="zoom:100%"/>

<span id="more"></span>

<h2 id="0-事情起因"><a href="#0-事情起因" class="headerlink" title="0 事情起因"></a>0 事情起因</h2><p>几天前，在逛 V2EX 的时候，看到一个<a href="https://www.v2ex.com/t/668420">帖子</a>，里面讲到：</p>
<blockquote>
<p>做公众号，特别是近期注册的都想要留言功能。但是 2018 年 3 月 12 日之后注册的微信公众号默认没有留言功能。</p>
<p>新号想要留言功能，基本上就一条路花几千找人做迁移有留言功能的老号才行。</p>
</blockquote>
<p>巧合的是，在此之前的几天，我想起自己有个闲置已久的微信公众号，当时觉得没什么用了，于是申请了账号注销，七天后再次确认即可彻底注销。看到这个帖子之后，我立马终止了注销流程，开始琢磨怎么把它卖掉。</p>
<h2 id="1-迁移过程"><a href="#1-迁移过程" class="headerlink" title="1 迁移过程"></a>1 迁移过程</h2><p>简单搜索之后，我了解到腾讯关闭了新注册微信公众号的「留言」功能，想要开通的话需要一些特殊方法，具体可以参考<a href="https://zhuanlan.zhihu.com/p/63996356">微信公众号留言开通最全攻略</a>。</p>
<p>同时，我联系到一个专业的经办人，可以帮忙「卖」掉带有「留言」功能的微信公众号。</p>
<div class="note info"><p>接下来，从我的角度来描述一下大概的流程：</p>
<ol>
<li><p>第一天，经办人登录我的微信公众号，确认微信公众号的基本信息及违规记录。</p>
</li>
<li><p>随后，经办人要求我提供身份证正反面的照片，照片需要带有「公众号迁移」字样的水印。<strong>提供照片之后，经办人付给了我一半的费用。</strong></p>
</li>
<li><p>三个小时后，经办人要求我进行电子公证，此处需要进行人脸识别。</p>
</li>
<li><p>第二天，经办人再次登录我的微信公众号。</p>
</li>
<li><p>随后，经办人要求我扫码对「账号迁移」进行确认，此时微信需要对迁移申请进行审核。</p>
</li>
<li><p>四个小时后，微信对迁移申请的审核通过，经办人要求再次对「账号迁移」进行确认。<strong>最终确认之后，经办人付给了我另外一半的费用。</strong></p>
</li>
</ol>
</div>

<p>以上就是我需要做的事情，总体来说不算麻烦，何乐而不为。</p>
<h2 id="2-推广"><a href="#2-推广" class="headerlink" title="2 推广"></a>2 推广</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/04.png" style="zoom:100%"/>

<p><strong>如果你也有一个在 2018 年 03 月 12 日之前注册而又闲置的微信公众号，可以通过「下方的评论区」或「<a href="/about/">关于</a>页面的其他联系方式」联系到我，</strong>我可以把这个比较靠谱的经办人推荐给你。</p>
]]></content>
      <categories>
        <category>A1 - 生活随笔</category>
        <category>B1 - 经历</category>
      </categories>
      <tags>
        <tag>WeChat</tag>
        <tag>Life</tag>
        <tag>Promotion</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 May LeetCoding Challenge - Week 3</title>
    <url>/posts/2020-may-leetcoding-challenge-week-3/</url>
    <content><![CDATA[<p>LeetCode 五月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-May-LeetCoding-Challenge/">2020 May LeetCoding Challenge</a> 查看更多。</p>
<span id="more"></span>

<h2 id="May-15th-Maximum-Sum-Circular-Subarray"><a href="#May-15th-Maximum-Sum-Circular-Subarray" class="headerlink" title="May 15th: Maximum Sum Circular Subarray"></a>May 15th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/536/week-3-may-15th-may-21st/3330/">Maximum Sum Circular Subarray</a></h2><p>Given a <strong>circular array C</strong> of integers represented by <code>A</code>, find the maximum possible sum of a non-empty subarray of <strong>C</strong>.</p>
<p>Here, a <em>circular array</em> means the end of the array connects to the beginning of the array. (Formally, <code>C[i] = A[i]</code> when <code>0 &lt;= i &lt; A.length</code>, and <code>C[i+A.length] = C[i]</code> when <code>i &gt;= 0</code>.)</p>
<p>Also, a subarray may only include each element of the fixed buffer <code>A</code> at most once. (Formally, for a subarray <code>C[i], C[i+1], ..., C[j]</code>, there does not exist <code>i &lt;= k1, k2 &lt;= j</code> with <code>k1 % A.length = k2 % A.length</code>.)</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,-2,3,-2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarray [3] has maximum sum 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [5,-3,5]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: Subarray [5,5] has maximum sum 5 + 5 &#x3D; 10</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,-1,2,-1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 &#x3D; 4</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,-2,2,-3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-2,-3,-1]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: Subarray [-1] has maximum sum -1</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li><p><code>-30000 &lt;= A[i] &lt;= 30000</code></p>
</li>
<li><p><code>1 &lt;= A.length &lt;= 30000</code></p>
</li>
</ul>
<h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://www.cnblogs.com/grandyang/p/11716314.html">[LeetCode] 918. Maximum Sum Circular Subarray 环形子数组的最大和 - 刷尽天下</a></p>
<p>考虑到环形数组，子数组的和实际上包含两种情况：</p>
<ul>
<li><p><strong>一种是正常的，即 <code>A</code> 的某一子数组。</strong></p>
<p>对于这种情况，可以这样处理：在遍历过程中，**<code>curMx = max(curMx+num, num);</code> 语句表示 <code>curMx</code> 要么延续之前的子数组，要么放弃之前的子数组，<strong>即是否重新组织子数组，然后</strong>使用 <code>mx = max(mx, curMx);</code> 语句寻找子数组和的最大值。**</p>
</li>
<li><p><strong>另一种是两段的，即 <code>A</code> 的开头一段和结束一段组合而成的某一子数组。</strong></p>
<p>对于这种情况，可以这样处理：仿照第一种情况的方法，<strong>寻找子数组和的最小值 <code>mn</code>，使用 <code>A</code> 的总和 <code>sum</code> 减去 <code>mn</code> 就可以得到子数组和的最大值。</strong></p>
</li>
</ul>
<p>最后，上述两种情况取较大值即可。</p>
<p>另外，如果 <code>sum</code> 与 <code>mn</code> 相等，说明 <code>A</code> 中全为负数，结果应该是 <code>A</code> 中最大的负数，此时直接返回 <code>mx</code> 即可。</p>
<h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, mn = INT_MAX, mx = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> curMn = <span class="number">0</span>, curMx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : A) &#123;</span><br><span class="line">            curMn = <span class="built_in">min</span>(curMn+num, num);</span><br><span class="line">            mn = <span class="built_in">min</span>(mn, curMn);</span><br><span class="line">            curMx = <span class="built_in">max</span>(curMx+num, num);</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, curMx);</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sum == mn) ? mx : <span class="built_in">max</span>(mx, sum-mn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-16th-Odd-Even-Linked-List"><a href="#May-16th-Odd-Even-Linked-List" class="headerlink" title="May 16th: Odd Even Linked List"></a>May 16th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/536/week-3-may-15th-may-21st/3331/">Odd Even Linked List</a></h2><p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>
<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL</span><br><span class="line">Output: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li><p>The relative order inside both the even and odd groups should remain as it was in the input.</p>
</li>
<li><p>The first node is considered odd, the second node even and so on …</p>
</li>
</ul>
<h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://www.cnblogs.com/grandyang/p/5138936.html">[LeetCode] Odd Even Linked List 奇偶链表 - 刷尽天下</a></p>
<p>其实比着代码画个图就能明白了。</p>
<h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *pre = head, *cur = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;next) &#123;</span><br><span class="line">            ListNode *tmp = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            pre-&gt;next-&gt;next = tmp;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-17th-Find-All-Anagrams-in-a-String"><a href="#May-17th-Find-All-Anagrams-in-a-String" class="headerlink" title="May 17th: Find All Anagrams in a String"></a>May 17th: <a href="https://leetcode.com/explore/featured/card/may-leetcoding-challenge/536/week-3-may-15th-may-21st/3332/">Find All Anagrams in a String</a></h2><p>Given a string <strong>s</strong> and a <strong>non-empty</strong> string <strong>p</strong>, find all the start indices of <strong>p</strong>‘s anagrams in <strong>s</strong>.</p>
<p>Strings consists of lowercase English letters only and the length of both strings <strong>s</strong> and <strong>p</strong> will not be larger than 20,100.</p>
<p>The order of output does not matter.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index &#x3D; 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.</span><br><span class="line">The substring with start index &#x3D; 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s: &quot;abab&quot; p: &quot;ab&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[0, 1, 2]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index &#x3D; 0 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class="line">The substring with start index &#x3D; 1 is &quot;ba&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class="line">The substring with start index &#x3D; 2 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br></pre></td></tr></table></figure>

<h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p><strong>使用 <code>array&lt;int, 256&gt;</code> 的 <code>arr1</code> 和 <code>arr2</code> 分别记录 <code>s</code> 的滑动窗口中和 <code>p</code> 中字符出现的次数，</strong>通过比较 <code>arr1</code> 和 <code>arr2</code> 是否相等，就可以知道滑动窗口中的字符串是否为 <code>p</code> 的变型。</p>
<p>P.S. 一开始还使用 <code>multiset&lt;char&gt;</code> 做记录，然后就超时了。</p>
<h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = s.<span class="built_in">size</span>(), n2 = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n1 &lt; n2) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        array&lt;<span class="keyword">int</span>, 256&gt; arr1&#123;&#125;, arr2&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n2; ++i) &#123;</span><br><span class="line">            ++arr1[s[i]];</span><br><span class="line">            ++arr2[p[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr1 == arr2) res.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n2; i &lt; n1; ++i) &#123;</span><br><span class="line">            ++arr1[s[i]];</span><br><span class="line">            --arr1[s[i-n2]];</span><br><span class="line">            <span class="keyword">if</span> (arr1 == arr2) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i-n2+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-18th-Permutation-in-String"><a href="#May-18th-Permutation-in-String" class="headerlink" title="May 18th: Permutation in String"></a>May 18th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/536/week-3-may-15th-may-21st/3333/">Permutation in String</a></h2><p>Given two strings <strong>s1</strong> and <strong>s2</strong>, write a function to return true if <strong>s2</strong> contains the permutation of <strong>s1</strong>. In other words, one of the first string’s permutations is the <strong>substring</strong> of the second string.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidbaooo&quot;</span><br><span class="line">Output: True</span><br><span class="line">Explanation: s2 contains one permutation of s1 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1&#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidboaoo&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li><p>The input strings only contain lower case letters.</p>
</li>
<li><p>The length of both given strings is in range [1, 10,000].</p>
</li>
</ul>
<h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>梅开二度，这不就是昨天的题嘛，不解释了。</p>
<h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = s1.<span class="built_in">size</span>(), n2 = s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n1 &gt; n2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        array&lt;<span class="keyword">int</span>, 256&gt; arr1&#123;&#125;, arr2&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; ++i) &#123;</span><br><span class="line">            ++arr1[s1[i]];</span><br><span class="line">            ++arr2[s2[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr1 == arr2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n1; i &lt; n2; ++i) &#123;</span><br><span class="line">            ++arr2[s2[i]];</span><br><span class="line">            --arr2[s2[i-n1]];</span><br><span class="line">            <span class="keyword">if</span> (arr1 == arr2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-19th-Online-Stock-Span"><a href="#May-19th-Online-Stock-Span" class="headerlink" title="May 19th: Online Stock Span"></a>May 19th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/536/week-3-may-15th-may-21st/3334/">Online Stock Span</a></h2><p>Write a class <code>StockSpanner</code> which collects daily price quotes for some stock, and returns the <em>span</em> of that stock’s price for the current day.</p>
<p>The span of the stock’s price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today’s price.</p>
<p>For example, if the price of a stock over the next 7 days were <code>[100, 80, 60, 70, 60, 75, 85]</code>, then the stock spans would be <code>[1, 1, 1, 2, 1, 4, 6]</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;StockSpanner&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[],[100],[80],[60],[70],[60],[75],[85]]</span><br><span class="line">Output: [null,1,1,1,2,1,4,6]</span><br><span class="line">Explanation:</span><br><span class="line">First, S &#x3D; StockSpanner() is initialized. Then:</span><br><span class="line">S.next(100) is called and returns 1,</span><br><span class="line">S.next(80) is called and returns 1,</span><br><span class="line">S.next(60) is called and returns 1,</span><br><span class="line">S.next(70) is called and returns 2,</span><br><span class="line">S.next(60) is called and returns 1,</span><br><span class="line">S.next(75) is called and returns 4,</span><br><span class="line">S.next(85) is called and returns 6.</span><br><span class="line"></span><br><span class="line">Note that (for example) S.next(75) returned 4, because the last 4 prices</span><br><span class="line">(including today&#39;s price of 75) were less than or equal to today&#39;s price.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li><p>Calls to <code>StockSpanner.next(int price)</code> will have <code>1 &lt;= price &lt;= 10^5</code>.</p>
</li>
<li><p>There will be at most <code>10000</code> calls to <code>StockSpanner.next</code> per test case.</p>
</li>
<li><p>There will be at most <code>150000</code> calls to <code>StockSpanner.next</code> across all test cases.</p>
</li>
<li><p>The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages.</p>
</li>
</ul>
<h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://www.cnblogs.com/grandyang/p/11029306.html">[LeetCode] 901. Online Stock Span 股票价格跨度 - 刷尽天下</a></p>
<p>使用 <code>stack&lt;pair&lt;int, int&gt;&gt; st</code> 中的 <code>pair&lt;int, int&gt;</code> 存放当前股价和之前股价不比其高的连续天数。</p>
<p>每次调用 <code>next</code> 方法，循环遍历堆顶元素，如果其股价不比当前股价 <code>price</code> 高，则累加其连续天数至 <code>cnt</code>，直到其股价比当前股价 <code>price</code> 高。</p>
<p>结束遍历后，将当前股价 <code>price</code> 和之前股价不比其高的连续天数 <code>cnt</code> 添加至 <code>st</code> 的堆顶，返回 <code>cnt</code> 即可。</p>
<h4 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StockSpanner</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>().first &lt;= price) &#123;</span><br><span class="line">            cnt += st.<span class="built_in">top</span>().second; st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(&#123;price, cnt&#125;);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StockSpanner* obj = new StockSpanner();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next(price);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="May-20th-Kth-Smallest-Element-in-a-BST"><a href="#May-20th-Kth-Smallest-Element-in-a-BST" class="headerlink" title="May 20th: Kth Smallest Element in a BST"></a>May 20th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/536/week-3-may-15th-may-21st/3335/">Kth Smallest Element in a BST</a></h2><p>Given a binary search tree, write a function <code>kthSmallest</code> to find the <strong>k</strong>th smallest element in it.</p>
<p><strong>Note:</strong></p>
<p>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><div class="note info"><p>众所周知，对二叉搜索树 BST 进行<strong>中序遍历</strong>，其结果即为从小到大排序的序列。</p>
</div>

<p>对二叉搜索树 BST 进行中序遍历的过程中，累减 <code>k</code> 直至 <code>k</code> 变为 <code>0</code>，返回节点的值即可。</p>
<h4 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(root, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(TreeNode *node, <span class="keyword">int</span> &amp;k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="built_in">func</span>(node-&gt;left, k);</span><br><span class="line">            <span class="keyword">if</span> (t != INT_MIN) <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="built_in">func</span>(node-&gt;right, k);</span><br><span class="line">            <span class="keyword">if</span> (t != INT_MIN) <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-21st-Count-Square-Submatrices-with-All-Ones"><a href="#May-21st-Count-Square-Submatrices-with-All-Ones" class="headerlink" title="May 21st: Count Square Submatrices with All Ones"></a>May 21st: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/536/week-3-may-15th-may-21st/3336/">Count Square Submatrices with All Ones</a></h2><p>Given a <code>m * n</code> matrix of ones and zeros, return how many <strong>square</strong> submatrices have all ones.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [0,1,1,1],</span><br><span class="line">  [1,1,1,1],</span><br><span class="line">  [0,1,1,1]</span><br><span class="line">]</span><br><span class="line">Output: 15</span><br><span class="line">Explanation:</span><br><span class="line">There are 10 squares of side 1.</span><br><span class="line">There are 4 squares of side 2.</span><br><span class="line">There is  1 square of side 3.</span><br><span class="line">Total number of squares &#x3D; 10 + 4 + 1 &#x3D; 15.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [1,1,0],</span><br><span class="line">  [1,1,0]</span><br><span class="line">]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation:</span><br><span class="line">There are 6 squares of side 1.</span><br><span class="line">There is 1 square of side 2.</span><br><span class="line">Total number of squares &#x3D; 6 + 1 &#x3D; 7.</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><p><code>1 &lt;= matrix.length &lt;= 300</code></p>
</li>
<li><p><code>1 &lt;= matrix[0].length &lt;= 300</code></p>
</li>
<li><p><code>0 &lt;= matrix[i][j] &lt;= 1</code></p>
</li>
</ul>
<h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>P.S. 印象中碰到过这道题，那次没做出来，看了别人的解法之后，这次就记着了。</p>
<p>使用 <code>vec</code> 记录<strong>以当前位置 <code>[i][j]</code> 为右下角的全 <code>1</code> 矩阵的最大尺寸</strong>，也就是<strong>以当前位置 <code>[i][j]</code> 为右下角的全 <code>1</code> 矩阵的个数</strong>。</p>
<p>如果当前位置在 <code>matrix</code> 中的值 <code>matrix[i-1][j-1]</code> 为 <code>1</code>，那么可以<strong>通过左上 <code>vec[i-1][j-1]</code>、左侧 <code>vec[i][j-1]</code> 和上方 <code>vec[i-1][j]</code> 中的最小值加 <code>1</code> 得到 <code>vec[i][j]</code>。</strong></p>
<div class="note info"><p>需要注意的是，为了在动态规划算法中使用统一的递推公式，一般将矩阵扩增一行和一列，所以 <code>vec[i][j]</code> 对应的是 <code>matrix[i-1][j-1]</code>。</p>
</div>

<p>最后，在遍历过程中，使用 <code>res</code> 累加 <code>vec[i][j]</code> 即可。</p>
<h4 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">vec</span>(m+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                    vec[i][j] = <span class="built_in">min</span>(vec[i<span class="number">-1</span>][j<span class="number">-1</span>],</span><br><span class="line">                                    <span class="built_in">min</span>(vec[i][j<span class="number">-1</span>], vec[i<span class="number">-1</span>][j])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res += vec[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B4 - 2020 LeetCoding Challenge</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Data Structure and Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>Challenge</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Weekly Contest 189 (1450 - 1453)</title>
    <url>/posts/leetcode-weekly-contest-189-1450-1453/</url>
    <content><![CDATA[<p>LeetCode 周赛专题每周随缘更新，点击类别 <a href="/categories/LeetCode-Weekly-Contest/">LeetCode Weekly Contest</a> 查看更多。</p>
<p>本次比赛通过 <code>3</code> 题，时间为 <code>0:48:25</code>，排名为 <code>2708/13036</code>。</p>
<span id="more"></span>

<h2 id="1450-Number-of-Students-Doing-Homework-at-a-Given-Time-Easy"><a href="#1450-Number-of-Students-Doing-Homework-at-a-Given-Time-Easy" class="headerlink" title="1450. Number of Students Doing Homework at a Given Time #Easy"></a><a href="https://leetcode.com/contest/weekly-contest-189/problems/number-of-students-doing-homework-at-a-given-time/">1450. Number of Students Doing Homework at a Given Time</a> #Easy</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>侮辱智商，不解释了。</p>
<h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">busyStudent</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; startTime, vector&lt;<span class="keyword">int</span>&gt;&amp; endTime, <span class="keyword">int</span> queryTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = startTime.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (startTime[i] &lt;= queryTime &amp;&amp; endTime[i] &gt;= queryTime) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1451-Rearrange-Words-in-a-Sentence-Medium"><a href="#1451-Rearrange-Words-in-a-Sentence-Medium" class="headerlink" title="1451. Rearrange Words in a Sentence #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-189/problems/rearrange-words-in-a-sentence">1451. Rearrange Words in a Sentence</a> #Medium</h2><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用 <code>vector&lt;pair&lt;vector&lt;int&gt;, string&gt;&gt; vec</code> 存放分割后的子字符串，<strong>其中 <code>vector&lt;int&gt;</code> 包含两个数字，第一个为字符串的长度，第二个为字符串的序号，</strong>从而在之后的 <code>sort</code> 中按照字符串的长度排序，如果长度相等，则按照字符串的原顺序排序。</p>
<h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">arrangeWords</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        text[<span class="number">0</span>] -= <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        text.<span class="built_in">push_back</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, cur = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        vector&lt;pair&lt;vector&lt;<span class="keyword">int</span>&gt;, string&gt;&gt; vec;</span><br><span class="line">        <span class="keyword">while</span> ((cur = text.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>, pre)) != string::npos) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;cur-pre, cnt++&#125;,</span><br><span class="line">                                    text.<span class="built_in">substr</span>(pre, cur-pre)));</span><br><span class="line">            pre = cur+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : vec) res += p.second + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">        res[<span class="number">0</span>] += <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1452-People-Whose-List-of-Favorite-Companies-Is-Not-a-Subset-of-Another-List-Medium"><a href="#1452-People-Whose-List-of-Favorite-Companies-Is-Not-a-Subset-of-Another-List-Medium" class="headerlink" title="1452. People Whose List of Favorite Companies Is Not a Subset of Another List #Medium"></a><a href="https://leetcode.com/contest/weekly-contest-189/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/">1452. People Whose List of Favorite Companies Is Not a Subset of Another List</a> #Medium</h2><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，<strong>将每组公司从 <code>vector&lt;string&gt;</code> 重新组织为 <code>set&lt;string&gt;</code>，</strong>从而方便后续查找。</p>
<p>其次，嵌套遍历，<strong>其中 <code>b1</code> 用于标记 <code>vec[i]</code> 是否包含于其他任何组，<code>b2</code> 用于标记 <code>vec[i]</code> 是否包含于 <code>vec[j]</code>。</strong></p>
<h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">peopleIndexes</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; favoriteCompanies)</span> </span>&#123;</span><br><span class="line">        vector&lt;set&lt;string&gt;&gt; vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> vs : favoriteCompanies) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(set&lt;string&gt;(vs.<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">bool</span> b1 = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vec[i].<span class="built_in">size</span>() &gt;= vec[j].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">bool</span> b2 = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> s : vec[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (vec[j].<span class="built_in">find</span>(s) == vec[j].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        b2 = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (b2) b1 = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!b1) res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1453-Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard-Hard"><a href="#1453-Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard-Hard" class="headerlink" title="1453. Maximum Number of Darts Inside of a Circular Dartboard #Hard"></a><a href="https://leetcode.com/contest/weekly-contest-189/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/">1453. Maximum Number of Darts Inside of a Circular Dartboard</a> #Hard</h2><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/discuss/636416/c%2B%2B-O(n2logn)-angular-sweep-(with-picture)">[c++] O(n^2logn), angular sweep (with picture)</a></p>
<p>又是放弃治疗系列，直接看大佬的解法吧。</p>
<h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numPoints</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">double</span>&gt;&gt; <span class="built_in">dist</span>(n, vector&lt;<span class="keyword">double</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                dist[i][j] = dist[j][i] = <span class="built_in">sqrt</span>((points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) * (points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) +</span><br><span class="line">                                               (points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]) * (points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            vector&lt;pair&lt;<span class="keyword">double</span>, <span class="keyword">bool</span>&gt;&gt; angles;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != i &amp;&amp; dist[i][j] &lt;= <span class="number">2</span> * r) &#123;</span><br><span class="line">                    <span class="keyword">double</span> A = <span class="built_in">atan2</span>(points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>], points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">double</span> B = <span class="built_in">acos</span>(dist[i][j] / (<span class="number">2.0</span> * r));</span><br><span class="line">                    <span class="keyword">double</span> alpha = A - B;</span><br><span class="line">                    <span class="keyword">double</span> beta = A + B;</span><br><span class="line">                    angles.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(alpha, <span class="literal">false</span>));</span><br><span class="line">                    angles.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(beta, <span class="literal">true</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(angles.<span class="built_in">begin</span>(), angles.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = angles.<span class="built_in">begin</span>(); it != angles.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((*it).second == <span class="literal">false</span>) ++cnt;</span><br><span class="line">                <span class="keyword">else</span> --cnt;</span><br><span class="line">                res = <span class="built_in">max</span>(res, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B2 - LeetCode Weekly Contest</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Data Structure and Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 May LeetCoding Challenge - Week 4</title>
    <url>/posts/2020-may-leetcoding-challenge-week-4/</url>
    <content><![CDATA[<p>LeetCode 五月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-May-LeetCoding-Challenge/">2020 May LeetCoding Challenge</a> 查看更多。</p>
<span id="more"></span>

<h2 id="May-22nd-Sort-Characters-By-Frequency"><a href="#May-22nd-Sort-Characters-By-Frequency" class="headerlink" title="May 22nd: Sort Characters By Frequency"></a>May 22nd: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3337/">Sort Characters By Frequency</a></h2><p>Given a string, sort it in decreasing order based on the frequency of characters.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;tree&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;eert&quot;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">&#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.</span><br><span class="line">So &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Both &#39;c&#39; and &#39;a&#39; appear three times, so &quot;aaaccc&quot; is also a valid answer.</span><br><span class="line">Note that &quot;cacaca&quot; is incorrect, as the same characters must be together.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;Aabb&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;bbAa&quot;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">&quot;bbaA&quot; is also a valid answer, but &quot;Aabb&quot; is incorrect.</span><br><span class="line">Note that &#39;A&#39; and &#39;a&#39; are treated as two different characters.</span><br></pre></td></tr></table></figure>

<h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用 <code>vector&lt;pair&lt;int, char&gt;&gt; vec(256)</code> 保存字符串 <code>s</code> 中<strong>每个字符出现的次数</strong>及<strong>字符本身</strong>。从大到小进行排序之后，重新拼接成新的字符串 <code>res</code> 即可。</p>
<h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">frequencySort</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;&gt; <span class="built_in">vec</span>(<span class="number">256</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[ch].first++ == <span class="number">0</span>) &#123;</span><br><span class="line">                vec[ch].second = ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">rbegin</span>(), vec.<span class="built_in">rend</span>());</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : vec) &#123;</span><br><span class="line">            res += <span class="built_in">string</span>(p.first, p.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-23rd-Interval-List-Intersections"><a href="#May-23rd-Interval-List-Intersections" class="headerlink" title="May 23rd: Interval List Intersections"></a>May 23rd: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3338/">Interval List Intersections</a></h2><p>Given two lists of <strong>closed</strong> intervals, each list of intervals is pairwise disjoint and in sorted order.</p>
<p>Return the intersection of these two interval lists.</p>
<p><em>(Formally, a closed interval <code>[a, b]</code> (with <code>a &lt;= b</code>) denotes the set of real numbers <code>x</code> with <code>a &lt;= x &lt;= b</code>. The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3].)</em></p>
<p><strong>Example 1:</strong></p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/05.png" style="zoom:80%"/>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A &#x3D; [[0,2],[5,10],[13,23],[24,25]], B &#x3D; [[1,5],[8,12],[15,24],[25,26]]</span><br><span class="line">Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]</span><br><span class="line">Reminder: The inputs and the desired output are lists of Interval objects, and not arrays or lists.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li><p><code>0 &lt;= A.length &lt; 1000</code></p>
</li>
<li><p><code>0 &lt;= B.length &lt; 1000</code></p>
</li>
<li><p><code>0 &lt;= A[i].start, A[i].end, B[i].start, B[i].end &lt; 10^9</code></p>
</li>
</ul>
<h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>因为 <code>A</code> 和 <code>B</code> 的数据量都不大，所以可以嵌套遍历。在遍历过程中：</p>
<ul>
<li><p><strong>如果 <code>a</code> 的右界小于 <code>b</code> 的左界，说明两者不相交，而且因为 <code>B</code> 有序，所以 <code>b</code> 之后的区间也不可能与 <code>a</code> 相交，跳出小循环。</strong></p>
</li>
<li><p><strong>如果 <code>a</code> 的左界大于 <code>b</code> 的右界，说明两者不相交，进入下一次小循环。</strong></p>
</li>
</ul>
<p>如果两者相交，那么两者<strong>左界的最大值和右界的最小值之间就是相交的区间。</strong></p>
<h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">intervalIntersection</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; B) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : A) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> b : B) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[<span class="number">1</span>] &lt; b[<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (a[<span class="number">0</span>] &gt; b[<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;<span class="built_in">max</span>(a[<span class="number">0</span>], b[<span class="number">0</span>]), <span class="built_in">min</span>(a[<span class="number">1</span>], b[<span class="number">1</span>])&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-24th-Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#May-24th-Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="May 24th: Construct Binary Search Tree from Preorder Traversal"></a>May 24th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3339/">Construct Binary Search Tree from Preorder Traversal</a></h2><p>Return the root node of a binary <strong>search</strong> tree that matches the given <code>preorder</code> traversal.</p>
<p><em>(Recall that a binary search tree is a binary tree where for every node, any descendant of <code>node.left</code> has a value <code>&lt; node.val</code>, and any descendant of <code>node.right</code> has a value <code>&gt; node.val</code>. Also recall that a preorder traversal displays the value of the <code>node</code> first, then traverses <code>node.left</code>, then traverses <code>node.right</code>.)</em></p>
<p>It’s guaranteed that for the given test cases there is always possible to find a binary search tree with the given requirements.</p>
<p><strong>Example 1:</strong></p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/09.png" style="zoom:80%"/>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [8,5,1,7,10,12]</span><br><span class="line">Output: [8,5,10,1,7,null,12]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><p><code>1 &lt;= preorder.length &lt;= 100</code></p>
</li>
<li><p><code>1 &lt;= preorder[i] &lt;= 10^8</code></p>
</li>
<li><p>The values of <code>preorder</code> are distinct.</p>
</li>
</ul>
<h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p><strong>利用 <code>func</code> 函数将 <code>preorder</code> 的 <code>[beg, end]</code> 区间分割为根节点、左子树和右子树。</strong>具体地：</p>
<ul>
<li><p>对于根节点，因为 <code>preorder</code> 是前序遍历，所以<strong>根节点必然是 <code>preorder[beg]</code>。</strong></p>
</li>
<li><p>对于左子树和右子树，在 <code>preorder</code> 的 <code>[beg+1, end]</code> 区间内遍历寻找第一个大于 <code>preorder[beg]</code> 的数字，其下标为 <code>idx</code>，那么<strong>左子树必然是 <code>preorder[beg+1, idx-1]</code>，右子树必然是 <code>preorder[idx, end]</code>。</strong></p>
</li>
</ul>
<h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstFromPreorder</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">func</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;preorder, <span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beg &gt; end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = beg + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt;= end &amp;&amp; preorder[idx] &lt; preorder[beg]) ++idx;</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[beg]);</span><br><span class="line">        node-&gt;left = <span class="built_in">func</span>(preorder, beg+<span class="number">1</span>, idx<span class="number">-1</span>);</span><br><span class="line">        node-&gt;right = <span class="built_in">func</span>(preorder, idx, end);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-25th-Uncrossed-Lines"><a href="#May-25th-Uncrossed-Lines" class="headerlink" title="May 25th: Uncrossed Lines"></a>May 25th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3340/">Uncrossed Lines</a></h2><p>We write the integers of <code>A</code> and <code>B</code> (in the order they are given) on two separate horizontal lines.</p>
<p>Now, we may draw connecting lines: a straight line connecting two numbers <code>A[i]</code> and <code>B[j]</code> such that:</p>
<ul>
<li><p><code>A[i] == B[j]</code>;</p>
</li>
<li><p>The line we draw does not intersect any other connecting (non-horizontal) line.</p>
</li>
</ul>
<p>Note that a connecting lines cannot intersect even at the endpoints: each number can only belong to one connecting line.</p>
<p>Return the maximum number of connecting lines we can draw in this way.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A &#x3D; [1,4,2], B &#x3D; [1,2,4]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We can draw 2 uncrossed lines as in the diagram.</span><br><span class="line">We cannot draw 3 uncrossed lines, because the line from A[1]&#x3D;4 to B[2]&#x3D;4 will intersect the line from A[2]&#x3D;2 to B[1]&#x3D;2.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A &#x3D; [2,5,1,2,5], B &#x3D; [10,5,2,1,5,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A &#x3D; [1,3,7,1,7,5], B &#x3D; [1,9,2,5,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li><p><code>1 &lt;= A.length &lt;= 500</code></p>
</li>
<li><p><code>1 &lt;= B.length &lt;= 500</code></p>
</li>
<li><p><code>1 &lt;= A[i], B[i] &lt;= 2000</code></p>
</li>
</ul>
<h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://leetcode.com/problems/uncrossed-lines/discuss/650947/C%2B%2B-DP-with-explanation">C++ DP with explanation</a></p>
<p>P.S. 嗨，看着动态规划的代码感觉还挺好理解的，自己写就写不出来。</p>
<h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.<span class="built_in">size</span>(), n = B.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i] == B[j]) dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span> + dp[i][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="built_in">max</span>(dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-26th-Contiguous-Array"><a href="#May-26th-Contiguous-Array" class="headerlink" title="May 26th: Contiguous Array"></a>May 26th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3341/">Contiguous Array</a></h2><p>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,1,0]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong> The length of the given binary array will not exceed 50,000.</p>
<h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://www.cnblogs.com/grandyang/p/6529857.html">[LeetCode] 525. Contiguous Array 相连的数组 - 刷尽天下</a></p>
<p>遍历 <code>nums</code> 中的数字 <code>num</code>，如果为 <code>1</code> 则累加 <code>1</code> 至 <code>sum</code>，如果为 <code>0</code> 则累加 <code>-1</code> 至 <code>sum</code>。</p>
<p>使用 <code>map&lt;int, int&gt; m</code> 记录首次出现某个 <code>sum</code> 的下标，如果之后再次出现该 <code>sum</code>，说明两者之间的子数组满足题目要求，寻找其长度的最大值即可。</p>
<h4 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(), sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sum += nums[i] ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(sum)) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, i-m[sum]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                m[sum] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-27th-Possible-Bipartition"><a href="#May-27th-Possible-Bipartition" class="headerlink" title="May 27th: Possible Bipartition"></a>May 27th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3342/">Possible Bipartition</a></h2><p>Given a set of <code>N</code> people (numbered <code>1, 2, ..., N</code>), we would like to split everyone into two groups of <strong>any</strong> size.</p>
<p>Each person may dislike some other people, and they should not go into the same group.</p>
<p>Formally, if <code>dislikes[i] = [a, b]</code>, it means it is not allowed to put the people numbered <code>a</code> and <code>b</code> into the same group.</p>
<p>Return <code>true</code> if and only if it is possible to split everyone into two groups in this way.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 4, dislikes &#x3D; [[1,2],[1,3],[2,4]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: group1 [1,4], group2 [2,3]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 3, dislikes &#x3D; [[1,2],[1,3],[2,3]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N &#x3D; 5, dislikes &#x3D; [[1,2],[2,3],[3,4],[4,5],[1,5]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li><p><code>1 &lt;= N &lt;= 2000</code></p>
</li>
<li><p><code>0 &lt;= dislikes.length &lt;= 10000</code></p>
</li>
<li><p><code>1 &lt;= dislikes[i][j] &lt;= N</code></p>
</li>
<li><p><code>dislikes[i][0] &lt; dislikes[i][1]</code></p>
</li>
<li><p>There does not exist <code>i != j</code> for which <code>dislikes[i] == dislikes[j]</code>.</p>
</li>
</ul>
<h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>参考：<a href="https://www.cnblogs.com/grandyang/p/10317141.html">[LeetCode] 886. Possible Bipartition 可能的二分图 - 刷尽天下</a></p>
<p>放弃治疗，直接看大佬的解法吧。</p>
<h4 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">possibleBipartition</span><span class="params">(<span class="keyword">int</span> N, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; dislikes)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">g</span>(N+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(N+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> dislike : dislikes) &#123;</span><br><span class="line">            g[dislike[<span class="number">0</span>]][dislike[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">            g[dislike[<span class="number">1</span>]][dislike[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">colors</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (colors[i] == <span class="number">0</span> &amp;&amp; !<span class="built_in">func</span>(g, i, <span class="number">1</span>, colors)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; g, <span class="keyword">int</span> cur, <span class="keyword">int</span> color, vector&lt;<span class="keyword">int</span>&gt;&amp; colors)</span> </span>&#123;</span><br><span class="line">        colors[cur] = color;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[cur][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (colors[i] == color) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (colors[i] == <span class="number">0</span> &amp;&amp; !<span class="built_in">func</span>(g, i, -color, colors)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="May-28th-Counting-Bits"><a href="#May-28th-Counting-Bits" class="headerlink" title="May 28th: Counting Bits"></a>May 28th: <a href="https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/537/week-4-may-22nd-may-28th/3343/">Counting Bits</a></h2><p>Given a non negative integer number <strong>num</strong>. For every numbers <strong>i</strong> in the range <strong>0 ≤ i ≤ num</strong> calculate the number of 1’s in their binary representation and return them as an array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: [0,1,1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure>

<h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>充分利用之前的结果：计算 <code>i</code> 中 <code>1</code> 的个数，那么只需要知道 <code>i&gt;&gt;1</code> 中 <code>1</code> 的个数（即 <code>res[i&gt;&gt;1]</code>）和 <code>i</code> 的最后一位是否为 <code>1</code>（即 <code>i&amp;0x1</code>），相加即可。</p>
<h4 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(res[i&gt;&gt;<span class="number">1</span>]+(i&amp;<span class="number">0x1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B4 - 2020 LeetCoding Challenge</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Data Structure and Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>Challenge</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Cloudflare Workers 搭建 Google 和 GitHub 镜像网站</title>
    <url>/posts/use-cf-workers-build-google-and-github-mirrors/</url>
    <content><![CDATA[<p>对于 Google 来说，虽然大部分时间都能够在科学环境中网上冲浪，但是<strong>难免有需要在普通环境中使用 Google 的情况，</strong>而对于 GitHub 来说，虽然目前可以无障碍访问，但是<strong>在普通环境中下载某些 Release（比如科学工具的客户端）的速度实在太慢。</strong></p>
<p>如果你也有和我一样的困扰，那么可以考虑<strong>使用 Cloudflare Workers 搭建属于自己的镜像网站，</strong>在普通环境中备用。</p>
<span id="more"></span>

<h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0 写在前面"></a>0 写在前面</h2><p>如果你只是在寻找临时的解决方案，而又不想费劲的话，那么可以直接使用我已经搭建好的镜像网站。</p>
<div class="note warning"><p>但是，请你务必遵守以下约定：</p>
<ol>
<li><p><strong>不滥用服务。</strong>因为每个 Cloudflare 账户每天只有 100,000 次请求的额度。</p>
</li>
<li><p><strong>不登录自己的任何账号。</strong>虽然我保证不拦截你的数据，但是防人之心不可无。</p>
</li>
<li><p><strong>不违反大陆的法律法规。</strong>虽然你需要科学，但是请保持理性。</p>
</li>
</ol>
</div>

<ul>
<li><p>Google 镜像网站：<a href="https://google.progcz.workers.dev/">https://google.progcz.workers.dev/</a></p>
</li>
<li><p>GitHub 镜像网站：<a href="https://github.progcz.workers.dev/">https://github.progcz.workers.dev/</a></p>
</li>
</ul>
<h2 id="1-注册并登录-Cloudflare-账号"><a href="#1-注册并登录-Cloudflare-账号" class="headerlink" title="1 注册并登录 Cloudflare 账号"></a>1 注册并登录 Cloudflare 账号</h2><p>这没啥好说的，前往 <a href="https://www.cloudflare.com/">Cloudflare 官网</a>自行注册并登录，然后<strong>点击「Workers」。</strong></p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/06.png" style="zoom:100%"/>

<h2 id="2-创建新的-Worker-应用"><a href="#2-创建新的-Worker-应用" class="headerlink" title="2 创建新的 Worker 应用"></a>2 创建新的 Worker 应用</h2><p>进入 Workers 页面之后，新用户需要设置用户名（比如 <code>progcz</code>），然后<strong>点击「创建 Worker」。</strong></p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/07.png" style="zoom:100%"/>

<h2 id="3-部署-Worker-应用"><a href="#3-部署-Worker-应用" class="headerlink" title="3 部署 Worker 应用"></a>3 部署 Worker 应用</h2><p><strong>自行修改应用名（比如 <code>test</code>），将 <a href="https://github.com/ProgCZ/code-cloud-a/blob/master/2020/05/cf-workers-mirrors/index.js">index.js</a> 中的代码拷贝至脚本中，点击「保存并部署」，</strong>然后就可以通过 <a href="https://test.progcz.workers.dev/">https://test.progcz.workers.dev/</a>（注意替换应用名 <code>test</code> 和用户名 <code>progcz</code>）访问 Google 的镜像网站了。</p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/08.png" style="zoom:100%"/>

<h2 id="4-自定义-index-js-脚本"><a href="#4-自定义-index-js-脚本" class="headerlink" title="4 自定义 index.js 脚本"></a>4 自定义 index.js 脚本</h2><div class="note info"><p>上文的 <a href="https://github.com/ProgCZ/code-cloud-a/blob/master/2020/05/cf-workers-mirrors/index.js">index.js</a> 其实来自于 <a href="https://github.com/Berkeley-Reject/Workers-Proxy">Berkeley-Reject/Workers-Proxy</a> 仓库，但是代码中设置了对于国内访问的屏蔽，所以为了避免误用，我就在自行修改之后保存了一份。</p>
</div>

<p>可以通过修改以下部分来搭建不同的镜像网站：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Website you intended to retrieve for users.</span></span><br><span class="line"><span class="keyword">const</span> upstream = <span class="string">&#x27;www.google.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Custom pathname for the upstream website.</span></span><br><span class="line"><span class="keyword">const</span> upstream_path = <span class="string">&#x27;/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Website you intended to retrieve for users using mobile devices.</span></span><br><span class="line"><span class="keyword">const</span> upstream_mobile = <span class="string">&#x27;www.google.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Countries and regions where you wish to suspend your service.</span></span><br><span class="line"><span class="keyword">const</span> blocked_region = [<span class="string">&#x27;KP&#x27;</span>, <span class="string">&#x27;SY&#x27;</span>, <span class="string">&#x27;PK&#x27;</span>, <span class="string">&#x27;CU&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// IP addresses which you wish to block from using your service.</span></span><br><span class="line"><span class="keyword">const</span> blocked_ip_address = [<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Whether to use HTTPS protocol for upstream address.</span></span><br><span class="line"><span class="keyword">const</span> https = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Whether to disable cache.</span></span><br><span class="line"><span class="keyword">const</span> disable_cache = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace texts.</span></span><br><span class="line"><span class="keyword">const</span> replace_dict = &#123;</span><br><span class="line">    <span class="string">&#x27;$upstream&#x27;</span>: <span class="string">&#x27;$custom_domain&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;//google.com&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>需要注意的是，上述代码只是 <a href="https://github.com/ProgCZ/code-cloud-a/blob/master/2020/05/cf-workers-mirrors/index.js">index.js</a> 的一小部分。</p>
</div>

<p>比如，对于 GitHub 来说，我们只需要<strong>将 <code>upstream</code>、<code>upstream_mobile</code> 和 <code>replace_dict</code> 中的 <code>google.com</code> 修改为 <code>github.com</code> 即可。</strong></p>
]]></content>
      <categories>
        <category>A1 - 生活随笔</category>
        <category>B2 - 折腾</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Cloudflare</tag>
        <tag>Google</tag>
        <tag>Mirror</tag>
      </tags>
  </entry>
  <entry>
    <title>记录使用 IFTTT + Telegram 订阅 RSS 的推送模板</title>
    <url>/posts/record-use-ifttt-tg-sub-rss-push-template/</url>
    <content><![CDATA[<p>对于大部分使用 RSS 的人来说，RSS 最大的优势便是能够提供<strong>「聚合阅读」</strong>的功能，也就是在一个地方阅读多篇不同来源的文章，而且可以自主选择订阅源，拒绝推荐引擎的「投喂」。然而对于我来说，RSS 还有一个重要的作用在于能够提供<strong>「即时通知」</strong>的功能，也就是<strong>「一旦发生了什么，请立刻通知我」</strong>。</p>
<p>所以，为了实现<strong>「即时通知」</strong>的功能，<strong>可以使用 IFTTT 将 RSS 订阅内容推送至 Telegram 的对话、群组或公开频道，形成属于自己的「信息流」。</strong></p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/05/10.png" style="zoom:100%"/>

<span id="more"></span>

<h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0 写在前面"></a>0 写在前面</h2><p>本文不介绍具体教程，只记录其中使用的推送模板，留作以后参考。</p>
<p><strong>如果你想了解具体教程，推荐参考<a href="https://sword.studio/157.html">这篇文章</a>。</strong></p>
<p>另外，<strong>如果你也使用 <a href="https://docs.rsshub.app/">RSSHub</a>，推荐参考<a href="https://docs.rsshub.app/install/#bu-shu-dao-vercel-zeit-now">官方文档</a>将其部署至 <a href="https://vercel.com/">Vercel</a>，</strong>从而搭建属于自己的订阅引擎。</p>
<h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1 应用场景"></a>1 应用场景</h2><p>在 Telegram 中，我创建了两个公开频道，分别是：</p>
<ul>
<li><p><strong><a href="https://t.me/ProgCZChannel">ProgCZ’s Blog - Channel</a> 用于同步本博客更新的文章。</strong></p>
</li>
<li><p><strong><a href="https://t.me/ProgCZFlow">ProgCZ’s Flow</a> 用于建立专属于自己的信息流。</strong></p>
</li>
</ul>
<h2 id="2-推送模板"><a href="#2-推送模板" class="headerlink" title="2 推送模板"></a>2 推送模板</h2><p>在 IFTTT 中，需要设置推送模板，分为两种情况：</p>
<ul>
<li><p><strong>对于内容较多的订阅源（比如博客文章），只是推送其标题、链接和来源，</strong>模板如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标题：&lt;b&gt;&#123;&#123;EntryTitle&#125;&#125;&lt;&#x2F;b&gt;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">链接：&lt;b&gt;&#123;&#123;EntryUrl&#125;&#125;&lt;&#x2F;b&gt;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">来自：&lt;a href&#x3D;&quot;&#123;&#123;FeedUrl&#125;&#125;&quot;&gt;&#123;&#123;FeedTitle&#125;&#125;&lt;&#x2F;a&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure>

<p>同时，<strong>开启「网页预览」功能。</strong></p>
</li>
<li><p><strong>对于内容较少的订阅源（比如购物优惠），推送其标题、内容、链接和来源，</strong>模板如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标题：&lt;b&gt;&#123;&#123;EntryTitle&#125;&#125;&lt;&#x2F;b&gt;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&#123;&#123;EntryContent&#125;&#125;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">链接：&lt;b&gt;&#123;&#123;EntryUrl&#125;&#125;&lt;&#x2F;b&gt;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">来自：&lt;a href&#x3D;&quot;&#123;&#123;FeedUrl&#125;&#125;&quot;&gt;&#123;&#123;FeedTitle&#125;&#125;&lt;&#x2F;a&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure>

<p>同时，<strong>关闭「网页预览」功能。</strong></p>
</li>
</ul>
<h2 id="3-预览效果"><a href="#3-预览效果" class="headerlink" title="3 预览效果"></a>3 预览效果</h2><p>如果你想预览效果，可以在科学环境中访问 <a href="https://t.me/s/ProgCZChannel">ProgCZ’s Blog - Channel</a> 和 <a href="https://t.me/s/ProgCZFlow">ProgCZ’s Flow</a>。</p>
]]></content>
      <categories>
        <category>A1 - 生活随笔</category>
        <category>B2 - 折腾</category>
      </categories>
      <tags>
        <tag>IFTTT</tag>
        <tag>Telegram</tag>
        <tag>RSS</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次在上海租房的经历</title>
    <url>/posts/record-for-rent-in-shanghai/</url>
    <content><![CDATA[<p>入职之前，我预留了一周的时间用来租房，本以为做好了充足的准备，但还是碰到了很多「租房新手」必踩的坑。果然，<strong>小马还是要自己过一遍河才能知道河水的深浅。</strong></p>
<p>所以，趁着自己的记忆还够新鲜，记录一下这次在上海租房的经历，为以后的自己留下亿点经验和教训。</p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/06/00.png" style="zoom:100%"/>

<span id="more"></span>

<h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1 需求"></a>1 需求</h2><p>在租房之前，需要<strong>梳理一遍自己的需求，哪些是必不可少的，哪些是可以妥协的。</strong></p>
<p>当然，下面列出的这些需求仅适用于我个人，读者需要自行甄别。</p>
<h3 id="1-1-必不可少的"><a href="#1-1-必不可少的" class="headerlink" title="1.1 必不可少的"></a>1.1 必不可少的</h3><div class="note warning"><p>对于「必不可少的」需求，一旦确定之后，即便中介再怎么花言巧语，也不能有半点动摇。</p>
</div>

<ul>
<li><p><strong>距离公司的步行时间不超过 15 分钟，</strong>能够有效提升幸福感。</p>
</li>
<li><p><strong>房子不在一楼或顶楼，</strong>避免一楼的过于潮湿和顶楼的过冷过热。</p>
</li>
<li><p><strong>房间的装修时间至少在一年以上，</strong>避免存在甲醛和苯等污染问题。</p>
<p>我刚开始租的就是新装修了一个月的房间，年少无知的我觉得只要通风就好了，结果在房间里面待了几个小时之后，嗓子就开始不舒服。所以，我只租了几天，就直接与房东违约，押金自然要不回来了，肉疼但还是保命要紧。</p>
</li>
<li><p><strong>独立卫生间，不必与他人分享马桶和浴室，</strong>不管从时间还是空间的角度，都能够有效提升幸福感。</p>
<p>预算充足的话，可以考虑<strong>「整租」独立的一居室</strong>；预算有限的话，可以考虑<strong>「合租」带独卫的卧室</strong>。</p>
</li>
<li><p><strong>家具和家电：床、空调、衣柜、洗衣机、热水器。</strong></p>
</li>
</ul>
<h3 id="1-2-可以妥协的"><a href="#1-2-可以妥协的" class="headerlink" title="1.2 可以妥协的"></a>1.2 可以妥协的</h3><ul>
<li><p><strong>可以晾衣服的地方。</strong></p>
<p>预算充足的话，可以考虑<strong>朝南阳台</strong>；预算有限的话，可以考虑<strong>朝南外窗（带外置晾衣架）</strong>。</p>
<p>当然，朝北也是可以的，毕竟洗衣机甩干后的衣服只要再风干就可以了。</p>
</li>
<li><p><strong>厨房。</strong></p>
</li>
<li><p><strong>家具和家电：冰箱、电视、沙发。</strong></p>
</li>
</ul>
<h3 id="1-3-其他"><a href="#1-3-其他" class="headerlink" title="1.3 其他"></a>1.3 其他</h3><h4 id="1-3-1-关于二房东"><a href="#1-3-1-关于二房东" class="headerlink" title="1.3.1 关于二房东"></a>1.3.1 关于二房东</h4><p>我之前看过的很多租房攻略都有提到：千万不要租二房东的房子。</p>
<p>但是，其实有相当一部分的房源都来自<strong>「职业」二房东</strong>，这种二房东并不是真正的租客，而是因为原房东手中有闲置的房子而又怕麻烦，于是将房子出租给二房东，由二房东来管理出租的事情。真正应该避开的是<strong>「非职业」二房东</strong>，这种二房东是真正的租客，但是因为某些原因而不得已将其转租，在这种情况下就很难保障自己的租房权益。</p>
<p>所以，可以要求<strong>查看二房东的原租房合同和原房东的房产证。</strong>查看租房合同是否长达数年，就可以大致判断是否为「职业」二房东。而且，查看租房合同的开始日期，也可以大致判断房间的装修时间。</p>
<h4 id="1-3-2-关于隔断"><a href="#1-3-2-关于隔断" class="headerlink" title="1.3.2 关于隔断"></a>1.3.2 关于隔断</h4><p>预算有限的话，一般只能考虑隔断的房间了。但是，隔断属于违规建筑，其最大的风险在于<strong>房间可能随时会被政府强拆。</strong></p>
<p>所以，可以要求<strong>在租房合同中注明：如果房间因为违规建筑而导致乙方无法居住，那么不算乙方违约，甲方需退还押金和剩余租金。</strong></p>
<div class="note info"><p>问：如何判断隔断？</p>
<p>答：实地看房时敲一下四周的墙。如果声音很闷，就是原装的墙，如果声音很响，就是隔断的墙。</p>
</div>

<h2 id="2-找房"><a href="#2-找房" class="headerlink" title="2 找房"></a>2 找房</h2><h3 id="2-1-短租"><a href="#2-1-短租" class="headerlink" title="2.1 短租"></a>2.1 短租</h3><p>我没有短租过，但是个人感觉短租的话直接选择<strong>自如或蛋壳</strong>即可，省心省力且价格也没有高很多。</p>
<p>但是，自如或蛋壳被人诟病最多的就是污染问题，所以需要实地看房，感受一下房间内的空气质量。</p>
<h3 id="2-2-长租"><a href="#2-2-长租" class="headerlink" title="2.2 长租"></a>2.2 长租</h3><p>长租的话还是建议找当地的<strong>大中介</strong>，比如链家、我爱我家等。</p>
<h2 id="3-看房"><a href="#3-看房" class="headerlink" title="3 看房"></a>3 看房</h2><p>这一步主要是看房间是否满足需求，同时检查一下房间内设施的基本情况，包括但不仅限于：</p>
<ul>
<li><p>检查是否新装修，是否存在污染问题。</p>
</li>
<li><p>检查防盗门、窗户是否完好。</p>
</li>
<li><p>检查家具、家电是否老化。</p>
</li>
<li><p>检查水管是否通畅、电路是否老化。</p>
</li>
<li><p>检查卫生情况。</p>
</li>
</ul>
<h2 id="4-签订合同"><a href="#4-签订合同" class="headerlink" title="4 签订合同"></a>4 签订合同</h2><p>大中介的合同一般没有什么问题，只是需要注意以下几点：</p>
<ul>
<li><p><strong>明确费用明细，</strong>包括但不仅限于：押金、房租、中介费、服务费、物业费、水电费、煤气费、宽带费、维修费等。</p>
</li>
<li><p><strong>明确房东和房客的违约条款。</strong></p>
</li>
<li><p><strong>拍照或录像记录房间内设施的基本情况，</strong>避免后续的维修纠纷。</p>
</li>
<li><p><strong>（独居女生尤其注意）与房东沟通是否可以换锁。</strong></p>
</li>
<li><p><strong>与房东当面签订合同，拍照留存房东的身份证、房产证，如果是二房东，拍照留存二房东的原租房合同和原房东的身份证、房产证。</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>A1 - 生活随笔</category>
        <category>B1 - 经历</category>
      </categories>
      <tags>
        <tag>Life</tag>
        <tag>Shanghai</tag>
        <tag>Rent</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 August LeetCoding Challenge - Week 1</title>
    <url>/posts/2020-august-leetcoding-challenge-week-1/</url>
    <content><![CDATA[<p>LeetCode 八月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-August-LeetCoding-Challenge/">2020 August LeetCoding Challenge</a> 查看更多。</p>
<span id="more"></span>

<h2 id="August-1st-Detect-Capital"><a href="#August-1st-Detect-Capital" class="headerlink" title="August 1st: Detect Capital"></a>August 1st: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3409/">Detect Capital</a></h2><p>Given a word, you need to judge whether the usage of capitals in it is right or not.</p>
<p>We define the usage of capitals in a word to be right when one of the following cases holds:</p>
<ul>
<li><p>All letters in this word are capitals, like “USA”.</p>
</li>
<li><p>All letters in this word are not capitals, like “leetcode”.</p>
</li>
<li><p>Only the first letter in this word is capital, like “Google”.</p>
</li>
</ul>
<p>Otherwise, we define that this word doesn’t use capitals in a right way.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;USA&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;FlaG&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong> The input will be a non-empty word consisting of uppercase and lowercase latin letters.</p>
<h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>不管字符串 <code>word</code> 的写法是否正确，我都可以列举出其三种正确的写法，放入集合 <code>s</code> 中，判断最初的 <code>word</code> 是否存在于 <code>s</code> 中即可。</p>
<h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">detectCapitalUse</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;string&gt; s;</span><br><span class="line">        string word_cp = word;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : word_cp) &#123;</span><br><span class="line">            ch = <span class="built_in">tolower</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">insert</span>(word_cp);</span><br><span class="line">        word_cp[<span class="number">0</span>] = <span class="built_in">toupper</span>(word_cp[<span class="number">0</span>]);</span><br><span class="line">        s.<span class="built_in">insert</span>(word_cp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : word_cp) &#123;</span><br><span class="line">            ch = <span class="built_in">toupper</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">insert</span>(word_cp);</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">find</span>(word) != s.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="August-2nd-Design-HashSet"><a href="#August-2nd-Design-HashSet" class="headerlink" title="August 2nd: Design HashSet"></a>August 2nd: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3410/">Design HashSet</a></h2><p>Design a HashSet without using any built-in hash table libraries.</p>
<p>To be specific, your design should include these functions:</p>
<ul>
<li><p><code>add(value)</code>: Insert a value into the HashSet.</p>
</li>
<li><p><code>contains(value)</code>: Return whether the value exists in the HashSet or not.</p>
</li>
<li><p><code>remove(value)</code>: Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing.</p>
</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyHashSet hashSet &#x3D; new MyHashSet();</span><br><span class="line">hashSet.add(1);</span><br><span class="line">hashSet.add(2);</span><br><span class="line">hashSet.contains(1);    &#x2F;&#x2F; returns true</span><br><span class="line">hashSet.contains(3);    &#x2F;&#x2F; returns false (not found)</span><br><span class="line">hashSet.add(2);</span><br><span class="line">hashSet.contains(2);    &#x2F;&#x2F; returns true</span><br><span class="line">hashSet.remove(2);</span><br><span class="line">hashSet.contains(2);    &#x2F;&#x2F; returns false (already removed)</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li><p>All values will be in the range of <code>[0, 1000000]</code>.</p>
</li>
<li><p>The number of operations will be in the range of <code>[1, 10000]</code>.</p>
</li>
<li><p>Please do not use the built-in HashSet library.</p>
</li>
</ul>
<h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>采用哈希函数 + 单向链表，将 <code>key</code> 取模后在链表中添加、删除和查找。</p>
<p>P.S. 空间换时间，当然可以把 <code>mod</code> 直接赋值为 <code>1000001</code>。</p>
<h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyHashSet</span>() : <span class="built_in">mod</span>(<span class="number">1000</span>) &#123;</span><br><span class="line">        v.<span class="built_in">resize</span>(mod);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        v[key%mod].<span class="built_in">push_front</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        v[key%mod].<span class="built_in">remove</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;val : v[key%mod]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mod;</span><br><span class="line">    vector&lt;forward_list&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyHashSet* obj = new MyHashSet();</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;remove(key);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;contains(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="August-3rd-Valid-Palindrome"><a href="#August-3rd-Valid-Palindrome" class="headerlink" title="August 3rd: Valid Palindrome"></a>August 3rd: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3411/">Valid Palindrome</a></h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p><strong>Note:</strong> For the purpose of this problem, we define empty string as valid palindrome.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;race a car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>s</code> consists only of printable ASCII characters.</li>
</ul>
<h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用首尾指针 <code>beg</code> 和 <code>end</code> 进行比较，如果不是数字或字母，直接跳过。</p>
<h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> beg = <span class="number">0</span>, end = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (beg &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(s[beg])) &#123;</span><br><span class="line">                ++beg;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(s[end])) &#123;</span><br><span class="line">                --end;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[beg]) != <span class="built_in">tolower</span>(s[end])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++beg;</span><br><span class="line">            --end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="August-4th-Power-of-Four"><a href="#August-4th-Power-of-Four" class="headerlink" title="August 4th: Power of Four"></a>August 4th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3412/">Power of Four</a></h2><p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 16</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>每次累乘 4，实际上都是将二进制形式左移 2 位，循环判断即可。</p>
<h4 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="August-5th-Add-and-Search-Word-Data-structure-design"><a href="#August-5th-Add-and-Search-Word-Data-structure-design" class="headerlink" title="August 5th: Add and Search Word - Data structure design"></a>August 5th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3413/">Add and Search Word - Data structure design</a></h2><p>Design a data structure that supports the following two operations:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void addWord(word)</span><br><span class="line">bool search(word)</span><br></pre></td></tr></table></figure>

<p>search(word) can search a literal word or a regular expression string containing only letters <code>a-z</code> or <code>.</code>. A <code>.</code> means it can represent any one letter.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addWord(&quot;bad&quot;)</span><br><span class="line">addWord(&quot;dad&quot;)</span><br><span class="line">addWord(&quot;mad&quot;)</span><br><span class="line">search(&quot;pad&quot;) -&gt; false</span><br><span class="line">search(&quot;bad&quot;) -&gt; true</span><br><span class="line">search(&quot;.ad&quot;) -&gt; true</span><br><span class="line">search(&quot;b..&quot;) -&gt; true</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<p>You may assume that all words are consist of lowercase letters <code>a-z</code>.</p>
<h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用 <code>um</code> 建立从字符串长度至字符串数组的映射，从而在查询的时候降低时间复杂度。妙啊。</p>
<h4 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">WordDictionary</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds a word into the data structure. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        um[word.<span class="built_in">size</span>()].<span class="built_in">push_back</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character &#x27;.&#x27; to represent any one letter. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str : um[word.<span class="built_in">size</span>()]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">is_match</span>(str, word)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_match</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[i] == <span class="string">&#x27;.&#x27;</span> || word2[i] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (word1[i] != word2[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, vector&lt;string&gt;&gt; um;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary* obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addWord(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="August-6th-Find-All-Duplicates-in-an-Array"><a href="#August-6th-Find-All-Duplicates-in-an-Array" class="headerlink" title="August 6th: Find All Duplicates in an Array"></a>August 6th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3414/">Find All Duplicates in an Array</a></h2><p>Given an array of integers, <code>1 ≤ a[i] ≤ n</code> (<code>n</code> = size of array), some elements appear <strong>twice</strong> and others appear <strong>once</strong>.</p>
<p>Find all the elements that appear <strong>twice</strong> in this array.</p>
<p>Could you do it without extra space and in <code>O(n)</code> runtime?</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[2,3]</span><br></pre></td></tr></table></figure>

<h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>没啥好说的，直接看代码吧。</p>
<h4 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; um;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            ++um[num];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : um) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t.second == <span class="number">2</span>) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(t.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="August-7th-Vertical-Order-Traversal-of-a-Binary-Tree"><a href="#August-7th-Vertical-Order-Traversal-of-a-Binary-Tree" class="headerlink" title="August 7th: Vertical Order Traversal of a Binary Tree"></a>August 7th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/549/week-1-august-1st-august-7th/3415/">Vertical Order Traversal of a Binary Tree</a></h2><p>Given a binary tree, return the vertical order traversal of its nodes values.</p>
<p>For each node at position <code>(X, Y)</code>, its left and right children respectively will be at positions <code>(X-1, Y-1)</code> and <code>(X+1, Y-1)</code>.</p>
<p>Running a vertical line from <code>X = -infinity</code> to <code>X = +infinity</code>, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing <code>Y</code> coordinates).</p>
<p>If two nodes have the same position, then the value of the node that is reported first is the value that is smaller.</p>
<p>Return an list of non-empty reports in order of <code>X</code> coordinate.  Every report will have a list of values of nodes.</p>
<p><strong>Example 1:</strong></p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/06.png" style="zoom:100%"/>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[9],[3,15],[20],[7]]</span><br><span class="line">Explanation:</span><br><span class="line">Without loss of generality, we can assume the root node is at position (0, 0):</span><br><span class="line">Then, the node with value 9 occurs at position (-1, -1);</span><br><span class="line">The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2);</span><br><span class="line">The node with value 20 occurs at position (1, -1);</span><br><span class="line">The node with value 7 occurs at position (2, -2).</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/07.png" style="zoom:50%"/>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7]</span><br><span class="line">Output: [[4],[2],[1,5,6],[3],[7]]</span><br><span class="line">Explanation:</span><br><span class="line">The node with value 5 and the node with value 6 have the same position according to the given scheme.</span><br><span class="line">However, in the report &quot;[1,5,6]&quot;, the node value of 5 comes first since 5 is smaller than 6.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li><p>The tree will have between <code>1</code> and <code>1000</code> nodes.</p>
</li>
<li><p>Each node’s value will be between <code>0</code> and <code>1000</code>.</p>
</li>
</ol>
<h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，核心在于这个声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;&gt; m;</span><br></pre></td></tr></table></figure>

<p><strong>第一个 <code>int</code> 代表节点的 <code>x</code> 坐标，第二个 <code>int</code> 代表节点的 <code>y</code> 坐标，<code>vector&lt;int&gt;</code> 存放节点的值；而且，<code>x</code> 坐标按照默认升序排列，<code>y</code> 坐标按照指定降序排列，适应题目要求。</strong></p>
<p>其次，使用函数 <code>func</code> 遍历树，存放至对应的 <code>vector&lt;int&gt;</code> 中。</p>
<p>最后，遍历 <code>m</code>，将 <code>x</code> 坐标相同的点合并到 <code>v</code> 中，组织为 <code>res</code> 即可。</p>
<h4 id="C-实现-6"><a href="#C-实现-6" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">verticalTraversal</span>(TreeNode* root) &#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;&gt; m;</span><br><span class="line">        <span class="built_in">func</span>(root, <span class="number">0</span>, <span class="number">0</span>, m);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> imp : m) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> ivp : imp.second) &#123;</span><br><span class="line">                <span class="built_in">sort</span>(ivp.second.<span class="built_in">begin</span>(), ivp.second.<span class="built_in">end</span>());</span><br><span class="line">                v.<span class="built_in">insert</span>(v.<span class="built_in">end</span>(), ivp.second.<span class="built_in">begin</span>(), ivp.second.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(TreeNode *node, <span class="keyword">int</span> x, <span class="keyword">int</span> y,</span></span></span><br><span class="line"><span class="function"><span class="params">              map&lt;<span class="keyword">int</span>, map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;&gt; &amp;m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        m[x][y].<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="built_in">func</span>(node-&gt;left, x<span class="number">-1</span>, y<span class="number">-1</span>, m);</span><br><span class="line">        <span class="built_in">func</span>(node-&gt;right, x+<span class="number">1</span>, y<span class="number">-1</span>, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B4 - 2020 LeetCoding Challenge</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Data Structure and Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>Challenge</tag>
      </tags>
  </entry>
  <entry>
    <title>我的工作桌面长啥样</title>
    <url>/posts/what-does-my-work-desktop-look-like/</url>
    <content><![CDATA[<p>不知不觉，已经入职两个月了。</p>
<p>在这两个月里，我一直在适应工作节奏，所以没有时间更新博客（虽然也没什么人看）。</p>
<p>在这两个月里，我的工作桌面也在不断进化，不断适应我的使用习惯，到现在也算是个初级形态了，所以打算在这里梳理一下（其实就是想晒装备）。</p>
<p>先来张工作桌面的整体照片过过瘾：</p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/00.png" style="zoom:100%"/>

<span id="more"></span>

<h2 id="1-「公司发的」MacBook-Pro-16"><a href="#1-「公司发的」MacBook-Pro-16" class="headerlink" title="1 「公司发的」MacBook Pro 16"></a>1 「公司发的」MacBook Pro 16</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/01.png" style="zoom:100%"/>

<p>整个桌面都是围绕着 MacBook Pro 16 来布置的，具体配置：</p>
<table>
<thead>
<tr>
<th>条目</th>
<th>明细</th>
</tr>
</thead>
<tbody><tr>
<td>处理器</td>
<td>2.6 GHz 6‑core Intel Core i7</td>
</tr>
<tr>
<td>图形卡-1</td>
<td>AMD Radeon Pro 5300M 4 GB</td>
</tr>
<tr>
<td>图形卡-2</td>
<td>Intel UHD Graphics 630 1536 MB</td>
</tr>
<tr>
<td>内存</td>
<td>16 GB 2667 MHz DDR4</td>
</tr>
<tr>
<td>储存空间</td>
<td>512 GB SSD</td>
</tr>
</tbody></table>
<p>我已经过了那个对配置敏感的年纪，拿到这个电脑之后也只会感叹「好漂亮」和「好流畅」了。</p>
<p>在日常开发中，MacBook Pro 的性能确实绰绰有余，毕竟编译之类的苦差事都是在远程开发机上完成的，本地只是开开 Chrome 和 VS Code 而已。</p>
<p>P.S. 散热架也是公司发的，感觉薅了太多羊毛。</p>
<h2 id="2-「公司发的」Dell-U2720Q-4K-显示器"><a href="#2-「公司发的」Dell-U2720Q-4K-显示器" class="headerlink" title="2 「公司发的」Dell U2720Q 4K 显示器"></a>2 「公司发的」Dell U2720Q 4K 显示器</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/02.png" style="zoom:100%"/>

<p>两台 4K 显示器的幸福，我以前无法想象，现在除了开会和回家以外，MacBook Pro 基本上都是合盖的状态，因为两个显示器已经够我看的了，多了怕鼠标都挪不过来。</p>
<p>另外一个让人感到幸福的细节，就是可以使用单根 Type-C 数据线合并「显示」、「充电」和「扩展」的功能，显示器的下行接口可以外接键盘和鼠标，极大地节约了 MacBook Pro 的接口数量。</p>
<p>但是我有两台显示器，为了达到显示的最佳效果，还是不可避免地占用了 MacBook Pro 的两个接口。</p>
<h2 id="3-「自己买的」DURGOD-TAURUS-K320-茶轴机械键盘"><a href="#3-「自己买的」DURGOD-TAURUS-K320-茶轴机械键盘" class="headerlink" title="3 「自己买的」DURGOD TAURUS K320 茶轴机械键盘"></a>3 「自己买的」DURGOD TAURUS K320 茶轴机械键盘</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/03.png" style="zoom:100%"/>

<p>当时买这款机械键盘，主要是看中了 PBT 键帽，长期使用不打油的体验也是非常幸福。</p>
<h2 id="4-「自己买的」Logitech-MX-Master-2S-无线蓝牙鼠标"><a href="#4-「自己买的」Logitech-MX-Master-2S-无线蓝牙鼠标" class="headerlink" title="4 「自己买的」Logitech MX Master 2S 无线蓝牙鼠标"></a>4 「自己买的」Logitech MX Master 2S 无线蓝牙鼠标</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/04.png" style="zoom:50%"/>

<p>不解释，办公神器。</p>
<h2 id="5-「自己买的」AirPods-2-无线蓝牙耳机"><a href="#5-「自己买的」AirPods-2-无线蓝牙耳机" class="headerlink" title="5 「自己买的」AirPods 2 无线蓝牙耳机"></a>5 「自己买的」AirPods 2 无线蓝牙耳机</h2><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/08/05.png" style="zoom:25%"/>

<p>MacBook Pro 的耳机孔在右侧，使用的有线耳机总是和使用鼠标的手发生干涉，所以我就入手了 AirPods，在一众无线蓝牙耳机中算是最省心的选择了，连接、音质和通话质量都足够稳定，别无他求。</p>
<h2 id="6-写在最后"><a href="#6-写在最后" class="headerlink" title="6 写在最后"></a>6 写在最后</h2><p>之前在 V2EX 看到一句话，与君共勉：</p>
<blockquote>
<p>入职以后，公司给每位员工发了一台电脑，表面上看是每个人拥有了一台电脑，其实是给每台电脑配了一个人。</p>
</blockquote>
<hr>
<h2 id="7-更新（2020-11-26）"><a href="#7-更新（2020-11-26）" class="headerlink" title="7 更新（2020-11-26）"></a>7 更新（2020-11-26）</h2><p>惯例，先放张工作桌面 2.0 的整体照片：</p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2020/11/00.jpg" style="zoom:100%"/>

<p>改动：</p>
<ul>
<li><p>常年合盖使用的 MBP 被我挪到了左侧，这样键盘就可以向前推进，得到伸展的手臂感觉舒适了许多。</p>
</li>
<li><p>两个显示器都用包装盒架起了一定的高度，仰在椅子上的时候视线更加舒服了。</p>
</li>
<li><p>AirPods 2 =&gt; AirPods Pro，网吧工位少不了降噪。</p>
</li>
</ul>
<h2 id="8-更新（2021-05-31）"><a href="#8-更新（2021-05-31）" class="headerlink" title="8 更新（2021-05-31）"></a>8 更新（2021-05-31）</h2><p>可能是最终形态的工作桌面 3.0：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/11.png"></p>
<p>改动：</p>
<ul>
<li><p>MBP 16 背着实在有点重，换成 MBP 13</p>
</li>
<li><p>双屏虽然爽，但是没啥用，所以归还其中一个显示器，只看正面的显示器</p>
</li>
<li><p>键盘从杜咖茶轴换成阿米洛红轴，键位与 Mac 自带键盘保持一致</p>
</li>
<li><p>常年用鼠标，右手手指关节十分痛苦，所以换成妙控板，左右手交替操作</p>
</li>
<li><p>手机换成 iPhone 12 mini，和 AirPods Pro 都可以无线充电，所以买了绿联的无线充电板，随用随充</p>
</li>
</ul>
]]></content>
      <categories>
        <category>A1 - 生活随笔</category>
        <category>B2 - 折腾</category>
      </categories>
      <tags>
        <tag>Work</tag>
        <tag>Desktop</tag>
        <tag>MacBook Pro</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 August LeetCoding Challenge - Week 2</title>
    <url>/posts/2020-august-leetcoding-challenge-week-2/</url>
    <content><![CDATA[<p>LeetCode 八月挑战专题每日随缘更新，点击类别 <a href="/categories/2020-August-LeetCoding-Challenge/">2020 August LeetCoding Challenge</a> 查看更多。</p>
<span id="more"></span>

<h2 id="August-8th-Path-Sum-III"><a href="#August-8th-Path-Sum-III" class="headerlink" title="August 8th: Path Sum III"></a>August 8th: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/550/week-2-august-8th-august-14th/3417/">Path Sum III</a></h2><p>You are given a binary tree in which each node contains an integer value.</p>
<p>Find the number of paths that sum to a given value.</p>
<p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p>
<p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     &#x2F;  \</span><br><span class="line">    5   -3</span><br><span class="line">   &#x2F; \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure>

<h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用函数 <code>func</code> 对树进行深度优先搜索，对以 <code>node</code> 为起点且满足题目要求的路径进行计数。</p>
<p><code>pathSum(root-&gt;left, sum)</code> 和 <code>pathSum(root-&gt;right, sum)</code> 则是分别给左右节点一次「重新开始」的机会。</p>
<h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(root, sum) + <span class="built_in">pathSum</span>(root-&gt;left, sum) + <span class="built_in">pathSum</span>(root-&gt;right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(TreeNode *node,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = node-&gt;val==sum ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="built_in">func</span>(node-&gt;left, sum-node-&gt;val) + <span class="built_in">func</span>(node-&gt;right, sum-node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>终究还是没能在工作日坚持下来，这个系列终止吧。</p>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B4 - 2020 LeetCoding Challenge</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Data Structure and Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>Challenge</tag>
      </tags>
  </entry>
  <entry>
    <title>充满仪式感的「全年总结」和不太可能坚持下去的「新年计划」</title>
    <url>/posts/summary-for-past-year-and-plan-for-new-year/</url>
    <content><![CDATA[<p>即使新建好了文档，我依然不知道到底该写些什么，但是「写」这个念头就像只怎么也赶不走的乌鸦，一直在我的头顶盘旋。</p>
<p>也许确实是因为仪式感吧，<strong>每到了辞旧迎新的时候，总该有些「落在纸面」的文字，先跟过去的一年和解，再把自己交代给未来的一年。</strong></p>
<p>也罢，就让我这个记忆力和行动力都逐渐退化的人，来一场「全年总结」和「新年计划」吧！</p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/01.jpg" style="zoom:100%"/>

<span id="more"></span>

<h2 id="1-全年总结"><a href="#1-全年总结" class="headerlink" title="1 全年总结"></a>1 全年总结</h2><h3 id="1-1-失去的五个月"><a href="#1-1-失去的五个月" class="headerlink" title="1.1 失去的五个月"></a>1.1 失去的五个月</h3><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/02.jpg" style="zoom:100%"/>

<p>但凡回顾 2020，疫情是怎么都绕不开的话题。</p>
<p>不论性别，不论国籍，不论贫穷或富有，不论疾病或健康，只要你还是这颗蓝色星球上的原住民，或多或少都会受到疫情的影响，唯一的区别就在于这个「或多或少」。</p>
<p>非常幸运，也非常惭愧，我是「或少」中的一员。</p>
<p>不管是磕磕绊绊但还是顺利完成了的学位答辩，还是在家只吃不动而逐渐狂妄的体重涨幅，在这场全人类都无法幸免的灾难面前，看上去都是小事。</p>
<p>因此，我始终对在疫情中离开人世的生命感到惋惜，他们一定也在 2020 年伊始时，怀揣着对新年的希望，如今归于尘土；我也始终对在疫情中奋战在一线的医护人员保持敬意，他们以血肉之躯，构筑起保护我们的钢铁长城。</p>
<div class="note warning"><p>写得越来越像高考作文了。</p>
<p>Whatever, it’s just the way how i was raised and educated.</p>
</div>

<p>不是超级英雄，<strong>只能保护好自己，照顾好家人，足够了。</strong></p>
<h3 id="1-2-十九年寒窗"><a href="#1-2-十九年寒窗" class="headerlink" title="1.2 十九年寒窗"></a>1.2 十九年寒窗</h3><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/03.jpg" style="zoom:100%"/>

<p>毕业算是改变人生的事情当中，意外指数最低的事情了吧。</p>
<p>在这种意义下，与其说是改变人生，<strong>不如说是人生早就被安排成了列车的时刻表，毕业这件事情就在单线轨道的某个站点上等着，没有丝毫悬念。</strong></p>
<p>虽然，我今年所面临的毕业，与以往的毕业不尽相同：</p>
<ul>
<li><p>以往的毕业，从学校到学校，换了环境而已，依然是衣食无忧的学生，终极目标不过是分数、绩点和排名。</p>
</li>
<li><p>今年的毕业，从学校到公司，真正意义上的经济独立，终极目标切换成房子、车子和存款。</p>
</li>
</ul>
<p>当然，还是很感谢曾经作为学生的自己，至少为我打好了阶级跃迁的基础，在人生这一新的阶段能多抢跑几秒钟。</p>
<h3 id="1-3-职场与人生"><a href="#1-3-职场与人生" class="headerlink" title="1.3 职场与人生"></a>1.3 职场与人生</h3><p>互联网大厂的程序员工作，一言以蔽之：节奏快，工作忙，身体累。</p>
<p>比起初入职场的感想，我更想探讨的是，在人生意义这个问题上的心态转变。</p>
<p>这是个老生常谈的哲学命题，我明白。但我还是想说说自己的理解。</p>
<p>过去的二十几年，从我记事开始，我就一直在为别人而活。</p>
<p>说起来非常简单的生活：作为学生，考试考个好成绩；作为儿女，听长辈的话。这样，父母就会很开心，长辈就会称赞我（不管是不是虚情假意），同学也会尊重我（即便是以对待书呆子的态度）。</p>
<p>我好像从来没想过，自己想要什么。</p>
<p>或者说，是周围的人告诉我的「我想要的」：努力学习，努力赚钱，有套自己的房子，有个幸福的家庭。</p>
<p>直到我开始问我自己：然后呢？这一切之后呢？从生到死，人这一生到底是为了什么呢？</p>
<p>过去的一年里，我反复地思考人生的意义，在上下班通勤的路上，在漫长而枯燥的旅途中，在每个放纵自己而熬到很困的深夜里。</p>
<p>而每次我都只能得到同一个答案：<strong>人生的意义是为了开心，为了愉悦的体验，为了舒适的生活。</strong></p>
<p>又是个老生常谈的答案，我明白。但这次，我是真的相信它了。</p>
<h2 id="2-新年计划"><a href="#2-新年计划" class="headerlink" title="2 新年计划"></a>2 新年计划</h2><h3 id="2-1-工作"><a href="#2-1-工作" class="headerlink" title="2.1 工作"></a>2.1 工作</h3><p>无他，努力工作，赚钱买房。</p>
<div class="note warning"><p>但是要牢记的是，身体是革命的本钱！任何事情的达成都不能以牺牲身体健康为前提。</p>
</div>

<h3 id="2-2-读书"><a href="#2-2-读书" class="headerlink" title="2.2 读书"></a>2.2 读书</h3><p>在将 kindle 上未读的书目消灭至只有个位数之前，不再囤书了。</p>
<p>至于数量，不想做硬性要求，只求在有大块时间和舒适状态的时候，能想起来读书，而不是刷手机/看视频。</p>
<h3 id="2-3-按摩-健身"><a href="#2-3-按摩-健身" class="headerlink" title="2.3 按摩/健身"></a>2.3 按摩/健身</h3><p>每周二按摩，每周四健身。</p>
<h3 id="2-4-旅游"><a href="#2-4-旅游" class="headerlink" title="2.4 旅游"></a>2.4 旅游</h3><p>希望每年能有一次旅游，实际上 2021 的额度已经分给厦门了，毕竟厦大百年校庆，是时候回去看看了。</p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/04.jpg" style="zoom:100%"/>

<hr>
<h2 id="3-番外"><a href="#3-番外" class="headerlink" title="3 番外"></a>3 番外</h2><p>新年第一天，去撸了猫猫狗狗，希望能把这份开心延续一整年吧。</p>
<img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/01/05.jpg" style="zoom:100%"/>
]]></content>
      <categories>
        <category>A0 - 总结与计划</category>
      </categories>
      <tags>
        <tag>Plan</tag>
        <tag>Summary</tag>
        <tag>Happiness</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Problem 1 - Two Sum</title>
    <url>/posts/leetcode-problem-two-sum/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/two-sum/">https://leetcode.com/problems/two-sum/</a></p>
<h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定数组 <code>nums</code> 和数字 <code>target</code>，要求在 <code>nums</code> 中找到两个数字，和为 <code>target</code>，返回这两个数字的下标。</p>
<p>保证有且只有一个解，而且同一个数字不能用两次。</p>
<span id="more"></span>

<h2 id="解法一：两层循环，暴力破解"><a href="#解法一：两层循环，暴力破解" class="headerlink" title="解法一：两层循环，暴力破解"></a>解法一：两层循环，暴力破解</h2><p>两层循环，遍历所有可能的数字组合，找到则返回下标。</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p>空间：<code>O(1)</code></p>
</li>
<li><p>时间：<code>O(n^2)</code></p>
</li>
</ul>
<h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：借助-hash-map，用空间换时间"><a href="#解法二：借助-hash-map，用空间换时间" class="headerlink" title="解法二：借助 hash_map，用空间换时间"></a>解法二：借助 <code>hash_map</code>，用空间换时间</h2><p>既可以使用两次循环：</p>
<ul>
<li><p>第一次循环完成「记录」：借助 <code>hash_map</code>，建立数字 <code>target-nums[i]</code> 和下标 <code>i</code> 之间的映射。</p>
</li>
<li><p>第二次循环进行「查询」：如果数字 <code>nums[i]</code> 存在于 <code>hash_map</code> 中，而且不是同一数字（下标不同），说明可以「配对」，则返回该数字下标和 <code>hash_map</code> 中记录的另一数字下标。</p>
</li>
</ul>
<p>也可以使用单次循环：</p>
<ul>
<li>单次循环合并「记录」和「查询」：如果数字 <code>nums[i]</code> 存在于 <code>hash_map</code> 中，说明可以「配对」，则返回该数字下标和 <code>hash_map</code> 中记录的另一数字下标，否则建立数字 <code>target-nums[i]</code> 和下标 <code>i</code> 之间的映射。</li>
</ul>
<blockquote>
<p>单次循环参考：<a href="https://leetcode.com/problems/two-sum/discuss/13/Accepted-C++-O(n)-Solution/263">https://leetcode.com/problems/two-sum/discuss/13/Accepted-C++-O(n)-Solution/263</a></p>
</blockquote>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p>空间：<code>O(n)</code>（不太确定）</p>
</li>
<li><p>时间：<code>O(n)</code></p>
<ul>
<li><code>hash_map</code> 插入、查询、删除的操作，时间复杂度均为 <code>O(1)</code>。</li>
</ul>
</li>
</ul>
<h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><p>两次循环：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; um = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            um[target-nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (um.<span class="built_in">find</span>(nums[i]) != um.<span class="built_in">end</span>() &amp;&amp;</span><br><span class="line">                um[nums[i]] != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;um[nums[i]], i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>单次循环：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; um;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (um.<span class="built_in">find</span>(nums[i]) != um.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;um[nums[i]], i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            um[target-nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B1 - LeetCode Problems</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>LeetCode</tag>
        <tag>Array</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Problem 2 - Add Two Numbers</title>
    <url>/posts/leetcode-problem-add-two-numbers/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/add-two-numbers/">https://leetcode.com/problems/add-two-numbers/</a></p>
<h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>将两个数字的每一位，逆序地拆成两个链表 <code>l1</code> 和 <code>l2</code>，计算这两个数字的和，结果以同样顺序的链表表示。</p>
<span id="more"></span>

<h2 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h2><p>递归遍历两个输入链表，对应节点相加，<code>%10</code> 的值存入输出链表的对应节点，<code>/10</code> 的值存入输出链表的下一节点。</p>
<p>边界条件：两个输入链表的对应节点都为空指针。</p>
<div class="note info"><p>在边界条件下，需要根据下一节点的值是否为 0 而决定是否抛弃该下一节点。为了实现这一点，同时保持代码的 <code>neat</code> 性，传入递归函数的输出链表的对应节点，需要自带下一节点，这就是 C++ 实现中 <code>new ListNode(0, new ListNode(0))</code> 的由来。</p>
</div>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p>空间：<code>O(n)</code></p>
</li>
<li><p>时间：<code>O(n)</code></p>
</li>
</ul>
<h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* root = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">helper</span>(l1, l2, root);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(ListNode* l1, ListNode* l2, ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1 &amp;&amp; !l2) &#123;</span><br><span class="line">            node-&gt;next = node-&gt;next-&gt;val ? node-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        <span class="keyword">int</span> sum = node-&gt;val +</span><br><span class="line">            (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>);</span><br><span class="line">        node-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">        node-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum/<span class="number">10</span>);</span><br><span class="line">        l1 = l1 ? l1-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        l2 = l2 ? l2-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(l1, l2, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：循环"><a href="#解法二：循环" class="headerlink" title="解法二：循环"></a>解法二：循环</h2><p>思路基本上与<a href="#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9A%E9%80%92%E5%BD%92">解法一</a>保持一致，只是将递归形式改为循环形式，同时写法上更加 neat。</p>
<blockquote>
<p>参考：<a href="https://leetcode.com/problems/add-two-numbers/discuss/997/c++-Sharing-my-11-line-c++-solution-can-someone-make-it-even-more-concise">https://leetcode.com/problems/add-two-numbers/discuss/997/c++-Sharing-my-11-line-c++-solution-can-someone-make-it-even-more-concise</a></p>
</blockquote>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p>空间：<code>O(n)</code></p>
</li>
<li><p>时间：<code>O(n)</code></p>
</li>
</ul>
<h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode root(0), *node = &amp;root;</span><br><span class="line">        <span class="keyword">int</span> extra = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || extra) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = extra + </span><br><span class="line">                (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>);</span><br><span class="line">            extra = sum/<span class="number">10</span>;</span><br><span class="line">            node-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            l1 = l1 ? l1-&gt;next : l1;</span><br><span class="line">            l2 = l2 ? l2-&gt;next : l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B1 - LeetCode Problems</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
        <tag>Math</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Problem 3 - Longest Substring Without Repeating Characters</title>
    <url>/posts/leetcode-problem-longest-substring-without-repeating-characters/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a></p>
<h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定字符串，输出最长不重复子串的长度。</p>
<span id="more"></span>

<h2 id="解法一：滑动窗口"><a href="#解法一：滑动窗口" class="headerlink" title="解法一：滑动窗口"></a>解法一：滑动窗口</h2><p>借助 <code>hash_map</code>，建立起<strong>子串中</strong>字符和出现次数的映射，如果 <code>hash_map</code> 中所有字符的出现次数均不大于 <code>1</code>，那么就说明当前子串为不重复子串。</p>
<p>滑动窗口的左右边界分别为 <code>beg</code> 和 <code>end</code>（均初始化为 <code>0</code>），</p>
<ol>
<li><p>在遍历 <code>hash_map</code> 后判断当前子串为不重复子串的情况下，<code>end</code> 不断右移，同时将 <code>hash_map</code> 中对应字符的出现次数 <code>+1</code>。</p>
</li>
<li><p>上述 <code>end</code> 的右移停止，说明 <code>end</code> 到达字符串末尾或者当前子串为重复子串，则记录不重复子串的最大长度。</p>
</li>
<li><p>在遍历 <code>hash_map</code> 后判断当前子串为重复子串的情况下，<code>beg</code> 不断右移，同时将 <code>hash_map</code> 中对应字符的出现次数 <code>-1</code>。</p>
</li>
<li><p>上述 <code>beg</code> 的右移停止，说明 <code>beg</code> 到达 <code>end</code> 或者当前子串不为重复子串，则重复整个流程。</p>
</li>
</ol>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p>空间：<code>O(n)</code>（不太确定）</p>
</li>
<li><p>时间：<code>O(n)</code></p>
</li>
</ul>
<h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; um;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> beg = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; <span class="built_in">helper</span>(um)) &#123;</span><br><span class="line">                um[s[end++]-<span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> len = (end == n &amp;&amp; <span class="built_in">helper</span>(um)) ?</span><br><span class="line">                (end - beg) : (end - beg - <span class="number">1</span>);</span><br><span class="line">            res = <span class="built_in">max</span>(res, len);</span><br><span class="line">            <span class="keyword">while</span> (beg &lt;= end &amp;&amp; !<span class="built_in">helper</span>(um)) &#123;</span><br><span class="line">                um[s[beg++]-<span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="keyword">const</span> unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; um)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = um.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (iter != um.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;second &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++iter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：记旧账"><a href="#解法二：记旧账" class="headerlink" title="解法二：记旧账"></a>解法二：记旧账</h2><p>对于当前字符来说，往前一个一个地推字符，如果某个字符出现了两次，那么该字符前一次出现的下标，一定是最长不重复子串起点的下标减一。</p>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p>空间复杂度：<code>O(1)</code></p>
</li>
<li><p>时间复杂度：<code>O(n)</code></p>
</li>
</ul>
<h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><blockquote>
<p>参考：<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1730/Shortest-O(n)-DP-solution-with-explanations">https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1730/Shortest-O(n)-DP-solution-with-explanations</a></p>
</blockquote>
<div class="note info"><p>因为 <code>char</code> 类型是 8 位，枚举值共有 256 种，所以可以使用 <code>array&lt;int, 256&gt;</code> 代替 <code>unordered_map&lt;char, int&gt;</code> 来实现字符和下标之间的映射。</p>
</div>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        array&lt;<span class="keyword">int</span>, 256&gt; arr; arr.<span class="built_in">fill</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, loc = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 等号右边的 `loc`，就是解法中提到的「前一次出现的下标」</span></span><br><span class="line">            <span class="comment">// 等号右边的 `arr[s[i]]`，就是当前字符的「前一次出现的下标」</span></span><br><span class="line">            <span class="comment">// 两者取最大，更新 `loc`，同时 `loc` 也就是：</span></span><br><span class="line">            <span class="comment">// 对于当前字符来说的，最长不重复子串起点的下标减一</span></span><br><span class="line">            loc = <span class="built_in">max</span>(loc, arr[s[i]]);</span><br><span class="line">            <span class="comment">// 计算：对于当前字符来说的，最长不重复子串的长度</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, i-loc);</span><br><span class="line">            <span class="comment">// 更新 `arr[s[i]]`</span></span><br><span class="line">            arr[s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B1 - LeetCode Problems</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>LeetCode</tag>
        <tag>String</tag>
        <tag>Hash Table</tag>
        <tag>Two Pointers</tag>
        <tag>Sliding Window</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈 Hexo 的主题现状以及我对 NexT 的细节改造</title>
    <url>/posts/1619784301/</url>
    <content><![CDATA[<p>上次发文还是三月初，中间停更了这么久，主要原因在于，之前我对主题源码进行了侵入式的改造，难以升级享受最新的版本特性，于是我就想要重建这个博客站点，兼顾可升级和可改造。</p>
<p>那我就想，既然要重建，何不换个主题试一下？果然，试试就逝世。</p>
<span id="more"></span>

<h2 id="1-Hexo-主题"><a href="#1-Hexo-主题" class="headerlink" title="1 Hexo 主题"></a>1 Hexo 主题</h2><p>在静态博客框架中，Hexo 向来是最受青睐的选择，没有之一。</p>
<p>Jekyll 作为 GitHub 官方支持的框架，可以直接托管源码而无需手动生成静态网页，Hugo 借助 Go 语言的性能优势，号称全世界最快的框架，然而这两者都有一点远落后于 Hexo，那就是最为关键的<strong>主题生态</strong>。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/01.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/02.png"></div></div></div>

<p>作为一个想搭博客的人来说，审美能对自己胃口才是头等大事，所以主题生态只有枝繁叶茂才能留住众口难调的用户。</p>
<p>Hexo 使用 Node.js 开发，从语言层面上就吸引了大批优秀的前端工程师，精美主题可以说是层出不穷。</p>
<p>当然再好的主题也必然有令人不甚满意的地方，这里就把 Butterfly 单拎出来说说问题。</p>
<h3 id="1-1-Butterfly"><a href="#1-1-Butterfly" class="headerlink" title="1.1 Butterfly"></a>1.1 <a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></h3><p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/03.png"></p>
<p>简洁好看，尤其是首屏的视觉效果，足够吸引眼球。这也是我刚开始重建的第一选择。</p>
<p>但是这个主题，说得严重一点，「金玉其外，败絮其中。」</p>
<p>我相信，任何用过 Butterfly 的人，一定会被 <code>_config.butterfly.yml</code> 中混乱的配置给搞得心烦意乱，举个栗子：</p>
<p>配置中有一段是关于网站默认的展示模式，可以选择明亮/暗黑：</p>
<figure class="highlight yaml"><figcaption><span>code</span><a href="https://github.com/jerryc127/hexo-theme-butterfly/blob/dev/_config.yml">_config.yml</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Default display mode (網站默認的顯示模式)</span></span><br><span class="line"><span class="comment"># light (default) / dark</span></span><br><span class="line"><span class="attr">display_mode:</span> <span class="string">light</span></span><br></pre></td></tr></table></figure>

<p>然而在后面又出现了一段是关于暗黑模式，可以选择是否开启：</p>
<figure class="highlight yaml"><figcaption><span>code</span><a href="https://github.com/jerryc127/hexo-theme-butterfly/blob/dev/_config.yml">_config.yml</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># dark mode</span></span><br><span class="line"><span class="attr">darkmode:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Toggle Button to switch dark/light mode</span></span><br><span class="line">    <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Switch dark/light mode automatically (自動切換 dark mode和 light mode)</span></span><br><span class="line">    <span class="comment"># autoChangeMode: 1  Following System Settings, if the system doesn&#x27;t support dark mode, it will switch dark mode between 6 pm to 6 am</span></span><br><span class="line">    <span class="comment"># autoChangeMode: 2  Switch dark mode between 6 pm to 6 am</span></span><br><span class="line">    <span class="comment"># autoChangeMode: false</span></span><br><span class="line">    <span class="attr">autoChangeMode:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>这让我不禁想问：如果我在前面选了默认明亮模式，后面又选了开启暗黑模式，那主题到底是展现哪一种？只有试过之后才能知道，无疑增加了理解成本。</p>
<p>类似的问题还有很多，就不赘述了。总之这个配置文件折磨了我很久，最终不得不放弃。</p>
<div class="note warning"><p>不管怎样，我还是很尊重主题作者的，提供免费开源的主题给大家用，本身就非常值得敬佩。但还是那句话，「若批评不自由，则赞美无意义。」</p>
<p><del>而且感觉主题作者是个暴躁老哥，惹不太起。</del></p>
</div>

<h2 id="2-NexT-改造"><a href="#2-NexT-改造" class="headerlink" title="2 NexT 改造"></a>2 NexT 改造</h2><p>当然，我换过不止 Butterfly 一个主题，然而其他主题即便没有混乱的配置文件，也存在大量优化不到位的细节，所以兜兜转转又回到了 NexT 的怀抱。</p>
<h3 id="2-1-基本配置"><a href="#2-1-基本配置" class="headerlink" title="2.1 基本配置"></a>2.1 基本配置</h3><p><code>_config.yml</code> 和 <code>_config.next.yml</code> 中的配置基本都体现在 <a href="https://github.com/ProgCZ/progcz.github.io/commit/f3cdd681835389803f187024e06124960f48d251">commit f3cdd68</a> 中，不再赘述。</p>
<h3 id="2-2-特殊改造"><a href="#2-2-特殊改造" class="headerlink" title="2.2 特殊改造"></a>2.2 特殊改造</h3><p>特殊改造基本都体现在 <a href="https://github.com/ProgCZ/progcz.github.io/commit/3d56b383f78c1b260edb668ff7ed8e0d6f5232fd">commit 3d56b38</a> 中，没有污染博客源码，只是通过自定义的 js 和 css 来实现。</p>
<ol>
<li><p>替换站点标题中不规范的部分</p>
<p> 如果足够细心的话，你就会发现，在每个分类页面中，标题中的冒号都是英文冒号，不符合中文排版规范：</p>
<p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/04.png"></p>
<p> 替换后：</p>
<p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/05.png"></p>
</li>
<li><p>替换归档页面中不规范的部分</p>
<p> 归档页面中，表达冗余，且英文叹号也不符合中文排版规范：</p>
<p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/06.png"></p>
<p> 替换后：</p>
<p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/07.png"></p>
</li>
<li><p>替换文章信息中不规范的部分</p>
<p> 这个单纯是我看中文逗号不顺眼，不能表达分类之间的层级关系：</p>
<p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/08.png"></p>
<p> 替换后：</p>
<p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/09.png"></p>
</li>
<li><p>替换页脚中不规范的部分</p>
<p> 这个也单纯是我看 copyright 字符不顺眼，有点矮：</p>
<p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/10.png"></p>
<p> 替换后：</p>
<p> <img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/04/11.png"></p>
</li>
<li><p>动画速度调整至 0.3s</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.animated</span> &#123;</span><br><span class="line">    <span class="attribute">animation-duration</span>: <span class="number">0.3s</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>侧边栏字体从 <code>font-size-smaller</code> 调大至 <code>font-size-small</code></p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu-item</span> &#123;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: $font-size-small;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.links-of-author</span> &#123;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: $font-size-small;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.site-state-item-name</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: $font-size-small;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-后记"><a href="#3-后记" class="headerlink" title="3 后记"></a>3 后记</h2><p>折腾告一段落，静下心来好好写些文章吧。</p>
]]></content>
      <categories>
        <category>A1 - 生活随笔</category>
        <category>B2 - 折腾</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>从一封邮件谈谈我为什么不再想要评论系统</title>
    <url>/posts/1620608429/</url>
    <content><![CDATA[<p>在重建站点的过程中，我曾经挣扎过要不要重设评论系统。</p>
<p>基础设施方面，适用于静态博客的各类评论系统都已经发展得比较成熟，比如独立服务的 <a href="https://blog.disqus.com/">Disqus</a>、依赖 GitHub Issues 的 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 和 <a href="https://github.com/utterance/utterances">Utterances</a>、依赖 LeanCloud 等的 <a href="https://github.com/xCss/Valine">Valine</a> 和 <a href="https://github.com/lizheming/waline">Waline</a>，选择颇多。</p>
<p>对于博客而言，评论系统可以让读者更方便地给出反馈，和作者交流彼此的观点和看法。</p>
<p>但是如你所见，我还是没有重设评论系统。</p>
<p>真正促使我放弃的，根本原因是<strong>互联网中随处可见的，无知、无营养甚至充满恶意的评论。</strong></p>
<p>而导火索则是这样一封邮件：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/01.png"></p>
<span id="more"></span>

<h2 id="1-事情起因（我的猜测）"><a href="#1-事情起因（我的猜测）" class="headerlink" title="1 事情起因（我的猜测）"></a>1 事情起因（我的猜测）</h2><p>这位朋友曾经使用 Cloudflare 搭过 Google Scholar 的镜像网站，突然发现不可用了，于是在 Google 搜索相关信息，看到了我一年前写的这篇文章：<a href="https://progcz.com/posts/use-cf-workers-build-google-and-github-mirrors/">使用 Cloudflare Workers 搭建 Google 和 GitHub 镜像网站</a>，认为是我的分享和传播导致了 Cloudflare 不可用，怒不可遏的同时又看到了我的邮箱，于是就有了上面那封邮件。</p>
<h2 id="2-我的看法"><a href="#2-我的看法" class="headerlink" title="2 我的看法"></a>2 我的看法</h2><p>这位朋友的核心观点在于：<strong>这样的知识，自己知道就好了，不要拿出来分享。</strong></p>
<p>可以说是非常自私了，而且多少有点逻辑的人都能看出这里面的问题：<strong>如果每个人都不分享这样的知识，那这位朋友又是从哪里获取到的呢？靠自己顿悟吗？</strong></p>
<p>我有时候也会很纳闷，为什么这么简单的道理，都没有出现在这类朋友的脑子里。</p>
<p>如果是其他网民，我可能可以理解。因为根据<a href="https://finance.sina.com.cn/tech/2020-09-29/doc-iivhuipp7144597.shtml">这篇文章</a>，2020 年网民的规模达 9.40 亿，其中学历达到本科及以上的仅为 8.8％。没有经历过高等教育的话，认知是会受到一定限制。</p>
<p>但是这位朋友提到了谷歌学术，说明至少已经到了高等教育的阶段，却依然这么狭隘，让我匪夷所思。</p>
<p>当然，这种情况不止发生了一次，在评论量较大的博客、在我认为社区氛围很好的 B 站和豆瓣，我都会频繁地看到这类评论，不然我也不会对互联网的评论环境如此失望。</p>
<h2 id="3-我的回复"><a href="#3-我的回复" class="headerlink" title="3 我的回复"></a>3 我的回复</h2><p>尽管无法理解，但我还是出于本能的 defence，回复了这封邮件：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/02.png"></p>
<p>看，这也是我不想要评论系统的原因之一，我不想为了这种事情 defence 啊。</p>
<p>人生已经很累了，照顾好自己的情绪都是一件非常困难的事情，就更不想陷入这种本不该存在的争论之中了。</p>
]]></content>
      <categories>
        <category>A1 - 生活随笔</category>
        <category>B2 - 折腾</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Mail</tag>
        <tag>Comment</tag>
      </tags>
  </entry>
  <entry>
    <title>招商银行朝朝宝：余额宝和零钱通的最佳替代品</title>
    <url>/posts/1620777814/</url>
    <content><![CDATA[<p>当我们看向历史的后视镜，2013 年面世的余额宝确实是一款影响十分深远的产品，它永久地改变了人们对于短期闲置现金的处置方式，更进一步地推动了无现金支付的发展。邯郸学步的零钱通后来也不断壮大，和余额宝一起，成为人们活期理财的首要选择。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/03.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/04.png"></div></div></div>

<p>达成这一切，靠的便是直击用户痛点的两个特性：<strong>高收益率</strong>和<strong>随时支取</strong>。</p>
<p>然而，眼看着互联网金融的繁荣发展，银行自然不能坐以待毙。</p>
<p>招商银行推出的<strong>朝朝宝</strong>便是这样一款狙击余额宝/零钱通的活期理财产品，极大地吸引了以招商银行卡为主力卡的用户，比如我。</p>
<span id="more"></span>

<h2 id="1-在余额宝出现之前，用于日常支出的钱都放在哪里？"><a href="#1-在余额宝出现之前，用于日常支出的钱都放在哪里？" class="headerlink" title="1 在余额宝出现之前，用于日常支出的钱都放在哪里？"></a>1 在余额宝出现之前，用于日常支出的钱都放在哪里？</h2><p>无非三个选择：钱包、银行卡的活期账户、支付宝的余额。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/05.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/06.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/07.png"></div></div></div>

<p>这样看来，钱包和银行卡的活期账户明显是更优的选择，因为</p>
<ul>
<li>如果场景不支持扫码，可以用钱包中的现金，或者 POS 机刷银行卡支付。</li>
<li>如果场景支持扫码，可以在支付宝中选择使用银行卡支付。</li>
</ul>
<p>更何况，放在银行卡里，还有聊胜于无的利息收入，放在支付宝余额里，就真的只是放着而已。</p>
<p>所以，<strong>用户好像没有什么动力，特地把银行卡里的钱转到支付宝里。</strong></p>
<h2 id="2-余额宝解决了什么痛点？"><a href="#2-余额宝解决了什么痛点？" class="headerlink" title="2 余额宝解决了什么痛点？"></a>2 余额宝解决了什么痛点？</h2><h3 id="2-1-高收益率"><a href="#2-1-高收益率" class="headerlink" title="2.1 高收益率"></a>2.1 高收益率</h3><p>众所周知，余额宝本质上属于货币基金。</p>
<blockquote>
<p>货币基金的运作方式可以简单理解为，基金将用户的钱集中起来，去跟银行谈一个利息较高的大额存款，再将利息作为收益返还给用户。</p>
</blockquote>
<p>好，这就为余额宝带来了第一个极具吸引力的特性：<strong>我把钱放在余额宝里，是有收益的，而且收益远高于银行卡的活期利息。</strong></p>
<div class="note info"><p>热知识：2014 年，余额宝的七日年化曾高达 6.76%，万份收益 1.8 元左右。</p>
</div>

<p>但是，用户还有个小问题：我为啥不选择其他货币基金？</p>
<h3 id="2-2-随时支取"><a href="#2-2-随时支取" class="headerlink" title="2.2 随时支取"></a>2.2 随时支取</h3><p>我们都知道，余额宝可以用于扫码支付、淘宝购物。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/08.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/09.png"></div></div></div>

<p>其支撑就在于，不同于当时的其他货币基金，余额宝提供了 T+0 的快速赎回方式。</p>
<p>好，第二个极具吸引力的特性向我们走来：<strong>我把钱放在余额宝里，24 小时均可取出，几分钟内到账。</strong></p>
<p>如今，众多「宝宝」类产品，比如天天基金的活期宝，其背后的货币基金也可以实现 T+0，但是无法打通消费场景，这是来自于支付宝的降维打击。</p>
<h2 id="3-余额宝还有什么缺点？"><a href="#3-余额宝还有什么缺点？" class="headerlink" title="3 余额宝还有什么缺点？"></a>3 余额宝还有什么缺点？</h2><h3 id="3-1-收益率不断下滑"><a href="#3-1-收益率不断下滑" class="headerlink" title="3.1 收益率不断下滑"></a>3.1 收益率不断下滑</h3><p>我不是经济专家，无法准确给出收益率下滑的原因。</p>
<p>但是对于一个用户而言，这就让我把钱转到余额宝里的动力越来越低。</p>
<div class="note warning"><p>内心 OS：每天就那么点收益，何必费那个劲呢？</p>
</div>

<h3 id="3-2-资金分散，不便管理"><a href="#3-2-资金分散，不便管理" class="headerlink" title="3.2 资金分散，不便管理"></a>3.2 资金分散，不便管理</h3><p>这实际上并不是余额宝的缺点，而是支付宝和微信支付二分天下带来的问题。</p>
<p>对于日常收支、投资理财，我有非常清晰的记录和规划。我每月初都会花十几分钟的时间整理一个表格，上面清晰地记录着我的每一分钱都放在什么地方，同时根据现状做出调整和规划。</p>
<p>具体到用于日常支出的短期闲置现金，我一般会在余额宝和零钱通分别放 5K 整。这样的话，下个月初我就能根据剩多少钱，快速算出上个月的支出。如果有异常，再去查看账单明细，看看是什么事情花费较多，有没有可优化的空间。</p>
<p>虽然管理两处也不是什么特别麻烦的事情，但是如果能合为一处岂不快哉。</p>
<h2 id="4-为什么推荐朝朝宝？"><a href="#4-为什么推荐朝朝宝？" class="headerlink" title="4 为什么推荐朝朝宝？"></a>4 为什么推荐朝朝宝？</h2><p>对于我而言，朝朝宝完美解决了上面两个缺点。</p>
<h3 id="4-1-收益方面"><a href="#4-1-收益方面" class="headerlink" title="4.1 收益方面"></a>4.1 收益方面</h3><p>朝朝宝的七日年化高达 3.10%，万分收益 0.8 元左右。</p>
<div class="note warning"><p>作为对比，支付宝的七日年化只有 2.12%，万份收益 0.5 元左右。</p>
</div>

<p>这一点主要得益于<strong>朝朝宝背后并不是货币基金，而是五款风险评级均为 R1 的招行代销理财产品，</strong>在收益较高的同时也保证了资金的安全性。</p>
<blockquote>
<p>其中一款代销理财细节可以看官网资料：<a href="http://www.cmbchina.com/cfweb/personal/saproductdetail.aspx?saaCod=D07&funCod=8920">招银理财招赢聚宝盆 1 号现金管理类理财计划</a></p>
</blockquote>
<p>当然，收益率会不会像余额宝一样下滑，还需要持续观察，至少现在是高的对吧。</p>
<h3 id="4-2-管理方面"><a href="#4-2-管理方面" class="headerlink" title="4.2 管理方面"></a>4.2 管理方面</h3><p>朝朝宝支持支付宝支付，微信支付，银行转账，ATM 取款，还信用卡、花呗和贷款，购买银行理财和基金等，如果不出意外的话，应该还支持 Apple Pay 或者其他 Pay（我没试过）。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/05/10.png"></p>
<p>我只需要每月初在朝朝宝里放 1W 整，不管是支付宝还是微信支付，在扫码后选择使用银行卡支付即可。</p>
<p>这样的话，我就可以集中管理生活中各个方面的支出情况，我直接大呼过瘾。</p>
<div class="note warning"><p>需要注意的是，朝朝宝最多可转入 5W，每日也最多可转出 5W，对于日常支出较多的人来说可能不是很友好。</p>
</div>

<h2 id="5-后记"><a href="#5-后记" class="headerlink" title="5 后记"></a>5 后记</h2><p>这不是朝朝宝的软文（招行也不至于卑贱到来找我写软文），单纯只是我想分享一下好的理财产品。不构成理财建议，但是如果对你有所帮助，那就再好不过了。也祝自己早日暴富！</p>
]]></content>
      <categories>
        <category>A1 - 生活随笔</category>
        <category>B3 - 理财</category>
      </categories>
      <tags>
        <tag>招商银行</tag>
        <tag>朝朝宝</tag>
        <tag>余额宝</tag>
        <tag>零钱通</tag>
        <tag>活期理财</tag>
      </tags>
  </entry>
  <entry>
    <title>上海迪士尼乐园攻略：两人行一日游</title>
    <url>/posts/1624282620/</url>
    <content><![CDATA[<p>从去年开始，女朋友就一直念着想去上海迪士尼乐园，然而疫情使得计划一拖再拖，直到上周六才如愿以偿。</p>
<p>不得不说，迪士尼乐园的确是真实世界中最接近于「童话王国」的地方，迪士尼作品中的经典形象在这里都触手可及。你可以是杰克船长的水手，也可以是冰雪女王的朋友；你可以坐在蜜罐里和小熊维尼打招呼，也可以跟着小飞侠穿梭在城市的上空。</p>
<p>迪士尼满足你的童心、少女心，以及对于浪漫的一切幻想。<del>只要你肯花钱。</del></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/25.png"></p>
<span id="more"></span>

<div class="note info"><p>友情提示：上海迪士尼乐园的政策几乎每月一变，可能导致攻略失效，比如很多攻略中提到的 FP 早就不复存在了，所以以下内容与其称为攻略，不如说是记录，仅供参考。</p>
</div>

<h2 id="1-购买门票"><a href="#1-购买门票" class="headerlink" title="1 购买门票"></a>1 购买门票</h2><p>我是在美团上购买的门票，价格大概是官方打 93 折。</p>
<blockquote>
<p>需要注意的是，不管是什么渠道购买的门票，都会有一行类似的注意事项：</p>
<p><em>乐园门票一经售出不可转让、不可退款，除非法律另有规定。指定日门票可在尚有余票且补足票价差额的前提下，于有效日的两日前更换两次等值或者更高价值的指定日门票。</em></p>
<p>而且我当时看到只能更换为当月的门票，所以建议提前规划行程，尤其注意天气。</p>
</blockquote>
<h2 id="2-准备随身携带的物品"><a href="#2-准备随身携带的物品" class="headerlink" title="2 准备随身携带的物品"></a>2 准备随身携带的物品</h2><p>记得携带身份证、口罩（疫情期间）、手机、移动电源及数据线、一次性雨衣（漂流项目和下雨天气）、空的非玻璃水瓶（园区内直饮水）、防晒用品（夏季）、小风扇（夏季）等等。</p>
<p>不能携带自拍杆、折叠椅、自热食物等等。</p>
<p>更多参考<a href="https://www.shanghaidisneyresort.com/rules/">上海迪士尼乐园游客须知</a>。</p>
<h2 id="3-住宿"><a href="#3-住宿" class="headerlink" title="3 住宿"></a>3 住宿</h2><p>我本身在上海，不用考虑住宿，所以这一部分就跳过了。</p>
<h2 id="4-入园"><a href="#4-入园" class="headerlink" title="4 入园"></a>4 入园</h2><p>如果购买早享卡，可以提前一个小时入园。</p>
<p>如果不买早享卡，建议提前至少一个小时到达园区门口排队，有包游客需要过有包安检，比较慢，无包游客只需要过安检门，比较快。</p>
<blockquote>
<p>需要注意的是，同一订单的多张门票必须同时入园，所以要么分不同订单来购买门票，要么同行的人都排有包安检，除非大家都不带包。</p>
</blockquote>
<h2 id="5-游玩"><a href="#5-游玩" class="headerlink" title="5 游玩"></a>5 游玩</h2><p>提前下载好上海迪士尼乐园的 APP，入园后将同行门票绑定在同一个 APP 内，优先领取预约等候卡，没有预约等候卡的项目可以在游玩过程中视排队情况购买尊享卡。</p>
<ol>
<li><p>领取预约等候卡，等于拥有在高峰时段排队的资格。每天可领取预约等候卡的项目不固定，可以当日在 APP 内查询。</p>
</li>
<li><p>购买尊享卡，等于拥有在任意时段插队的资格。如果想买尊享卡的项目比较多，可以考虑八件套或者六件套。</p>
</li>
</ol>
<p>放张盗来的图，热门项目基本一览无余。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/26.png"></p>
<p>再来分享一波自己拍的照片。</p>
<p>两个必看的舞台剧：风暴来临·杰克船长之惊天特技大冒险 &amp; 冰雪奇缘·欢唱盛会。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/27.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/28.png"></div></div></div>

<p>在漫威总部见到了钢铁侠的历代战甲，还碰到了钢铁侠的 COS，可惜是个视频没办法传上来。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/29.png"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/30.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/31.png"></div></div></div>

<p>夜晚的旋转木马，可以说是如梦如幻了。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/32.png"></p>
<h2 id="6-就餐"><a href="#6-就餐" class="headerlink" title="6 就餐"></a>6 就餐</h2><p>图个省事，我和女朋友在园区内吃的午饭和晚饭，每顿人均 100 左右。</p>
<p>午饭在加勒比海盗附近的巴博萨烧烤，左图的秋刀鱼套餐很不错。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/33.png"></div><div class="group-picture-column"><img data-src="https://cdn.jsdelivr.net/gh/ProgCZ/image-cloud-a@master/2021/06/34.png"></div></div></div>

<p>晚饭在创极速光轮附近的星露台餐厅，钢铁侠牛肉汉堡非常难吃，不放图了。</p>
]]></content>
      <categories>
        <category>A1 - 生活随笔</category>
        <category>B1 - 经历</category>
      </categories>
      <tags>
        <tag>上海</tag>
        <tag>迪士尼</tag>
        <tag>加勒比海盗</tag>
        <tag>漫威</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 August LeetCoding Challenge - Week 1</title>
    <url>/posts/1627831620/</url>
    <content><![CDATA[<p>LeetCode 八月挑战专题，第一周，每日随缘更新。</p>
<span id="more"></span>

<h2 id="August-1st-Making-A-Large-Island"><a href="#August-1st-Making-A-Large-Island" class="headerlink" title="August 1st: Making A Large Island"></a>August 1st: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/613/week-1-august-1st-august-7th/3835/">Making A Large Island</a></h2><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定 <code>n*n</code> 的矩阵，每格中的数字为 <code>0</code> 或 <code>1</code>，可以将其中的 <code>1</code> 个格子从 <code>0</code> 置为 <code>1</code>，求解矩阵中最大「岛屿」的面积。</p>
<p>其中，「岛屿」是指在上、下、左、右四个方向中，连通起来的 <code>1</code> 的区域。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><blockquote>
<p>参考：<a href="https://leetcode.com/problems/making-a-large-island/discuss/1376700/C%2B%2B-BFS-O(n2)-5-%3A(">C++ BFS  O(n^2) 5% :(</a></p>
</blockquote>
<p>首先，遍历矩阵，使用 BFS 探索所有的岛屿，标记为不同的 <code>flag</code>，并且使用 <code>record</code> 记录不同 <code>flag</code> 对应的岛屿面积 <code>cnt</code>。</p>
<p>其次，遍历矩阵，找出上、下、左、右四个方向所对应的 <code>flag</code>，累加其 <code>cnt</code> 即可。</p>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li><p>空间：<code>O(n^2)</code></p>
</li>
<li><p>时间：<code>O(n^4)</code></p>
</li>
</ul>
<h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dirs[<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; record, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>(), cnt = <span class="number">0</span>;</span><br><span class="line">        queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">        grid[i][j] = flag;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, y] = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; dir : dirs) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = x + dir.first, ny = y + dir.second;</span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] == <span class="number">1</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">                    grid[nx][ny] = flag;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        record[flag] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestIsland</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>(), flag = <span class="number">2</span>, res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; record;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">bfs</span>(grid, record, i, j, flag++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                unordered_set&lt;<span class="keyword">int</span>&gt; us;</span><br><span class="line">                us.<span class="built_in">insert</span>(grid[i][j]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; dir : dirs) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ni = i + dir.first, nj = j + dir.second;</span><br><span class="line">                    <span class="keyword">if</span> (ni &gt;= <span class="number">0</span> &amp;&amp; ni &lt; n &amp;&amp; nj &gt;= <span class="number">0</span> &amp;&amp; nj &lt; n) &#123;</span><br><span class="line">                        us.<span class="built_in">insert</span>(grid[ni][nj]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> sum = !grid[i][j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; flag : us) &#123;</span><br><span class="line">                    sum += record[flag];</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="August-2nd-Two-Sum"><a href="#August-2nd-Two-Sum" class="headerlink" title="August 2nd: Two Sum"></a>August 2nd: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/613/week-1-august-1st-august-7th/3836/">Two Sum</a></h2><h3 id="大意-1"><a href="#大意-1" class="headerlink" title="大意"></a>大意</h3><p>给定数组 <code>nums</code> 和数字 <code>target</code>，要求在 <code>nums</code> 中找到两个数字，和为 <code>target</code>，返回这两个数字的下标。</p>
<p>题目保证有且只有一个解，而且同一个数字不能用两次。</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>以前做过，参见：<a href="/posts/leetcode-problem-two-sum/#%E8%A7%A3%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%80%9F%E5%8A%A9-hash-map%EF%BC%8C%E7%94%A8%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4">LeetCode Problem 1 - Two Sum</a></p>
<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li><p>空间：<code>O(n)</code></p>
</li>
<li><p>时间：<code>O(n)</code></p>
</li>
</ul>
<h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; record;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = record.<span class="built_in">find</span>(target-nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (iter != record.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, iter-&gt;second&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            record[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="August-3rd-Subsets-II"><a href="#August-3rd-Subsets-II" class="headerlink" title="August 3rd: Subsets II"></a>August 3rd: <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge-2021/613/week-1-august-1st-august-7th/3837/">Subsets II</a></h2><h3 id="大意-2"><a href="#大意-2" class="headerlink" title="大意"></a>大意</h3><p>给定一个数组 <code>nums</code>，其中可能有重复元素，返回所有可能的子集，要求子集之间不重复。</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>使用 <code>set&lt;vector&lt;int&gt;&gt; s</code> 来存放所有的子集，避免出现 <code>[1,2]</code> 和 <code>[1,2]</code> 这种重复 case。</p>
<p>将 <code>nums</code> 进行排序，避免出现 <code>[1,2,2]</code> 和 <code>[2,1,2]</code> 这种重复 case。</p>
<p>遍历 <code>nums</code>，将遍历到的 <code>num</code> 与 <code>s</code> 中的每个数组组成新的数组，添加至 <code>s</code> 中即可。</p>
<h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li><p>空间：<code>O(2^n)</code>（不确定）</p>
</li>
<li><p>时间：<code>O(n*2^n)</code></p>
</li>
</ul>
<h4 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        set&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">        s.<span class="built_in">insert</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;&#125;);</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            set&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ts</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> vi : ts) &#123;</span><br><span class="line">                vi.<span class="built_in">push_back</span>(num);</span><br><span class="line">                s.<span class="built_in">insert</span>(vi);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B5 - 2021 LeetCoding Challenge</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Problem 5 - Longest Palindromic Substring</title>
    <url>/posts/1627949478/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/longest-palindromic-substring/">https://leetcode.com/problems/longest-palindromic-substring/</a></p>
<h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定字符串 <code>s</code>，返回其中的最长回文子串。</p>
<span id="more"></span>

<h2 id="解法一：遍历扩散"><a href="#解法一：遍历扩散" class="headerlink" title="解法一：遍历扩散"></a>解法一：遍历扩散</h2><p>遍历字符串 <code>s</code>，从每个字符的位置 <code>i</code> 向外扩散，寻找最长回文子串。</p>
<p>需要注意的是，回文子串的长度有奇偶之分，因此：对于奇数长度，从 <code>i</code> 扩散，对于偶数长度，从 <code>i</code> 和 <code>i+1</code> 向外扩散。</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p>空间：<code>O(1)</code></p>
</li>
<li><p>时间：<code>O(n^2)</code></p>
</li>
</ul>
<h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), ss_start = <span class="number">0</span>, ss_length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">helper</span>(s, i, i, ss_start, ss_length);</span><br><span class="line">            <span class="built_in">helper</span>(s, i, i+<span class="number">1</span>, ss_start, ss_length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(ss_start, ss_length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(string&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span>&amp; ss_start, <span class="keyword">int</span>&amp; ss_length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left; ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ss_length &lt; right - left - <span class="number">1</span>) &#123;</span><br><span class="line">            ss_start = left + <span class="number">1</span>;</span><br><span class="line">            ss_length = right - left - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：马拉车算法"><a href="#解法二：马拉车算法" class="headerlink" title="解法二：马拉车算法"></a>解法二：马拉车算法</h2><p>以前写过，参见：<a href="/posts/apply-manacher-s-algorithm-to-solve-longest-palindromic-substring-problem/">使用马拉车算法解决最长回文子串问题</a></p>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B1 - LeetCode Problems</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>LeetCode</tag>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Problem 7 - Reverse Integer</title>
    <url>/posts/1627951198/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/reverse-integer/">https://leetcode.com/problems/reverse-integer/</a></p>
<h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>给定 32 位整数 <code>x</code>，返回反转后的数字，如果存在溢出，则返回 <code>0</code>。</p>
<span id="more"></span>

<h2 id="解法一：模运算"><a href="#解法一：模运算" class="headerlink" title="解法一：模运算"></a>解法一：模运算</h2><p>通过模运算来反转 <code>x</code> 即可。</p>
<p>需要注意的是，判断反转后的数字 <code>res</code> 是否会溢出，这个判断不能在每次模运算之后（因为如果溢出，此时已经溢出），而应该在每次模运算之前，判断 <code>res</code> 是否超出了 <code>INT_MAX/10</code>。</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p>空间：<code>O(1)</code></p>
</li>
<li><p>时间：<code>O(n)</code></p>
</li>
</ul>
<h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(res) &gt; INT_MAX/<span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>A3 - LeetCode</category>
        <category>B1 - LeetCode Problems</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>LeetCode</tag>
        <tag>Math</tag>
      </tags>
  </entry>
</search>
